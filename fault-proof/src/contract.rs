//! Contract bindings for the fault proof system.
//!
//! Contract types (instances, events, function calls) are imported from forge-generated
//! bindings in `op-succinct-bindings`, which are the source of truth for ABI correctness.
//!
//! Enums (GameStatus, ProposalStatus) are kept as hand-written `sol!` definitions because
//! forge bind generates UDT wrappers (`struct GameStatus(u8)`) instead of proper Rust enums,
//! and we need named variants for pattern matching and Serialize/Deserialize derives.

use alloy_sol_macro::sol;
use serde::{Deserialize, Serialize};

// Re-export contract modules from forge-generated bindings.
// These are auto-synced from Solidity, preventing ABI drift.
pub use op_succinct_bindings::{
    anchor_state_registry::AnchorStateRegistry, dispute_game_factory::DisputeGameFactory,
    i_anchor_state_registry::IAnchorStateRegistry, i_dispute_game::IDisputeGame,
    i_fault_dispute_game::IFaultDisputeGame,
    op_succinct_fault_dispute_game::OPSuccinctFaultDisputeGame, L2Output,
};

// Hand-written types that need custom derives or are not generated by forge bind.
sol! {
    /// The current status of the dispute game.
    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    #[serde(rename_all = "SCREAMING_SNAKE_CASE")]
    enum GameStatus {
        IN_PROGRESS,
        CHALLENGER_WINS,
        DEFENDER_WINS
    }

    /// The proposal status within a dispute game.
    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    enum ProposalStatus {
        Unchallenged,
        Challenged,
        UnchallengedAndValidProofProvided,
        ChallengedAndValidProofProvided,
        Resolved
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod game_status {
        use super::*;

        #[test]
        fn try_from_valid_values() {
            assert_eq!(GameStatus::try_from(0u8).unwrap(), GameStatus::IN_PROGRESS);
            assert_eq!(GameStatus::try_from(1u8).unwrap(), GameStatus::CHALLENGER_WINS);
            assert_eq!(GameStatus::try_from(2u8).unwrap(), GameStatus::DEFENDER_WINS);
        }

        #[test]
        fn try_from_out_of_range() {
            assert!(GameStatus::try_from(3u8).is_err());
        }

        #[test]
        fn serde_roundtrip() {
            for variant in
                [GameStatus::IN_PROGRESS, GameStatus::CHALLENGER_WINS, GameStatus::DEFENDER_WINS]
            {
                let json = serde_json::to_string(&variant).unwrap();
                let deserialized: GameStatus = serde_json::from_str(&json).unwrap();
                assert_eq!(variant, deserialized);
            }
        }
    }

    mod proposal_status {
        use super::*;

        #[test]
        fn try_from_valid_values() {
            assert_eq!(ProposalStatus::try_from(0u8).unwrap(), ProposalStatus::Unchallenged);
            assert_eq!(ProposalStatus::try_from(1u8).unwrap(), ProposalStatus::Challenged);
            assert_eq!(
                ProposalStatus::try_from(2u8).unwrap(),
                ProposalStatus::UnchallengedAndValidProofProvided
            );
            assert_eq!(
                ProposalStatus::try_from(3u8).unwrap(),
                ProposalStatus::ChallengedAndValidProofProvided
            );
            assert_eq!(ProposalStatus::try_from(4u8).unwrap(), ProposalStatus::Resolved);
        }

        #[test]
        fn try_from_out_of_range() {
            assert!(ProposalStatus::try_from(5u8).is_err());
        }

        #[test]
        fn serde_roundtrip() {
            for variant in [
                ProposalStatus::Unchallenged,
                ProposalStatus::Challenged,
                ProposalStatus::UnchallengedAndValidProofProvided,
                ProposalStatus::ChallengedAndValidProofProvided,
                ProposalStatus::Resolved,
            ] {
                let json = serde_json::to_string(&variant).unwrap();
                let deserialized: ProposalStatus = serde_json::from_str(&json).unwrap();
                assert_eq!(variant, deserialized);
            }
        }
    }
}
