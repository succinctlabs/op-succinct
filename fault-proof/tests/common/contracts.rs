//! Contract deployment utilities for E2E tests.

use alloy_primitives::Address;
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use tracing::info;

/// Container for deployed contracts
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeployedContracts {
    pub factory: Address,
    pub portal: Address,
    pub access_manager: Address,
    pub game_implementation: Address,
}

/// Typed structure for forge script output
#[derive(Debug, Deserialize)]
struct ForgeOutput {
    returns: ForgeReturns,
    success: bool,
}

/// Forge returns structure containing contract addresses
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct ForgeReturns {
    game_implementation: AddressField,
    #[allow(dead_code)]
    sp1_verifier: AddressField,
    #[allow(dead_code)]
    anchor_state_registry: AddressField,
    access_manager: AddressField,
    optimism_portal2: AddressField,
    factory_proxy: AddressField,
}

/// Address field structure
#[derive(Debug, Deserialize)]
struct AddressField {
    #[allow(dead_code)]
    internal_type: String,
    value: String,
}

/// Parse forge script output to extract contract addresses
fn parse_forge_output(output: &str) -> Result<DeployedContracts> {
    // Get the first line which should be valid JSON
    let json_line = output.lines().next().ok_or_else(|| anyhow!("No output from forge script"))?;

    // Parse the forge output structure
    let forge_output: ForgeOutput = serde_json::from_str(json_line)
        .map_err(|e| anyhow!("Failed to parse forge output JSON: {}\n{}", e, json_line))?;

    if !forge_output.success {
        return Err(anyhow!("Forge script execution was not successful"));
    }

    // Parse individual addresses directly from returns
    let factory = forge_output
        .returns
        .factory_proxy
        .value
        .parse::<Address>()
        .map_err(|e| anyhow!("Invalid factoryProxy address: {}", e))?;

    let portal = forge_output
        .returns
        .optimism_portal2
        .value
        .parse::<Address>()
        .map_err(|e| anyhow!("Invalid optimismPortal2 address: {}", e))?;

    let access_manager = forge_output
        .returns
        .access_manager
        .value
        .parse::<Address>()
        .map_err(|e| anyhow!("Invalid accessManager address: {}", e))?;

    let game_implementation = forge_output
        .returns
        .game_implementation
        .value
        .parse::<Address>()
        .map_err(|e| anyhow!("Invalid gameImplementation address: {}", e))?;

    Ok(DeployedContracts { factory, portal, access_manager, game_implementation })
}

/// Deploy all contracts required for E2E testing
pub async fn deploy_test_contracts(rpc_url: &str, private_key: &str) -> Result<DeployedContracts> {
    info!("Deploying test contracts using forge script");

    // Run the forge script to deploy contracts
    let contracts_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("contracts");
    
    let output = std::process::Command::new("forge")
        .arg("script")
        .arg("script/fp/DeployOPSuccinctFDG.s.sol")
        .arg("--broadcast")
        .arg("--rpc-url")
        .arg(rpc_url)
        .arg("--private-key")
        .arg(private_key)
        .arg("--json")
        .env("RUST_LOG", "off")
        .current_dir(&contracts_dir)
        .output()
        .map_err(|e| anyhow!("Failed to execute forge script: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("Forge script failed: {}", stderr));
    }

    // Parse the JSON output to extract contract addresses
    let stdout = String::from_utf8_lossy(&output.stdout);
    let deployed_contracts = parse_forge_output(&stdout)?;

    info!("âœ“ Contracts deployed successfully");
    info!("  Factory: {}", deployed_contracts.factory);
    info!("  Portal: {}", deployed_contracts.portal);
    info!("  Access Manager: {}", deployed_contracts.access_manager);
    info!("  Game Implementation: {}", deployed_contracts.game_implementation);

    Ok(deployed_contracts)
}
