/**

Generated by the following Solidity interface...
```solidity
interface DisputeGameFactory {
    type Claim is bytes32;
    type GameId is bytes32;
    type GameType is uint32;
    type Hash is bytes32;
    type Timestamp is uint64;
    struct GameSearchResult {
        uint256 index;
        GameId metadata;
        Timestamp timestamp;
        Claim rootClaim;
        bytes extraData;
    }

    error GameAlreadyExists(Hash uuid);
    error IncorrectBondAmount();
    error NoImplementation(GameType gameType);
    error ProxyAdminOwnedBase_NotProxyAdmin();
    error ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();
    error ProxyAdminOwnedBase_NotProxyAdminOwner();
    error ProxyAdminOwnedBase_NotResolvedDelegateProxy();
    error ProxyAdminOwnedBase_NotSharedProxyAdminOwner();
    error ProxyAdminOwnedBase_ProxyAdminNotFound();
    error ReinitializableBase_ZeroInitVersion();

    event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);
    event ImplementationArgsSet(GameType indexed gameType, bytes args);
    event ImplementationSet(address indexed impl, GameType indexed gameType);
    event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);
    event Initialized(uint8 version);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor();

    function create(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external payable returns (address proxy_);
    function findLatestGames(GameType _gameType, uint256 _start, uint256 _n) external view returns (GameSearchResult[] memory games_);
    function gameArgs(GameType) external view returns (bytes memory);
    function gameAtIndex(uint256 _index) external view returns (GameType gameType_, Timestamp timestamp_, address proxy_);
    function gameCount() external view returns (uint256 gameCount_);
    function gameImpls(GameType) external view returns (address);
    function games(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external view returns (address proxy_, Timestamp timestamp_);
    function getGameUUID(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external pure returns (Hash uuid_);
    function initBonds(GameType) external view returns (uint256);
    function initVersion() external view returns (uint8);
    function initialize(address _owner) external;
    function owner() external view returns (address);
    function proxyAdmin() external view returns (address);
    function proxyAdminOwner() external view returns (address);
    function renounceOwnership() external;
    function setImplementation(GameType _gameType, address _impl) external;
    function setImplementation(GameType _gameType, address _impl, bytes memory _args) external;
    function setInitBond(GameType _gameType, uint256 _initBond) external;
    function transferOwnership(address newOwner) external;
    function version() external view returns (string memory);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "create",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_rootClaim",
        "type": "bytes32",
        "internalType": "Claim"
      },
      {
        "name": "_extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "proxy_",
        "type": "address",
        "internalType": "contract IDisputeGame"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "findLatestGames",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_n",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "games_",
        "type": "tuple[]",
        "internalType": "struct DisputeGameFactory.GameSearchResult[]",
        "components": [
          {
            "name": "index",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "metadata",
            "type": "bytes32",
            "internalType": "GameId"
          },
          {
            "name": "timestamp",
            "type": "uint64",
            "internalType": "Timestamp"
          },
          {
            "name": "rootClaim",
            "type": "bytes32",
            "internalType": "Claim"
          },
          {
            "name": "extraData",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameArgs",
    "inputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "GameType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameAtIndex",
    "inputs": [
      {
        "name": "_index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "gameType_",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "timestamp_",
        "type": "uint64",
        "internalType": "Timestamp"
      },
      {
        "name": "proxy_",
        "type": "address",
        "internalType": "contract IDisputeGame"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameCount",
    "inputs": [],
    "outputs": [
      {
        "name": "gameCount_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameImpls",
    "inputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "GameType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IDisputeGame"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "games",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_rootClaim",
        "type": "bytes32",
        "internalType": "Claim"
      },
      {
        "name": "_extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "proxy_",
        "type": "address",
        "internalType": "contract IDisputeGame"
      },
      {
        "name": "timestamp_",
        "type": "uint64",
        "internalType": "Timestamp"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getGameUUID",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_rootClaim",
        "type": "bytes32",
        "internalType": "Claim"
      },
      {
        "name": "_extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "uuid_",
        "type": "bytes32",
        "internalType": "Hash"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initBonds",
    "inputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "GameType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxyAdmin",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxyAdminOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setImplementation",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_impl",
        "type": "address",
        "internalType": "contract IDisputeGame"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setImplementation",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_impl",
        "type": "address",
        "internalType": "contract IDisputeGame"
      },
      {
        "name": "_args",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setInitBond",
    "inputs": [
      {
        "name": "_gameType",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "_initBond",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "version",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "DisputeGameCreated",
    "inputs": [
      {
        "name": "disputeProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "gameType",
        "type": "uint32",
        "indexed": true,
        "internalType": "GameType"
      },
      {
        "name": "rootClaim",
        "type": "bytes32",
        "indexed": true,
        "internalType": "Claim"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationArgsSet",
    "inputs": [
      {
        "name": "gameType",
        "type": "uint32",
        "indexed": true,
        "internalType": "GameType"
      },
      {
        "name": "args",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationSet",
    "inputs": [
      {
        "name": "impl",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "gameType",
        "type": "uint32",
        "indexed": true,
        "internalType": "GameType"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InitBondUpdated",
    "inputs": [
      {
        "name": "gameType",
        "type": "uint32",
        "indexed": true,
        "internalType": "GameType"
      },
      {
        "name": "newBond",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "GameAlreadyExists",
    "inputs": [
      {
        "name": "uuid",
        "type": "bytes32",
        "internalType": "Hash"
      }
    ]
  },
  {
    "type": "error",
    "name": "IncorrectBondAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoImplementation",
    "inputs": [
      {
        "name": "gameType",
        "type": "uint32",
        "internalType": "GameType"
      }
    ]
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_NotProxyAdmin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_NotProxyAdminOwner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_NotResolvedDelegateProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_NotSharedProxyAdminOwner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProxyAdminOwnedBase_ProxyAdminNotFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReinitializableBase_ZeroInitVersion",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod DisputeGameFactory {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523480156200001157600080fd5b50600160008160ff160362000052576040517f9b01afed00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060ff1660808160ff168152505050620000716200007760201b60201c565b62000222565b600060019054906101000a900460ff1615620000ca576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620000c190620001c5565b60405180910390fd5b60ff801660008054906101000a900460ff1660ff1610156200013c5760ff6000806101000a81548160ff021916908360ff1602179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249860ff60405162000133919062000205565b60405180910390a15b565b600082825260208201905092915050565b7f496e697469616c697a61626c653a20636f6e747261637420697320696e69746960008201527f616c697a696e6700000000000000000000000000000000000000000000000000602082015250565b6000620001ad6027836200013e565b9150620001ba826200014f565b604082019050919050565b60006020820190508181036000830152620001e0816200019e565b9050919050565b600060ff82169050919050565b620001ff81620001e7565b82525050565b60006020820190506200021c6000830184620001f4565b92915050565b608051612b526200023e60003960006108630152612b526000f3fe60806040526004361061011f5760003560e01c8063715018a6116100a0578063b107095711610064578063b107095714610403578063bb8aa1fc1461042c578063c4d66de81461046b578063dad544e014610494578063f2fde38b146104bf5761011f565b8063715018a61461031757806374cc86ac1461032e57806382ecf2f61461036b5780638da5cb5b1461039b57806396cd9720146103c65761011f565b80633e47158c116100e75780633e47158c1461021b5780634d1975b41461024657806354fd4d50146102715780635f0150cb1461029c5780636593dc6e146102da5761011f565b806314f6b1a3146101245780631b685b9e1461014d5780631e3342401461018a578063254bd683146101b357806338d38c97146101f0575b600080fd5b34801561013057600080fd5b5061014b60048036038101906101469190611820565b6104e8565b005b34801561015957600080fd5b50610174600480360381019061016f9190611860565b61059c565b60405161018191906118ec565b60405180910390f35b34801561019657600080fd5b506101b160048036038101906101ac919061193d565b6105cf565b005b3480156101bf57600080fd5b506101da60048036038101906101d5919061197d565b610633565b6040516101e79190611c2f565b60405180910390f35b3480156101fc57600080fd5b5061020561085f565b6040516102129190611c6d565b60405180910390f35b34801561022757600080fd5b50610230610887565b60405161023d9190611ca9565b60405180910390f35b34801561025257600080fd5b5061025b610ae0565b6040516102689190611cd3565b60405180910390f35b34801561027d57600080fd5b50610286610aed565b6040516102939190611d43565b60405180910390f35b3480156102a857600080fd5b506102c360048036038101906102be9190611df6565b610b26565b6040516102d1929190611e79565b60405180910390f35b3480156102e657600080fd5b5061030160048036038101906102fc9190611860565b610b73565b60405161030e9190611cd3565b60405180910390f35b34801561032357600080fd5b5061032c610b8b565b005b34801561033a57600080fd5b5061035560048036038101906103509190611860565b610b9f565b6040516103629190611eec565b60405180910390f35b61038560048036038101906103809190611df6565b610c3f565b60405161039291906118ec565b60405180910390f35b3480156103a757600080fd5b506103b0610f43565b6040516103bd9190611f1d565b60405180910390f35b3480156103d257600080fd5b506103ed60048036038101906103e89190611df6565b610f6d565b6040516103fa9190611f47565b60405180910390f35b34801561040f57600080fd5b5061042a60048036038101906104259190611f62565b610fa6565b005b34801561043857600080fd5b50610453600480360381019061044e9190611fd6565b6110cb565b60405161046293929190612034565b60405180910390f35b34801561047757600080fd5b50610492600480360381019061048d9190612097565b61111a565b005b3480156104a057600080fd5b506104a9611233565b6040516104b69190611f1d565b60405180910390f35b3480156104cb57600080fd5b506104e660048036038101906104e19190612097565b6112b0565b005b6104f0611333565b80606560008463ffffffff1663ffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508163ffffffff168173ffffffffffffffffffffffffffffffffffffffff167fff513d80e2c7fa487608f70a618dfbc0cf415699dc69588c747e8c71566c88de60405160405180910390a35050565b60656020528060005260406000206000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6105d7611333565b80606660008463ffffffff1663ffffffff16815260200190815260200160002081905550808263ffffffff167f74d6665c4b26d5596a5aa13d3014e0c06af4d322075a797f87b03cd4c5bc91ca60405160405180910390a35050565b6060606880549050831015806106495750600082145b6108585760405190508160051b602001810160405260008390505b600081101580156106755750838111155b15610856576000606882815481106106905761068f6120c4565b5b9060005260206000200154905060008060006106ab846113b1565b9250925092506106c08963ffffffff166113ec565b63ffffffff166106d58463ffffffff166113ec565b63ffffffff1603610844576001865101865260008173ffffffffffffffffffffffffffffffffffffffff1663609d33346040518163ffffffff1660e01b8152600401600060405180830381865afa158015610734573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061075d9190612214565b905060008273ffffffffffffffffffffffffffffffffffffffff1663bcef3b556040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d09190612272565b90506040518060a001604052808881526020018781526020018567ffffffffffffffff168152602001828152602001838152508860018a5161081291906122ce565b81518110610823576108226120c4565b5b60200260200101819052508888511061084157505050505050610856565b50505b84806001900395505050505050610664565b505b9392505050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000806108b67fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610360001b6113f6565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146108f55780915050610add565b60026040518060400160405280601a81526020017f4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000815250516109389190612302565b7f4f564d5f4c3143726f7373446f6d61696e4d657373656e67657200000000000060001c1760001b61099230600060405160200161097792919061235c565b60405160208183030381529060405280519060200120611401565b146109c9576040517f54e433cd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006109fd3060016040516020016109e292919061235c565b604051602081830303815290604052805190602001206113f6565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610aab578073ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa2919061239a565b92505050610add565b6040517f332144db00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b6000606880549050905090565b6040518060400160405280600581526020017f312e332e3000000000000000000000000000000000000000000000000000000081525081565b6000806000610b3787878787610f6d565b9050600080610b5860676000858152602001908152602001600020546113b1565b92509250508082809550819650505050505094509492505050565b60666020528060005260406000206000915090505481565b610b93611333565b610b9d600061140c565b565b60696020528060005260406000206000915090508054610bbe906123f6565b80601f0160208091040260200160405190810160405280929190818152602001828054610bea906123f6565b8015610c375780601f10610c0c57610100808354040283529160200191610c37565b820191906000526020600020905b815481529060010190602001808311610c1a57829003601f168201915b505050505081565b600080606560008763ffffffff1663ffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610cf557856040517f031c6de4000000000000000000000000000000000000000000000000000000008152600401610cec9190612427565b60405180910390fd5b606660008763ffffffff1663ffffffff168152602001908152602001600020543414610d4d576040517f8620aa1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600143610d5c91906122ce565b409050610dcf3387838888606960008e63ffffffff1663ffffffff168152602001908152602001600020604051602001610d9b96959493929190612599565b6040516020818303038152906040528373ffffffffffffffffffffffffffffffffffffffff166114d290919063ffffffff16565b92508273ffffffffffffffffffffffffffffffffffffffff16638129fc1c346040518263ffffffff1660e01b81526004016000604051808303818588803b158015610e1957600080fd5b505af1158015610e2d573d6000803e3d6000fd5b50505050506000610e4088888888610f6d565b90506000801b606760008381526020019081526020016000205414610e9c57806040517f014f6fe5000000000000000000000000000000000000000000000000000000008152600401610e939190611f47565b60405180910390fd5b6000610ea98942876114e8565b90508060676000848152602001908152602001600020819055506068819080600181540180825580915050600190039060005260206000200160009091909190915055878963ffffffff168673ffffffffffffffffffffffffffffffffffffffff167f5b565efe82411da98814f356d0e7bcb8f0219b8d970307c5afb4a6903a8b2e3560405160405180910390a450505050949350505050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600084848484604051602001610f86949392919061262e565b604051602081830303815290604052805190602001209050949350505050565b610fae611333565b82606560008663ffffffff1663ffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508181606960008763ffffffff1663ffffffff168152602001908152602001600020918261103a929190612806565b508363ffffffff168373ffffffffffffffffffffffffffffffffffffffff167fff513d80e2c7fa487608f70a618dfbc0cf415699dc69588c747e8c71566c88de60405160405180910390a38363ffffffff167fa47fcdf075d680d3817bfca7973b373e1a5f6cfc3b444748299cc2b83d8348f983836040516110bd9291906128d6565b60405180910390a250505050565b6000806000806000806110fb606888815481106110eb576110ea6120c4565b5b90600052602060002001546113b1565b9250925092508282828096508197508298505050505050509193909250565b61112261085f565b600060019054906101000a900460ff1615801561115157508060ff1660008054906101000a900460ff1660ff16105b611190576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111879061296c565b60405180910390fd5b806000806101000a81548160ff021916908360ff1602179055506001600060016101000a81548160ff0219169083151502179055506111cd6114fe565b6111d56115ad565b6111de8261140c565b60008060016101000a81548160ff0219169083151502179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498816040516112279190611c6d565b60405180910390a15050565b600061123d610887565b73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ab919061239a565b905090565b6112b8611333565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611327576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161131e906129fe565b60405180910390fd5b6113308161140c565b50565b61133b611606565b73ffffffffffffffffffffffffffffffffffffffff16611359610f43565b73ffffffffffffffffffffffffffffffffffffffff16146113af576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113a690612a6a565b60405180910390fd5b565b60008060008360e01c925067ffffffffffffffff8460a01c16915073ffffffffffffffffffffffffffffffffffffffff841690509193909250565b6000819050919050565b600081549050919050565b600081549050919050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081603360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b60006114e06000848461160e565b905092915050565b6000818360a01b8560e01b171790509392505050565b3373ffffffffffffffffffffffffffffffffffffffff1661151d610887565b73ffffffffffffffffffffffffffffffffffffffff161415801561157457503373ffffffffffffffffffffffffffffffffffffffff1661155b611233565b73ffffffffffffffffffffffffffffffffffffffff1614155b156115ab576040517fc4050a2600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b600060019054906101000a900460ff166115fc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115f390612afc565b60405180910390fd5b6116046116ff565b565b600033905090565b600060608203516040830351602084035184518060208701018051600283016c5af43d3d93803e606057fd5bf3895289600d8a035278593da1005b363d3d373d3d3d3d610000806062363936013d738160481b1760218a03527f9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff603a8a035272fd6100003d81600a3d39f336602c57343d527f6062820160781b1761ff9e82106059018a03528060f01b8352606c8101604c8a038cf09750876116d95763301164256000526004601cfd5b8183528389528460208a03528560408a03528660608a0352505050505050509392505050565b600060019054906101000a900460ff1661174e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161174590612afc565b60405180910390fd5b61175e611759611606565b61140c565b565b6000604051905090565b600080fd5b600080fd5b600063ffffffff82169050919050565b61178d81611774565b811461179857600080fd5b50565b6000813590506117aa81611784565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006117db826117b0565b9050919050565b60006117ed826117d0565b9050919050565b6117fd816117e2565b811461180857600080fd5b50565b60008135905061181a816117f4565b92915050565b600080604083850312156118375761183661176a565b5b60006118458582860161179b565b92505060206118568582860161180b565b9150509250929050565b6000602082840312156118765761187561176a565b5b60006118848482850161179b565b91505092915050565b6000819050919050565b60006118b26118ad6118a8846117b0565b61188d565b6117b0565b9050919050565b60006118c482611897565b9050919050565b60006118d6826118b9565b9050919050565b6118e6816118cb565b82525050565b600060208201905061190160008301846118dd565b92915050565b6000819050919050565b61191a81611907565b811461192557600080fd5b50565b60008135905061193781611911565b92915050565b600080604083850312156119545761195361176a565b5b60006119628582860161179b565b925050602061197385828601611928565b9150509250929050565b6000806000606084860312156119965761199561176a565b5b60006119a48682870161179b565b93505060206119b586828701611928565b92505060406119c686828701611928565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611a0581611907565b82525050565b6000819050919050565b6000611a2082611a0b565b9050919050565b611a3081611a15565b82525050565b600067ffffffffffffffff82169050919050565b6000611a65611a60611a5b84611a36565b61188d565b611a36565b9050919050565b611a7581611a4a565b82525050565b611a8481611a15565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ac4578082015181840152602081019050611aa9565b83811115611ad3576000848401525b50505050565b6000601f19601f8301169050919050565b6000611af582611a8a565b611aff8185611a95565b9350611b0f818560208601611aa6565b611b1881611ad9565b840191505092915050565b600060a083016000830151611b3b60008601826119fc565b506020830151611b4e6020860182611a27565b506040830151611b616040860182611a6c565b506060830151611b746060860182611a7b565b5060808301518482036080860152611b8c8282611aea565b9150508091505092915050565b6000611ba58383611b23565b905092915050565b6000602082019050919050565b6000611bc5826119d0565b611bcf81856119db565b935083602082028501611be1856119ec565b8060005b85811015611c1d5784840389528151611bfe8582611b99565b9450611c0983611bad565b925060208a01995050600181019050611be5565b50829750879550505050505092915050565b60006020820190508181036000830152611c498184611bba565b905092915050565b600060ff82169050919050565b611c6781611c51565b82525050565b6000602082019050611c826000830184611c5e565b92915050565b6000611c93826118b9565b9050919050565b611ca381611c88565b82525050565b6000602082019050611cbe6000830184611c9a565b92915050565b611ccd81611907565b82525050565b6000602082019050611ce86000830184611cc4565b92915050565b600081519050919050565b600082825260208201905092915050565b6000611d1582611cee565b611d1f8185611cf9565b9350611d2f818560208601611aa6565b611d3881611ad9565b840191505092915050565b60006020820190508181036000830152611d5d8184611d0a565b905092915050565b611d6e81611a0b565b8114611d7957600080fd5b50565b600081359050611d8b81611d65565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f840112611db657611db5611d91565b5b8235905067ffffffffffffffff811115611dd357611dd2611d96565b5b602083019150836001820283011115611def57611dee611d9b565b5b9250929050565b60008060008060608587031215611e1057611e0f61176a565b5b6000611e1e8782880161179b565b9450506020611e2f87828801611d7c565b935050604085013567ffffffffffffffff811115611e5057611e4f61176f565b5b611e5c87828801611da0565b925092505092959194509250565b611e7381611a4a565b82525050565b6000604082019050611e8e60008301856118dd565b611e9b6020830184611e6a565b9392505050565b600082825260208201905092915050565b6000611ebe82611a8a565b611ec88185611ea2565b9350611ed8818560208601611aa6565b611ee181611ad9565b840191505092915050565b60006020820190508181036000830152611f068184611eb3565b905092915050565b611f17816117d0565b82525050565b6000602082019050611f326000830184611f0e565b92915050565b611f4181611a15565b82525050565b6000602082019050611f5c6000830184611f38565b92915050565b60008060008060608587031215611f7c57611f7b61176a565b5b6000611f8a8782880161179b565b9450506020611f9b8782880161180b565b935050604085013567ffffffffffffffff811115611fbc57611fbb61176f565b5b611fc887828801611da0565b925092505092959194509250565b600060208284031215611fec57611feb61176a565b5b6000611ffa84828501611928565b91505092915050565b600061201e61201961201484611774565b61188d565b611774565b9050919050565b61202e81612003565b82525050565b60006060820190506120496000830186612025565b6120566020830185611e6a565b61206360408301846118dd565b949350505050565b612074816117d0565b811461207f57600080fd5b50565b6000813590506120918161206b565b92915050565b6000602082840312156120ad576120ac61176a565b5b60006120bb84828501612082565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61213082611ad9565b810181811067ffffffffffffffff8211171561214f5761214e6120f8565b5b80604052505050565b6000612162611760565b905061216e8282612127565b919050565b600067ffffffffffffffff82111561218e5761218d6120f8565b5b61219782611ad9565b9050602081019050919050565b60006121b76121b284612173565b612158565b9050828152602081018484840111156121d3576121d26120f3565b5b6121de848285611aa6565b509392505050565b600082601f8301126121fb576121fa611d91565b5b815161220b8482602086016121a4565b91505092915050565b60006020828403121561222a5761222961176a565b5b600082015167ffffffffffffffff8111156122485761224761176f565b5b612254848285016121e6565b91505092915050565b60008151905061226c81611d65565b92915050565b6000602082840312156122885761228761176a565b5b60006122968482850161225d565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006122d982611907565b91506122e483611907565b9250828210156122f7576122f661229f565b5b828203905092915050565b600061230d82611907565b915061231883611907565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156123515761235061229f565b5b828202905092915050565b60006040820190506123716000830185611f0e565b61237e6020830184611cc4565b9392505050565b6000815190506123948161206b565b92915050565b6000602082840312156123b0576123af61176a565b5b60006123be84828501612385565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061240e57607f821691505b602082108103612421576124206123c7565b5b50919050565b600060208201905061243c6000830184612025565b92915050565b60008160601b9050919050565b600061245a82612442565b9050919050565b600061246c8261244f565b9050919050565b61248461247f826117d0565b612461565b82525050565b6000819050919050565b6124a56124a082611a15565b61248a565b82525050565b6124bc6124b782611a0b565b61248a565b82525050565b600081905092915050565b82818337600083830152505050565b60006124e883856124c2565b93506124f58385846124cd565b82840190509392505050565b60008190508160005260206000209050919050565b60008154612523816123f6565b61252d81866124c2565b94506001821660008114612548576001811461255d57612590565b60ff1983168652811515820286019350612590565b61256685612501565b60005b8381101561258857815481890152600182019150602081019050612569565b838801955050505b50505092915050565b60006125a58289612473565b6014820191506125b58288612494565b6020820191506125c582876124ab565b6020820191506125d68285876124dc565b91506125e28284612516565b9150819050979650505050505050565b6125fb81611a15565b82525050565b600061260d8385611ea2565b935061261a8385846124cd565b61262383611ad9565b840190509392505050565b60006060820190506126436000830187612025565b61265060208301866125f2565b8181036040830152612663818486612601565b905095945050505050565b600082905092915050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026126c67fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82612689565b6126d08683612689565b95508019841693508086168417925050509392505050565b60006127036126fe6126f984611907565b61188d565b611907565b9050919050565b6000819050919050565b61271d836126e8565b6127316127298261270a565b848454612696565b825550505050565b600090565b612746612739565b612751818484612714565b505050565b5b818110156127755761276a60008261273e565b600181019050612757565b5050565b601f8211156127ba5761278b81612501565b61279484612679565b810160208510156127a3578190505b6127b76127af85612679565b830182612756565b50505b505050565b600082821c905092915050565b60006127dd600019846008026127bf565b1980831691505092915050565b60006127f683836127cc565b9150826002028217905092915050565b612810838361266e565b67ffffffffffffffff811115612829576128286120f8565b5b61283382546123f6565b61283e828285612779565b6000601f83116001811461286d576000841561285b578287013590505b61286585826127ea565b8655506128cd565b601f19841661287b86612501565b60005b828110156128a35784890135825560018201915060208501945060208101905061287e565b868310156128c057848901356128bc601f8916826127cc565b8355505b6001600288020188555050505b50505050505050565b600060208201905081810360008301526128f1818486612601565b90509392505050565b7f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160008201527f647920696e697469616c697a6564000000000000000000000000000000000000602082015250565b6000612956602e83611cf9565b9150612961826128fa565b604082019050919050565b6000602082019050818103600083015261298581612949565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006129e8602683611cf9565b91506129f38261298c565b604082019050919050565b60006020820190508181036000830152612a17816129db565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000612a54602083611cf9565b9150612a5f82612a1e565b602082019050919050565b60006020820190508181036000830152612a8381612a47565b9050919050565b7f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960008201527f6e697469616c697a696e67000000000000000000000000000000000000000000602082015250565b6000612ae6602b83611cf9565b9150612af182612a8a565b604082019050919050565b60006020820190508181036000830152612b1581612ad9565b905091905056fea264697066735822122099d02df53e25c69c481822cac2d3cc1491881b84bbfa623be70a9dfab86ad5bf64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4\x80\x15b\0\0\x11W`\0\x80\xFD[P`\x01`\0\x81`\xFF\x16\x03b\0\0RW`@Q\x7F\x9B\x01\xAF\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\xFF\x16`\x80\x81`\xFF\x16\x81RPPPb\0\0qb\0\0w` \x1B` \x1CV[b\0\x02\"V[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xCAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01b\0\0\xC1\x90b\0\x01\xC5V[`@Q\x80\x91\x03\x90\xFD[`\xFF\x80\x16`\0\x80T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x10\x15b\0\x01<W`\xFF`\0\x80a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\xFF\x16\x02\x17\x90UP\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98`\xFF`@Qb\0\x013\x91\x90b\0\x02\x05V[`@Q\x80\x91\x03\x90\xA1[V[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FInitializable: contract is initi`\0\x82\x01R\x7Falizing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0b\0\x01\xAD`'\x83b\0\x01>V[\x91Pb\0\x01\xBA\x82b\0\x01OV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Rb\0\x01\xE0\x81b\0\x01\x9EV[\x90P\x91\x90PV[`\0`\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xFF\x81b\0\x01\xE7V[\x82RPPV[`\0` \x82\x01\x90Pb\0\x02\x1C`\0\x83\x01\x84b\0\x01\xF4V[\x92\x91PPV[`\x80Qa+Rb\0\x02>`\09`\0a\x08c\x01Ra+R`\0\xF3\xFE`\x80`@R`\x046\x10a\x01\x1FW`\x005`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xA0W\x80c\xB1\x07\tW\x11a\0dW\x80c\xB1\x07\tW\x14a\x04\x03W\x80c\xBB\x8A\xA1\xFC\x14a\x04,W\x80c\xC4\xD6m\xE8\x14a\x04kW\x80c\xDA\xD5D\xE0\x14a\x04\x94W\x80c\xF2\xFD\xE3\x8B\x14a\x04\xBFWa\x01\x1FV[\x80cqP\x18\xA6\x14a\x03\x17W\x80ct\xCC\x86\xAC\x14a\x03.W\x80c\x82\xEC\xF2\xF6\x14a\x03kW\x80c\x8D\xA5\xCB[\x14a\x03\x9BW\x80c\x96\xCD\x97 \x14a\x03\xC6Wa\x01\x1FV[\x80c>G\x15\x8C\x11a\0\xE7W\x80c>G\x15\x8C\x14a\x02\x1BW\x80cM\x19u\xB4\x14a\x02FW\x80cT\xFDMP\x14a\x02qW\x80c_\x01P\xCB\x14a\x02\x9CW\x80ce\x93\xDCn\x14a\x02\xDAWa\x01\x1FV[\x80c\x14\xF6\xB1\xA3\x14a\x01$W\x80c\x1Bh[\x9E\x14a\x01MW\x80c\x1E3B@\x14a\x01\x8AW\x80c%K\xD6\x83\x14a\x01\xB3W\x80c8\xD3\x8C\x97\x14a\x01\xF0W[`\0\x80\xFD[4\x80\x15a\x010W`\0\x80\xFD[Pa\x01K`\x04\x806\x03\x81\x01\x90a\x01F\x91\x90a\x18 V[a\x04\xE8V[\0[4\x80\x15a\x01YW`\0\x80\xFD[Pa\x01t`\x04\x806\x03\x81\x01\x90a\x01o\x91\x90a\x18`V[a\x05\x9CV[`@Qa\x01\x81\x91\x90a\x18\xECV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x96W`\0\x80\xFD[Pa\x01\xB1`\x04\x806\x03\x81\x01\x90a\x01\xAC\x91\x90a\x19=V[a\x05\xCFV[\0[4\x80\x15a\x01\xBFW`\0\x80\xFD[Pa\x01\xDA`\x04\x806\x03\x81\x01\x90a\x01\xD5\x91\x90a\x19}V[a\x063V[`@Qa\x01\xE7\x91\x90a\x1C/V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xFCW`\0\x80\xFD[Pa\x02\x05a\x08_V[`@Qa\x02\x12\x91\x90a\x1CmV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02'W`\0\x80\xFD[Pa\x020a\x08\x87V[`@Qa\x02=\x91\x90a\x1C\xA9V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02RW`\0\x80\xFD[Pa\x02[a\n\xE0V[`@Qa\x02h\x91\x90a\x1C\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02}W`\0\x80\xFD[Pa\x02\x86a\n\xEDV[`@Qa\x02\x93\x91\x90a\x1DCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA8W`\0\x80\xFD[Pa\x02\xC3`\x04\x806\x03\x81\x01\x90a\x02\xBE\x91\x90a\x1D\xF6V[a\x0B&V[`@Qa\x02\xD1\x92\x91\x90a\x1EyV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xE6W`\0\x80\xFD[Pa\x03\x01`\x04\x806\x03\x81\x01\x90a\x02\xFC\x91\x90a\x18`V[a\x0BsV[`@Qa\x03\x0E\x91\x90a\x1C\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03#W`\0\x80\xFD[Pa\x03,a\x0B\x8BV[\0[4\x80\x15a\x03:W`\0\x80\xFD[Pa\x03U`\x04\x806\x03\x81\x01\x90a\x03P\x91\x90a\x18`V[a\x0B\x9FV[`@Qa\x03b\x91\x90a\x1E\xECV[`@Q\x80\x91\x03\x90\xF3[a\x03\x85`\x04\x806\x03\x81\x01\x90a\x03\x80\x91\x90a\x1D\xF6V[a\x0C?V[`@Qa\x03\x92\x91\x90a\x18\xECV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xA7W`\0\x80\xFD[Pa\x03\xB0a\x0FCV[`@Qa\x03\xBD\x91\x90a\x1F\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD2W`\0\x80\xFD[Pa\x03\xED`\x04\x806\x03\x81\x01\x90a\x03\xE8\x91\x90a\x1D\xF6V[a\x0FmV[`@Qa\x03\xFA\x91\x90a\x1FGV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x0FW`\0\x80\xFD[Pa\x04*`\x04\x806\x03\x81\x01\x90a\x04%\x91\x90a\x1FbV[a\x0F\xA6V[\0[4\x80\x15a\x048W`\0\x80\xFD[Pa\x04S`\x04\x806\x03\x81\x01\x90a\x04N\x91\x90a\x1F\xD6V[a\x10\xCBV[`@Qa\x04b\x93\x92\x91\x90a 4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04wW`\0\x80\xFD[Pa\x04\x92`\x04\x806\x03\x81\x01\x90a\x04\x8D\x91\x90a \x97V[a\x11\x1AV[\0[4\x80\x15a\x04\xA0W`\0\x80\xFD[Pa\x04\xA9a\x123V[`@Qa\x04\xB6\x91\x90a\x1F\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCBW`\0\x80\xFD[Pa\x04\xE6`\x04\x806\x03\x81\x01\x90a\x04\xE1\x91\x90a \x97V[a\x12\xB0V[\0[a\x04\xF0a\x133V[\x80`e`\0\x84c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81c\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFFQ=\x80\xE2\xC7\xFAHv\x08\xF7\na\x8D\xFB\xC0\xCFAV\x99\xDCiX\x8Ct~\x8CqVl\x88\xDE`@Q`@Q\x80\x91\x03\x90\xA3PPV[`e` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x05\xD7a\x133V[\x80`f`\0\x84c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x80\x82c\xFF\xFF\xFF\xFF\x16\x7Ft\xD6f\\K&\xD5YjZ\xA1=0\x14\xE0\xC0j\xF4\xD3\"\x07Zy\x7F\x87\xB0<\xD4\xC5\xBC\x91\xCA`@Q`@Q\x80\x91\x03\x90\xA3PPV[```h\x80T\x90P\x83\x10\x15\x80a\x06IWP`\0\x82\x14[a\x08XW`@Q\x90P\x81`\x05\x1B` \x01\x81\x01`@R`\0\x83\x90P[`\0\x81\x10\x15\x80\x15a\x06uWP\x83\x81\x11\x15[\x15a\x08VW`\0`h\x82\x81T\x81\x10a\x06\x90Wa\x06\x8Fa \xC4V[[\x90`\0R` `\0 \x01T\x90P`\0\x80`\0a\x06\xAB\x84a\x13\xB1V[\x92P\x92P\x92Pa\x06\xC0\x89c\xFF\xFF\xFF\xFF\x16a\x13\xECV[c\xFF\xFF\xFF\xFF\x16a\x06\xD5\x84c\xFF\xFF\xFF\xFF\x16a\x13\xECV[c\xFF\xFF\xFF\xFF\x16\x03a\x08DW`\x01\x86Q\x01\x86R`\0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c`\x9D34`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x074W=`\0\x80>=`\0\xFD[PPPP`@Q=`\0\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07]\x91\x90a\"\x14V[\x90P`\0\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBC\xEF;U`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\xACW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xD0\x91\x90a\"rV[\x90P`@Q\x80`\xA0\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x85g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01\x83\x81RP\x88`\x01\x8AQa\x08\x12\x91\x90a\"\xCEV[\x81Q\x81\x10a\x08#Wa\x08\"a \xC4V[[` \x02` \x01\x01\x81\x90RP\x88\x88Q\x10a\x08AWPPPPPPa\x08VV[PP[\x84\x80`\x01\x90\x03\x95PPPPPPa\x06dV[P[\x93\x92PPPV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80a\x08\xB6\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03`\0\x1Ba\x13\xF6V[\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xF5W\x80\x91PPa\n\xDDV[`\x02`@Q\x80`@\x01`@R\x80`\x1A\x81R` \x01\x7FOVM_L1CrossDomainMessenger\0\0\0\0\0\0\x81RPQa\t8\x91\x90a#\x02V[\x7FOVM_L1CrossDomainMessenger\0\0\0\0\0\0`\0\x1C\x17`\0\x1Ba\t\x920`\0`@Q` \x01a\tw\x92\x91\x90a#\\V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x14\x01V[\x14a\t\xC9W`@Q\x7FT\xE43\xCD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0a\t\xFD0`\x01`@Q` \x01a\t\xE2\x92\x91\x90a#\\V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x13\xF6V[\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n\xABW\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n~W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xA2\x91\x90a#\x9AV[\x92PPPa\n\xDDV[`@Q\x7F3!D\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x90V[`\0`h\x80T\x90P\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F1.3.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\0\x80`\0a\x0B7\x87\x87\x87\x87a\x0FmV[\x90P`\0\x80a\x0BX`g`\0\x85\x81R` \x01\x90\x81R` \x01`\0 Ta\x13\xB1V[\x92P\x92PP\x80\x82\x80\x95P\x81\x96PPPPPP\x94P\x94\x92PPPV[`f` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[a\x0B\x93a\x133V[a\x0B\x9D`\0a\x14\x0CV[V[`i` R\x80`\0R`@`\0 `\0\x91P\x90P\x80Ta\x0B\xBE\x90a#\xF6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xEA\x90a#\xF6V[\x80\x15a\x0C7W\x80`\x1F\x10a\x0C\x0CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C7V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x1AW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[`\0\x80`e`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0C\xF5W\x85`@Q\x7F\x03\x1Cm\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xEC\x91\x90a$'V[`@Q\x80\x91\x03\x90\xFD[`f`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T4\x14a\rMW`@Q\x7F\x86 \xAA\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x01Ca\r\\\x91\x90a\"\xCEV[@\x90Pa\r\xCF3\x87\x83\x88\x88`i`\0\x8Ec\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `@Q` \x01a\r\x9B\x96\x95\x94\x93\x92\x91\x90a%\x99V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x14\xD2\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x92P\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x81)\xFC\x1C4`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\0`@Q\x80\x83\x03\x81\x85\x88\x80;\x15\x80\x15a\x0E\x19W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x0E-W=`\0\x80>=`\0\xFD[PPPPP`\0a\x0E@\x88\x88\x88\x88a\x0FmV[\x90P`\0\x80\x1B`g`\0\x83\x81R` \x01\x90\x81R` \x01`\0 T\x14a\x0E\x9CW\x80`@Q\x7F\x01Oo\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x93\x91\x90a\x1FGV[`@Q\x80\x91\x03\x90\xFD[`\0a\x0E\xA9\x89B\x87a\x14\xE8V[\x90P\x80`g`\0\x84\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`h\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90`\0R` `\0 \x01`\0\x90\x91\x90\x91\x90\x91PU\x87\x89c\xFF\xFF\xFF\xFF\x16\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F[V^\xFE\x82A\x1D\xA9\x88\x14\xF3V\xD0\xE7\xBC\xB8\xF0!\x9B\x8D\x97\x03\x07\xC5\xAF\xB4\xA6\x90:\x8B.5`@Q`@Q\x80\x91\x03\x90\xA4PPPP\x94\x93PPPPV[`\0`3`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\0\x84\x84\x84\x84`@Q` \x01a\x0F\x86\x94\x93\x92\x91\x90a&.V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x94\x93PPPPV[a\x0F\xAEa\x133V[\x82`e`\0\x86c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81\x81`i`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x91\x82a\x10:\x92\x91\x90a(\x06V[P\x83c\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFFQ=\x80\xE2\xC7\xFAHv\x08\xF7\na\x8D\xFB\xC0\xCFAV\x99\xDCiX\x8Ct~\x8CqVl\x88\xDE`@Q`@Q\x80\x91\x03\x90\xA3\x83c\xFF\xFF\xFF\xFF\x16\x7F\xA4\x7F\xCD\xF0u\xD6\x80\xD3\x81{\xFC\xA7\x97;7>\x1A_l\xFC;DGH)\x9C\xC2\xB8=\x83H\xF9\x83\x83`@Qa\x10\xBD\x92\x91\x90a(\xD6V[`@Q\x80\x91\x03\x90\xA2PPPPV[`\0\x80`\0\x80`\0\x80a\x10\xFB`h\x88\x81T\x81\x10a\x10\xEBWa\x10\xEAa \xC4V[[\x90`\0R` `\0 \x01Ta\x13\xB1V[\x92P\x92P\x92P\x82\x82\x82\x80\x96P\x81\x97P\x82\x98PPPPPPP\x91\x93\x90\x92PV[a\x11\"a\x08_V[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80\x15a\x11QWP\x80`\xFF\x16`\0\x80T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x10[a\x11\x90W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\x87\x90a)lV[`@Q\x80\x91\x03\x90\xFD[\x80`\0\x80a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\xFF\x16\x02\x17\x90UP`\x01`\0`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x11\xCDa\x14\xFEV[a\x11\xD5a\x15\xADV[a\x11\xDE\x82a\x14\x0CV[`\0\x80`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x81`@Qa\x12'\x91\x90a\x1CmV[`@Q\x80\x91\x03\x90\xA1PPV[`\0a\x12=a\x08\x87V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x12\x87W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xAB\x91\x90a#\x9AV[\x90P\x90V[a\x12\xB8a\x133V[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13'W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x1E\x90a)\xFEV[`@Q\x80\x91\x03\x90\xFD[a\x130\x81a\x14\x0CV[PV[a\x13;a\x16\x06V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x13Ya\x0FCV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xAFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xA6\x90a*jV[`@Q\x80\x91\x03\x90\xFD[V[`\0\x80`\0\x83`\xE0\x1C\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84`\xA0\x1C\x16\x91Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90P\x91\x93\x90\x92PV[`\0\x81\x90P\x91\x90PV[`\0\x81T\x90P\x91\x90PV[`\0\x81T\x90P\x91\x90PV[`\0`3`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81`3`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\0a\x14\xE0`\0\x84\x84a\x16\x0EV[\x90P\x92\x91PPV[`\0\x81\x83`\xA0\x1B\x85`\xE0\x1B\x17\x17\x90P\x93\x92PPPV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\x1Da\x08\x87V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x15tWP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15[a\x123V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x15\xABW`@Q\x7F\xC4\x05\n&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15\xFCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xF3\x90a*\xFCV[`@Q\x80\x91\x03\x90\xFD[a\x16\x04a\x16\xFFV[V[`\x003\x90P\x90V[`\0``\x82\x03Q`@\x83\x03Q` \x84\x03Q\x84Q\x80` \x87\x01\x01\x80Q`\x02\x83\x01lZ\xF4==\x93\x80>``W\xFD[\xF3\x89R\x89`\r\x8A\x03RxY=\xA1\0[6==7====a\0\0\x80`b696\x01=s\x81`H\x1B\x17`!\x8A\x03R\x7F\x9EJ\xC3O!\xC6\x19\xCE\xFC\x92l\x8B\xD9;T\xBFZ9\xC7\xAB!'\xA8\x95\xAF\x1C\xC0i\x1D~=\xFF`:\x8A\x03Rr\xFDa\0\0=\x81`\n=9\xF36`,W4=R\x7F`b\x82\x01`x\x1B\x17a\xFF\x9E\x82\x10`Y\x01\x8A\x03R\x80`\xF0\x1B\x83R`l\x81\x01`L\x8A\x03\x8C\xF0\x97P\x87a\x16\xD9Wc0\x11d%`\0R`\x04`\x1C\xFD[\x81\x83R\x83\x89R\x84` \x8A\x03R\x85`@\x8A\x03R\x86``\x8A\x03RPPPPPPP\x93\x92PPPV[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x17NW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17E\x90a*\xFCV[`@Q\x80\x91\x03\x90\xFD[a\x17^a\x17Ya\x16\x06V[a\x14\x0CV[V[`\0`@Q\x90P\x90V[`\0\x80\xFD[`\0\x80\xFD[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x17\x8D\x81a\x17tV[\x81\x14a\x17\x98W`\0\x80\xFD[PV[`\0\x815\x90Pa\x17\xAA\x81a\x17\x84V[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x17\xDB\x82a\x17\xB0V[\x90P\x91\x90PV[`\0a\x17\xED\x82a\x17\xD0V[\x90P\x91\x90PV[a\x17\xFD\x81a\x17\xE2V[\x81\x14a\x18\x08W`\0\x80\xFD[PV[`\0\x815\x90Pa\x18\x1A\x81a\x17\xF4V[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x187Wa\x186a\x17jV[[`\0a\x18E\x85\x82\x86\x01a\x17\x9BV[\x92PP` a\x18V\x85\x82\x86\x01a\x18\x0BV[\x91PP\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a\x18vWa\x18ua\x17jV[[`\0a\x18\x84\x84\x82\x85\x01a\x17\x9BV[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a\x18\xB2a\x18\xADa\x18\xA8\x84a\x17\xB0V[a\x18\x8DV[a\x17\xB0V[\x90P\x91\x90PV[`\0a\x18\xC4\x82a\x18\x97V[\x90P\x91\x90PV[`\0a\x18\xD6\x82a\x18\xB9V[\x90P\x91\x90PV[a\x18\xE6\x81a\x18\xCBV[\x82RPPV[`\0` \x82\x01\x90Pa\x19\x01`\0\x83\x01\x84a\x18\xDDV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a\x19\x1A\x81a\x19\x07V[\x81\x14a\x19%W`\0\x80\xFD[PV[`\0\x815\x90Pa\x197\x81a\x19\x11V[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x19TWa\x19Sa\x17jV[[`\0a\x19b\x85\x82\x86\x01a\x17\x9BV[\x92PP` a\x19s\x85\x82\x86\x01a\x19(V[\x91PP\x92P\x92\x90PV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x19\x96Wa\x19\x95a\x17jV[[`\0a\x19\xA4\x86\x82\x87\x01a\x17\x9BV[\x93PP` a\x19\xB5\x86\x82\x87\x01a\x19(V[\x92PP`@a\x19\xC6\x86\x82\x87\x01a\x19(V[\x91PP\x92P\x92P\x92V[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x1A\x05\x81a\x19\x07V[\x82RPPV[`\0\x81\x90P\x91\x90PV[`\0a\x1A \x82a\x1A\x0BV[\x90P\x91\x90PV[a\x1A0\x81a\x1A\x15V[\x82RPPV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x1Aea\x1A`a\x1A[\x84a\x1A6V[a\x18\x8DV[a\x1A6V[\x90P\x91\x90PV[a\x1Au\x81a\x1AJV[\x82RPPV[a\x1A\x84\x81a\x1A\x15V[\x82RPPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0[\x83\x81\x10\x15a\x1A\xC4W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x1A\xA9V[\x83\x81\x11\x15a\x1A\xD3W`\0\x84\x84\x01R[PPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x1A\xF5\x82a\x1A\x8AV[a\x1A\xFF\x81\x85a\x1A\x95V[\x93Pa\x1B\x0F\x81\x85` \x86\x01a\x1A\xA6V[a\x1B\x18\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0`\xA0\x83\x01`\0\x83\x01Qa\x1B;`\0\x86\x01\x82a\x19\xFCV[P` \x83\x01Qa\x1BN` \x86\x01\x82a\x1A'V[P`@\x83\x01Qa\x1Ba`@\x86\x01\x82a\x1AlV[P``\x83\x01Qa\x1Bt``\x86\x01\x82a\x1A{V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra\x1B\x8C\x82\x82a\x1A\xEAV[\x91PP\x80\x91PP\x92\x91PPV[`\0a\x1B\xA5\x83\x83a\x1B#V[\x90P\x92\x91PPV[`\0` \x82\x01\x90P\x91\x90PV[`\0a\x1B\xC5\x82a\x19\xD0V[a\x1B\xCF\x81\x85a\x19\xDBV[\x93P\x83` \x82\x02\x85\x01a\x1B\xE1\x85a\x19\xECV[\x80`\0[\x85\x81\x10\x15a\x1C\x1DW\x84\x84\x03\x89R\x81Qa\x1B\xFE\x85\x82a\x1B\x99V[\x94Pa\x1C\t\x83a\x1B\xADV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa\x1B\xE5V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1CI\x81\x84a\x1B\xBAV[\x90P\x92\x91PPV[`\0`\xFF\x82\x16\x90P\x91\x90PV[a\x1Cg\x81a\x1CQV[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\x82`\0\x83\x01\x84a\x1C^V[\x92\x91PPV[`\0a\x1C\x93\x82a\x18\xB9V[\x90P\x91\x90PV[a\x1C\xA3\x81a\x1C\x88V[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\xBE`\0\x83\x01\x84a\x1C\x9AV[\x92\x91PPV[a\x1C\xCD\x81a\x19\x07V[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\xE8`\0\x83\x01\x84a\x1C\xC4V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a\x1D\x15\x82a\x1C\xEEV[a\x1D\x1F\x81\x85a\x1C\xF9V[\x93Pa\x1D/\x81\x85` \x86\x01a\x1A\xA6V[a\x1D8\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1D]\x81\x84a\x1D\nV[\x90P\x92\x91PPV[a\x1Dn\x81a\x1A\x0BV[\x81\x14a\x1DyW`\0\x80\xFD[PV[`\0\x815\x90Pa\x1D\x8B\x81a\x1DeV[\x92\x91PPV[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\x83`\x1F\x84\x01\x12a\x1D\xB6Wa\x1D\xB5a\x1D\x91V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1D\xD3Wa\x1D\xD2a\x1D\x96V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1D\xEFWa\x1D\xEEa\x1D\x9BV[[\x92P\x92\x90PV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15a\x1E\x10Wa\x1E\x0Fa\x17jV[[`\0a\x1E\x1E\x87\x82\x88\x01a\x17\x9BV[\x94PP` a\x1E/\x87\x82\x88\x01a\x1D|V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1EPWa\x1EOa\x17oV[[a\x1E\\\x87\x82\x88\x01a\x1D\xA0V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[a\x1Es\x81a\x1AJV[\x82RPPV[`\0`@\x82\x01\x90Pa\x1E\x8E`\0\x83\x01\x85a\x18\xDDV[a\x1E\x9B` \x83\x01\x84a\x1EjV[\x93\x92PPPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a\x1E\xBE\x82a\x1A\x8AV[a\x1E\xC8\x81\x85a\x1E\xA2V[\x93Pa\x1E\xD8\x81\x85` \x86\x01a\x1A\xA6V[a\x1E\xE1\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1F\x06\x81\x84a\x1E\xB3V[\x90P\x92\x91PPV[a\x1F\x17\x81a\x17\xD0V[\x82RPPV[`\0` \x82\x01\x90Pa\x1F2`\0\x83\x01\x84a\x1F\x0EV[\x92\x91PPV[a\x1FA\x81a\x1A\x15V[\x82RPPV[`\0` \x82\x01\x90Pa\x1F\\`\0\x83\x01\x84a\x1F8V[\x92\x91PPV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15a\x1F|Wa\x1F{a\x17jV[[`\0a\x1F\x8A\x87\x82\x88\x01a\x17\x9BV[\x94PP` a\x1F\x9B\x87\x82\x88\x01a\x18\x0BV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xBCWa\x1F\xBBa\x17oV[[a\x1F\xC8\x87\x82\x88\x01a\x1D\xA0V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[`\0` \x82\x84\x03\x12\x15a\x1F\xECWa\x1F\xEBa\x17jV[[`\0a\x1F\xFA\x84\x82\x85\x01a\x19(V[\x91PP\x92\x91PPV[`\0a \x1Ea \x19a \x14\x84a\x17tV[a\x18\x8DV[a\x17tV[\x90P\x91\x90PV[a .\x81a \x03V[\x82RPPV[`\0``\x82\x01\x90Pa I`\0\x83\x01\x86a %V[a V` \x83\x01\x85a\x1EjV[a c`@\x83\x01\x84a\x18\xDDV[\x94\x93PPPPV[a t\x81a\x17\xD0V[\x81\x14a \x7FW`\0\x80\xFD[PV[`\0\x815\x90Pa \x91\x81a kV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a \xADWa \xACa\x17jV[[`\0a \xBB\x84\x82\x85\x01a \x82V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`2`\x04R`$`\0\xFD[`\0\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`A`\x04R`$`\0\xFD[a!0\x82a\x1A\xD9V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a!OWa!Na \xF8V[[\x80`@RPPPV[`\0a!ba\x17`V[\x90Pa!n\x82\x82a!'V[\x91\x90PV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a!\x8EWa!\x8Da \xF8V[[a!\x97\x82a\x1A\xD9V[\x90P` \x81\x01\x90P\x91\x90PV[`\0a!\xB7a!\xB2\x84a!sV[a!XV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a!\xD3Wa!\xD2a \xF3V[[a!\xDE\x84\x82\x85a\x1A\xA6V[P\x93\x92PPPV[`\0\x82`\x1F\x83\x01\x12a!\xFBWa!\xFAa\x1D\x91V[[\x81Qa\"\x0B\x84\x82` \x86\x01a!\xA4V[\x91PP\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\"*Wa\")a\x17jV[[`\0\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"HWa\"Ga\x17oV[[a\"T\x84\x82\x85\x01a!\xE6V[\x91PP\x92\x91PPV[`\0\x81Q\x90Pa\"l\x81a\x1DeV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\"\x88Wa\"\x87a\x17jV[[`\0a\"\x96\x84\x82\x85\x01a\"]V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a\"\xD9\x82a\x19\x07V[\x91Pa\"\xE4\x83a\x19\x07V[\x92P\x82\x82\x10\x15a\"\xF7Wa\"\xF6a\"\x9FV[[\x82\x82\x03\x90P\x92\x91PPV[`\0a#\r\x82a\x19\x07V[\x91Pa#\x18\x83a\x19\x07V[\x92P\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04\x83\x11\x82\x15\x15\x16\x15a#QWa#Pa\"\x9FV[[\x82\x82\x02\x90P\x92\x91PPV[`\0`@\x82\x01\x90Pa#q`\0\x83\x01\x85a\x1F\x0EV[a#~` \x83\x01\x84a\x1C\xC4V[\x93\x92PPPV[`\0\x81Q\x90Pa#\x94\x81a kV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a#\xB0Wa#\xAFa\x17jV[[`\0a#\xBE\x84\x82\x85\x01a#\x85V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\"`\x04R`$`\0\xFD[`\0`\x02\x82\x04\x90P`\x01\x82\x16\x80a$\x0EW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a$!Wa$ a#\xC7V[[P\x91\x90PV[`\0` \x82\x01\x90Pa$<`\0\x83\x01\x84a %V[\x92\x91PPV[`\0\x81``\x1B\x90P\x91\x90PV[`\0a$Z\x82a$BV[\x90P\x91\x90PV[`\0a$l\x82a$OV[\x90P\x91\x90PV[a$\x84a$\x7F\x82a\x17\xD0V[a$aV[\x82RPPV[`\0\x81\x90P\x91\x90PV[a$\xA5a$\xA0\x82a\x1A\x15V[a$\x8AV[\x82RPPV[a$\xBCa$\xB7\x82a\x1A\x0BV[a$\x8AV[\x82RPPV[`\0\x81\x90P\x92\x91PPV[\x82\x81\x837`\0\x83\x83\x01RPPPV[`\0a$\xE8\x83\x85a$\xC2V[\x93Pa$\xF5\x83\x85\x84a$\xCDV[\x82\x84\x01\x90P\x93\x92PPPV[`\0\x81\x90P\x81`\0R` `\0 \x90P\x91\x90PV[`\0\x81Ta%#\x81a#\xF6V[a%-\x81\x86a$\xC2V[\x94P`\x01\x82\x16`\0\x81\x14a%HW`\x01\x81\x14a%]Wa%\x90V[`\xFF\x19\x83\x16\x86R\x81\x15\x15\x82\x02\x86\x01\x93Pa%\x90V[a%f\x85a%\x01V[`\0[\x83\x81\x10\x15a%\x88W\x81T\x81\x89\x01R`\x01\x82\x01\x91P` \x81\x01\x90Pa%iV[\x83\x88\x01\x95PPP[PPP\x92\x91PPV[`\0a%\xA5\x82\x89a$sV[`\x14\x82\x01\x91Pa%\xB5\x82\x88a$\x94V[` \x82\x01\x91Pa%\xC5\x82\x87a$\xABV[` \x82\x01\x91Pa%\xD6\x82\x85\x87a$\xDCV[\x91Pa%\xE2\x82\x84a%\x16V[\x91P\x81\x90P\x97\x96PPPPPPPV[a%\xFB\x81a\x1A\x15V[\x82RPPV[`\0a&\r\x83\x85a\x1E\xA2V[\x93Pa&\x1A\x83\x85\x84a$\xCDV[a&#\x83a\x1A\xD9V[\x84\x01\x90P\x93\x92PPPV[`\0``\x82\x01\x90Pa&C`\0\x83\x01\x87a %V[a&P` \x83\x01\x86a%\xF2V[\x81\x81\x03`@\x83\x01Ra&c\x81\x84\x86a&\x01V[\x90P\x95\x94PPPPPV[`\0\x82\x90P\x92\x91PPV[`\0` `\x1F\x83\x01\x04\x90P\x91\x90PV[`\0\x82\x82\x1B\x90P\x92\x91PPV[`\0`\x08\x83\x02a&\xC6\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a&\x89V[a&\xD0\x86\x83a&\x89V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[`\0a'\x03a&\xFEa&\xF9\x84a\x19\x07V[a\x18\x8DV[a\x19\x07V[\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[a'\x1D\x83a&\xE8V[a'1a')\x82a'\nV[\x84\x84Ta&\x96V[\x82UPPPPV[`\0\x90V[a'Fa'9V[a'Q\x81\x84\x84a'\x14V[PPPV[[\x81\x81\x10\x15a'uWa'j`\0\x82a'>V[`\x01\x81\x01\x90Pa'WV[PPV[`\x1F\x82\x11\x15a'\xBAWa'\x8B\x81a%\x01V[a'\x94\x84a&yV[\x81\x01` \x85\x10\x15a'\xA3W\x81\x90P[a'\xB7a'\xAF\x85a&yV[\x83\x01\x82a'VV[PP[PPPV[`\0\x82\x82\x1C\x90P\x92\x91PPV[`\0a'\xDD`\0\x19\x84`\x08\x02a'\xBFV[\x19\x80\x83\x16\x91PP\x92\x91PPV[`\0a'\xF6\x83\x83a'\xCCV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a(\x10\x83\x83a&nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a()Wa((a \xF8V[[a(3\x82Ta#\xF6V[a(>\x82\x82\x85a'yV[`\0`\x1F\x83\x11`\x01\x81\x14a(mW`\0\x84\x15a([W\x82\x87\x015\x90P[a(e\x85\x82a'\xEAV[\x86UPa(\xCDV[`\x1F\x19\x84\x16a({\x86a%\x01V[`\0[\x82\x81\x10\x15a(\xA3W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa(~V[\x86\x83\x10\x15a(\xC0W\x84\x89\x015a(\xBC`\x1F\x89\x16\x82a'\xCCV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra(\xF1\x81\x84\x86a&\x01V[\x90P\x93\x92PPPV[\x7FInitializable: contract is alrea`\0\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a)V`.\x83a\x1C\xF9V[\x91Pa)a\x82a(\xFAV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra)\x85\x81a)IV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a`\0\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a)\xE8`&\x83a\x1C\xF9V[\x91Pa)\xF3\x82a)\x8CV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra*\x17\x81a)\xDBV[\x90P\x91\x90PV[\x7FOwnable: caller is not the owner`\0\x82\x01RPV[`\0a*T` \x83a\x1C\xF9V[\x91Pa*_\x82a*\x1EV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra*\x83\x81a*GV[\x90P\x91\x90PV[\x7FInitializable: contract is not i`\0\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a*\xE6`+\x83a\x1C\xF9V[\x91Pa*\xF1\x82a*\x8AV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra+\x15\x81a*\xD9V[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \x99\xD0-\xF5>%\xC6\x9CH\x18\"\xCA\xC2\xD3\xCC\x14\x91\x88\x1B\x84\xBB\xFAb;\xE7\n\x9D\xFA\xB8j\xD5\xBFdsolcC\0\x08\x0F\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361061011f5760003560e01c8063715018a6116100a0578063b107095711610064578063b107095714610403578063bb8aa1fc1461042c578063c4d66de81461046b578063dad544e014610494578063f2fde38b146104bf5761011f565b8063715018a61461031757806374cc86ac1461032e57806382ecf2f61461036b5780638da5cb5b1461039b57806396cd9720146103c65761011f565b80633e47158c116100e75780633e47158c1461021b5780634d1975b41461024657806354fd4d50146102715780635f0150cb1461029c5780636593dc6e146102da5761011f565b806314f6b1a3146101245780631b685b9e1461014d5780631e3342401461018a578063254bd683146101b357806338d38c97146101f0575b600080fd5b34801561013057600080fd5b5061014b60048036038101906101469190611820565b6104e8565b005b34801561015957600080fd5b50610174600480360381019061016f9190611860565b61059c565b60405161018191906118ec565b60405180910390f35b34801561019657600080fd5b506101b160048036038101906101ac919061193d565b6105cf565b005b3480156101bf57600080fd5b506101da60048036038101906101d5919061197d565b610633565b6040516101e79190611c2f565b60405180910390f35b3480156101fc57600080fd5b5061020561085f565b6040516102129190611c6d565b60405180910390f35b34801561022757600080fd5b50610230610887565b60405161023d9190611ca9565b60405180910390f35b34801561025257600080fd5b5061025b610ae0565b6040516102689190611cd3565b60405180910390f35b34801561027d57600080fd5b50610286610aed565b6040516102939190611d43565b60405180910390f35b3480156102a857600080fd5b506102c360048036038101906102be9190611df6565b610b26565b6040516102d1929190611e79565b60405180910390f35b3480156102e657600080fd5b5061030160048036038101906102fc9190611860565b610b73565b60405161030e9190611cd3565b60405180910390f35b34801561032357600080fd5b5061032c610b8b565b005b34801561033a57600080fd5b5061035560048036038101906103509190611860565b610b9f565b6040516103629190611eec565b60405180910390f35b61038560048036038101906103809190611df6565b610c3f565b60405161039291906118ec565b60405180910390f35b3480156103a757600080fd5b506103b0610f43565b6040516103bd9190611f1d565b60405180910390f35b3480156103d257600080fd5b506103ed60048036038101906103e89190611df6565b610f6d565b6040516103fa9190611f47565b60405180910390f35b34801561040f57600080fd5b5061042a60048036038101906104259190611f62565b610fa6565b005b34801561043857600080fd5b50610453600480360381019061044e9190611fd6565b6110cb565b60405161046293929190612034565b60405180910390f35b34801561047757600080fd5b50610492600480360381019061048d9190612097565b61111a565b005b3480156104a057600080fd5b506104a9611233565b6040516104b69190611f1d565b60405180910390f35b3480156104cb57600080fd5b506104e660048036038101906104e19190612097565b6112b0565b005b6104f0611333565b80606560008463ffffffff1663ffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508163ffffffff168173ffffffffffffffffffffffffffffffffffffffff167fff513d80e2c7fa487608f70a618dfbc0cf415699dc69588c747e8c71566c88de60405160405180910390a35050565b60656020528060005260406000206000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6105d7611333565b80606660008463ffffffff1663ffffffff16815260200190815260200160002081905550808263ffffffff167f74d6665c4b26d5596a5aa13d3014e0c06af4d322075a797f87b03cd4c5bc91ca60405160405180910390a35050565b6060606880549050831015806106495750600082145b6108585760405190508160051b602001810160405260008390505b600081101580156106755750838111155b15610856576000606882815481106106905761068f6120c4565b5b9060005260206000200154905060008060006106ab846113b1565b9250925092506106c08963ffffffff166113ec565b63ffffffff166106d58463ffffffff166113ec565b63ffffffff1603610844576001865101865260008173ffffffffffffffffffffffffffffffffffffffff1663609d33346040518163ffffffff1660e01b8152600401600060405180830381865afa158015610734573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061075d9190612214565b905060008273ffffffffffffffffffffffffffffffffffffffff1663bcef3b556040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d09190612272565b90506040518060a001604052808881526020018781526020018567ffffffffffffffff168152602001828152602001838152508860018a5161081291906122ce565b81518110610823576108226120c4565b5b60200260200101819052508888511061084157505050505050610856565b50505b84806001900395505050505050610664565b505b9392505050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000806108b67fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610360001b6113f6565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146108f55780915050610add565b60026040518060400160405280601a81526020017f4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000815250516109389190612302565b7f4f564d5f4c3143726f7373446f6d61696e4d657373656e67657200000000000060001c1760001b61099230600060405160200161097792919061235c565b60405160208183030381529060405280519060200120611401565b146109c9576040517f54e433cd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006109fd3060016040516020016109e292919061235c565b604051602081830303815290604052805190602001206113f6565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610aab578073ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa2919061239a565b92505050610add565b6040517f332144db00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b6000606880549050905090565b6040518060400160405280600581526020017f312e332e3000000000000000000000000000000000000000000000000000000081525081565b6000806000610b3787878787610f6d565b9050600080610b5860676000858152602001908152602001600020546113b1565b92509250508082809550819650505050505094509492505050565b60666020528060005260406000206000915090505481565b610b93611333565b610b9d600061140c565b565b60696020528060005260406000206000915090508054610bbe906123f6565b80601f0160208091040260200160405190810160405280929190818152602001828054610bea906123f6565b8015610c375780601f10610c0c57610100808354040283529160200191610c37565b820191906000526020600020905b815481529060010190602001808311610c1a57829003601f168201915b505050505081565b600080606560008763ffffffff1663ffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610cf557856040517f031c6de4000000000000000000000000000000000000000000000000000000008152600401610cec9190612427565b60405180910390fd5b606660008763ffffffff1663ffffffff168152602001908152602001600020543414610d4d576040517f8620aa1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600143610d5c91906122ce565b409050610dcf3387838888606960008e63ffffffff1663ffffffff168152602001908152602001600020604051602001610d9b96959493929190612599565b6040516020818303038152906040528373ffffffffffffffffffffffffffffffffffffffff166114d290919063ffffffff16565b92508273ffffffffffffffffffffffffffffffffffffffff16638129fc1c346040518263ffffffff1660e01b81526004016000604051808303818588803b158015610e1957600080fd5b505af1158015610e2d573d6000803e3d6000fd5b50505050506000610e4088888888610f6d565b90506000801b606760008381526020019081526020016000205414610e9c57806040517f014f6fe5000000000000000000000000000000000000000000000000000000008152600401610e939190611f47565b60405180910390fd5b6000610ea98942876114e8565b90508060676000848152602001908152602001600020819055506068819080600181540180825580915050600190039060005260206000200160009091909190915055878963ffffffff168673ffffffffffffffffffffffffffffffffffffffff167f5b565efe82411da98814f356d0e7bcb8f0219b8d970307c5afb4a6903a8b2e3560405160405180910390a450505050949350505050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600084848484604051602001610f86949392919061262e565b604051602081830303815290604052805190602001209050949350505050565b610fae611333565b82606560008663ffffffff1663ffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508181606960008763ffffffff1663ffffffff168152602001908152602001600020918261103a929190612806565b508363ffffffff168373ffffffffffffffffffffffffffffffffffffffff167fff513d80e2c7fa487608f70a618dfbc0cf415699dc69588c747e8c71566c88de60405160405180910390a38363ffffffff167fa47fcdf075d680d3817bfca7973b373e1a5f6cfc3b444748299cc2b83d8348f983836040516110bd9291906128d6565b60405180910390a250505050565b6000806000806000806110fb606888815481106110eb576110ea6120c4565b5b90600052602060002001546113b1565b9250925092508282828096508197508298505050505050509193909250565b61112261085f565b600060019054906101000a900460ff1615801561115157508060ff1660008054906101000a900460ff1660ff16105b611190576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111879061296c565b60405180910390fd5b806000806101000a81548160ff021916908360ff1602179055506001600060016101000a81548160ff0219169083151502179055506111cd6114fe565b6111d56115ad565b6111de8261140c565b60008060016101000a81548160ff0219169083151502179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498816040516112279190611c6d565b60405180910390a15050565b600061123d610887565b73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ab919061239a565b905090565b6112b8611333565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611327576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161131e906129fe565b60405180910390fd5b6113308161140c565b50565b61133b611606565b73ffffffffffffffffffffffffffffffffffffffff16611359610f43565b73ffffffffffffffffffffffffffffffffffffffff16146113af576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113a690612a6a565b60405180910390fd5b565b60008060008360e01c925067ffffffffffffffff8460a01c16915073ffffffffffffffffffffffffffffffffffffffff841690509193909250565b6000819050919050565b600081549050919050565b600081549050919050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081603360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b60006114e06000848461160e565b905092915050565b6000818360a01b8560e01b171790509392505050565b3373ffffffffffffffffffffffffffffffffffffffff1661151d610887565b73ffffffffffffffffffffffffffffffffffffffff161415801561157457503373ffffffffffffffffffffffffffffffffffffffff1661155b611233565b73ffffffffffffffffffffffffffffffffffffffff1614155b156115ab576040517fc4050a2600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b600060019054906101000a900460ff166115fc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115f390612afc565b60405180910390fd5b6116046116ff565b565b600033905090565b600060608203516040830351602084035184518060208701018051600283016c5af43d3d93803e606057fd5bf3895289600d8a035278593da1005b363d3d373d3d3d3d610000806062363936013d738160481b1760218a03527f9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff603a8a035272fd6100003d81600a3d39f336602c57343d527f6062820160781b1761ff9e82106059018a03528060f01b8352606c8101604c8a038cf09750876116d95763301164256000526004601cfd5b8183528389528460208a03528560408a03528660608a0352505050505050509392505050565b600060019054906101000a900460ff1661174e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161174590612afc565b60405180910390fd5b61175e611759611606565b61140c565b565b6000604051905090565b600080fd5b600080fd5b600063ffffffff82169050919050565b61178d81611774565b811461179857600080fd5b50565b6000813590506117aa81611784565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006117db826117b0565b9050919050565b60006117ed826117d0565b9050919050565b6117fd816117e2565b811461180857600080fd5b50565b60008135905061181a816117f4565b92915050565b600080604083850312156118375761183661176a565b5b60006118458582860161179b565b92505060206118568582860161180b565b9150509250929050565b6000602082840312156118765761187561176a565b5b60006118848482850161179b565b91505092915050565b6000819050919050565b60006118b26118ad6118a8846117b0565b61188d565b6117b0565b9050919050565b60006118c482611897565b9050919050565b60006118d6826118b9565b9050919050565b6118e6816118cb565b82525050565b600060208201905061190160008301846118dd565b92915050565b6000819050919050565b61191a81611907565b811461192557600080fd5b50565b60008135905061193781611911565b92915050565b600080604083850312156119545761195361176a565b5b60006119628582860161179b565b925050602061197385828601611928565b9150509250929050565b6000806000606084860312156119965761199561176a565b5b60006119a48682870161179b565b93505060206119b586828701611928565b92505060406119c686828701611928565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611a0581611907565b82525050565b6000819050919050565b6000611a2082611a0b565b9050919050565b611a3081611a15565b82525050565b600067ffffffffffffffff82169050919050565b6000611a65611a60611a5b84611a36565b61188d565b611a36565b9050919050565b611a7581611a4a565b82525050565b611a8481611a15565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ac4578082015181840152602081019050611aa9565b83811115611ad3576000848401525b50505050565b6000601f19601f8301169050919050565b6000611af582611a8a565b611aff8185611a95565b9350611b0f818560208601611aa6565b611b1881611ad9565b840191505092915050565b600060a083016000830151611b3b60008601826119fc565b506020830151611b4e6020860182611a27565b506040830151611b616040860182611a6c565b506060830151611b746060860182611a7b565b5060808301518482036080860152611b8c8282611aea565b9150508091505092915050565b6000611ba58383611b23565b905092915050565b6000602082019050919050565b6000611bc5826119d0565b611bcf81856119db565b935083602082028501611be1856119ec565b8060005b85811015611c1d5784840389528151611bfe8582611b99565b9450611c0983611bad565b925060208a01995050600181019050611be5565b50829750879550505050505092915050565b60006020820190508181036000830152611c498184611bba565b905092915050565b600060ff82169050919050565b611c6781611c51565b82525050565b6000602082019050611c826000830184611c5e565b92915050565b6000611c93826118b9565b9050919050565b611ca381611c88565b82525050565b6000602082019050611cbe6000830184611c9a565b92915050565b611ccd81611907565b82525050565b6000602082019050611ce86000830184611cc4565b92915050565b600081519050919050565b600082825260208201905092915050565b6000611d1582611cee565b611d1f8185611cf9565b9350611d2f818560208601611aa6565b611d3881611ad9565b840191505092915050565b60006020820190508181036000830152611d5d8184611d0a565b905092915050565b611d6e81611a0b565b8114611d7957600080fd5b50565b600081359050611d8b81611d65565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f840112611db657611db5611d91565b5b8235905067ffffffffffffffff811115611dd357611dd2611d96565b5b602083019150836001820283011115611def57611dee611d9b565b5b9250929050565b60008060008060608587031215611e1057611e0f61176a565b5b6000611e1e8782880161179b565b9450506020611e2f87828801611d7c565b935050604085013567ffffffffffffffff811115611e5057611e4f61176f565b5b611e5c87828801611da0565b925092505092959194509250565b611e7381611a4a565b82525050565b6000604082019050611e8e60008301856118dd565b611e9b6020830184611e6a565b9392505050565b600082825260208201905092915050565b6000611ebe82611a8a565b611ec88185611ea2565b9350611ed8818560208601611aa6565b611ee181611ad9565b840191505092915050565b60006020820190508181036000830152611f068184611eb3565b905092915050565b611f17816117d0565b82525050565b6000602082019050611f326000830184611f0e565b92915050565b611f4181611a15565b82525050565b6000602082019050611f5c6000830184611f38565b92915050565b60008060008060608587031215611f7c57611f7b61176a565b5b6000611f8a8782880161179b565b9450506020611f9b8782880161180b565b935050604085013567ffffffffffffffff811115611fbc57611fbb61176f565b5b611fc887828801611da0565b925092505092959194509250565b600060208284031215611fec57611feb61176a565b5b6000611ffa84828501611928565b91505092915050565b600061201e61201961201484611774565b61188d565b611774565b9050919050565b61202e81612003565b82525050565b60006060820190506120496000830186612025565b6120566020830185611e6a565b61206360408301846118dd565b949350505050565b612074816117d0565b811461207f57600080fd5b50565b6000813590506120918161206b565b92915050565b6000602082840312156120ad576120ac61176a565b5b60006120bb84828501612082565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61213082611ad9565b810181811067ffffffffffffffff8211171561214f5761214e6120f8565b5b80604052505050565b6000612162611760565b905061216e8282612127565b919050565b600067ffffffffffffffff82111561218e5761218d6120f8565b5b61219782611ad9565b9050602081019050919050565b60006121b76121b284612173565b612158565b9050828152602081018484840111156121d3576121d26120f3565b5b6121de848285611aa6565b509392505050565b600082601f8301126121fb576121fa611d91565b5b815161220b8482602086016121a4565b91505092915050565b60006020828403121561222a5761222961176a565b5b600082015167ffffffffffffffff8111156122485761224761176f565b5b612254848285016121e6565b91505092915050565b60008151905061226c81611d65565b92915050565b6000602082840312156122885761228761176a565b5b60006122968482850161225d565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006122d982611907565b91506122e483611907565b9250828210156122f7576122f661229f565b5b828203905092915050565b600061230d82611907565b915061231883611907565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156123515761235061229f565b5b828202905092915050565b60006040820190506123716000830185611f0e565b61237e6020830184611cc4565b9392505050565b6000815190506123948161206b565b92915050565b6000602082840312156123b0576123af61176a565b5b60006123be84828501612385565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061240e57607f821691505b602082108103612421576124206123c7565b5b50919050565b600060208201905061243c6000830184612025565b92915050565b60008160601b9050919050565b600061245a82612442565b9050919050565b600061246c8261244f565b9050919050565b61248461247f826117d0565b612461565b82525050565b6000819050919050565b6124a56124a082611a15565b61248a565b82525050565b6124bc6124b782611a0b565b61248a565b82525050565b600081905092915050565b82818337600083830152505050565b60006124e883856124c2565b93506124f58385846124cd565b82840190509392505050565b60008190508160005260206000209050919050565b60008154612523816123f6565b61252d81866124c2565b94506001821660008114612548576001811461255d57612590565b60ff1983168652811515820286019350612590565b61256685612501565b60005b8381101561258857815481890152600182019150602081019050612569565b838801955050505b50505092915050565b60006125a58289612473565b6014820191506125b58288612494565b6020820191506125c582876124ab565b6020820191506125d68285876124dc565b91506125e28284612516565b9150819050979650505050505050565b6125fb81611a15565b82525050565b600061260d8385611ea2565b935061261a8385846124cd565b61262383611ad9565b840190509392505050565b60006060820190506126436000830187612025565b61265060208301866125f2565b8181036040830152612663818486612601565b905095945050505050565b600082905092915050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026126c67fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82612689565b6126d08683612689565b95508019841693508086168417925050509392505050565b60006127036126fe6126f984611907565b61188d565b611907565b9050919050565b6000819050919050565b61271d836126e8565b6127316127298261270a565b848454612696565b825550505050565b600090565b612746612739565b612751818484612714565b505050565b5b818110156127755761276a60008261273e565b600181019050612757565b5050565b601f8211156127ba5761278b81612501565b61279484612679565b810160208510156127a3578190505b6127b76127af85612679565b830182612756565b50505b505050565b600082821c905092915050565b60006127dd600019846008026127bf565b1980831691505092915050565b60006127f683836127cc565b9150826002028217905092915050565b612810838361266e565b67ffffffffffffffff811115612829576128286120f8565b5b61283382546123f6565b61283e828285612779565b6000601f83116001811461286d576000841561285b578287013590505b61286585826127ea565b8655506128cd565b601f19841661287b86612501565b60005b828110156128a35784890135825560018201915060208501945060208101905061287e565b868310156128c057848901356128bc601f8916826127cc565b8355505b6001600288020188555050505b50505050505050565b600060208201905081810360008301526128f1818486612601565b90509392505050565b7f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160008201527f647920696e697469616c697a6564000000000000000000000000000000000000602082015250565b6000612956602e83611cf9565b9150612961826128fa565b604082019050919050565b6000602082019050818103600083015261298581612949565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006129e8602683611cf9565b91506129f38261298c565b604082019050919050565b60006020820190508181036000830152612a17816129db565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000612a54602083611cf9565b9150612a5f82612a1e565b602082019050919050565b60006020820190508181036000830152612a8381612a47565b9050919050565b7f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960008201527f6e697469616c697a696e67000000000000000000000000000000000000000000602082015250565b6000612ae6602b83611cf9565b9150612af182612a8a565b604082019050919050565b60006020820190508181036000830152612b1581612ad9565b905091905056fea264697066735822122099d02df53e25c69c481822cac2d3cc1491881b84bbfa623be70a9dfab86ad5bf64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\x1FW`\x005`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xA0W\x80c\xB1\x07\tW\x11a\0dW\x80c\xB1\x07\tW\x14a\x04\x03W\x80c\xBB\x8A\xA1\xFC\x14a\x04,W\x80c\xC4\xD6m\xE8\x14a\x04kW\x80c\xDA\xD5D\xE0\x14a\x04\x94W\x80c\xF2\xFD\xE3\x8B\x14a\x04\xBFWa\x01\x1FV[\x80cqP\x18\xA6\x14a\x03\x17W\x80ct\xCC\x86\xAC\x14a\x03.W\x80c\x82\xEC\xF2\xF6\x14a\x03kW\x80c\x8D\xA5\xCB[\x14a\x03\x9BW\x80c\x96\xCD\x97 \x14a\x03\xC6Wa\x01\x1FV[\x80c>G\x15\x8C\x11a\0\xE7W\x80c>G\x15\x8C\x14a\x02\x1BW\x80cM\x19u\xB4\x14a\x02FW\x80cT\xFDMP\x14a\x02qW\x80c_\x01P\xCB\x14a\x02\x9CW\x80ce\x93\xDCn\x14a\x02\xDAWa\x01\x1FV[\x80c\x14\xF6\xB1\xA3\x14a\x01$W\x80c\x1Bh[\x9E\x14a\x01MW\x80c\x1E3B@\x14a\x01\x8AW\x80c%K\xD6\x83\x14a\x01\xB3W\x80c8\xD3\x8C\x97\x14a\x01\xF0W[`\0\x80\xFD[4\x80\x15a\x010W`\0\x80\xFD[Pa\x01K`\x04\x806\x03\x81\x01\x90a\x01F\x91\x90a\x18 V[a\x04\xE8V[\0[4\x80\x15a\x01YW`\0\x80\xFD[Pa\x01t`\x04\x806\x03\x81\x01\x90a\x01o\x91\x90a\x18`V[a\x05\x9CV[`@Qa\x01\x81\x91\x90a\x18\xECV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x96W`\0\x80\xFD[Pa\x01\xB1`\x04\x806\x03\x81\x01\x90a\x01\xAC\x91\x90a\x19=V[a\x05\xCFV[\0[4\x80\x15a\x01\xBFW`\0\x80\xFD[Pa\x01\xDA`\x04\x806\x03\x81\x01\x90a\x01\xD5\x91\x90a\x19}V[a\x063V[`@Qa\x01\xE7\x91\x90a\x1C/V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xFCW`\0\x80\xFD[Pa\x02\x05a\x08_V[`@Qa\x02\x12\x91\x90a\x1CmV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02'W`\0\x80\xFD[Pa\x020a\x08\x87V[`@Qa\x02=\x91\x90a\x1C\xA9V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02RW`\0\x80\xFD[Pa\x02[a\n\xE0V[`@Qa\x02h\x91\x90a\x1C\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02}W`\0\x80\xFD[Pa\x02\x86a\n\xEDV[`@Qa\x02\x93\x91\x90a\x1DCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA8W`\0\x80\xFD[Pa\x02\xC3`\x04\x806\x03\x81\x01\x90a\x02\xBE\x91\x90a\x1D\xF6V[a\x0B&V[`@Qa\x02\xD1\x92\x91\x90a\x1EyV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xE6W`\0\x80\xFD[Pa\x03\x01`\x04\x806\x03\x81\x01\x90a\x02\xFC\x91\x90a\x18`V[a\x0BsV[`@Qa\x03\x0E\x91\x90a\x1C\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03#W`\0\x80\xFD[Pa\x03,a\x0B\x8BV[\0[4\x80\x15a\x03:W`\0\x80\xFD[Pa\x03U`\x04\x806\x03\x81\x01\x90a\x03P\x91\x90a\x18`V[a\x0B\x9FV[`@Qa\x03b\x91\x90a\x1E\xECV[`@Q\x80\x91\x03\x90\xF3[a\x03\x85`\x04\x806\x03\x81\x01\x90a\x03\x80\x91\x90a\x1D\xF6V[a\x0C?V[`@Qa\x03\x92\x91\x90a\x18\xECV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xA7W`\0\x80\xFD[Pa\x03\xB0a\x0FCV[`@Qa\x03\xBD\x91\x90a\x1F\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD2W`\0\x80\xFD[Pa\x03\xED`\x04\x806\x03\x81\x01\x90a\x03\xE8\x91\x90a\x1D\xF6V[a\x0FmV[`@Qa\x03\xFA\x91\x90a\x1FGV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x0FW`\0\x80\xFD[Pa\x04*`\x04\x806\x03\x81\x01\x90a\x04%\x91\x90a\x1FbV[a\x0F\xA6V[\0[4\x80\x15a\x048W`\0\x80\xFD[Pa\x04S`\x04\x806\x03\x81\x01\x90a\x04N\x91\x90a\x1F\xD6V[a\x10\xCBV[`@Qa\x04b\x93\x92\x91\x90a 4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04wW`\0\x80\xFD[Pa\x04\x92`\x04\x806\x03\x81\x01\x90a\x04\x8D\x91\x90a \x97V[a\x11\x1AV[\0[4\x80\x15a\x04\xA0W`\0\x80\xFD[Pa\x04\xA9a\x123V[`@Qa\x04\xB6\x91\x90a\x1F\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCBW`\0\x80\xFD[Pa\x04\xE6`\x04\x806\x03\x81\x01\x90a\x04\xE1\x91\x90a \x97V[a\x12\xB0V[\0[a\x04\xF0a\x133V[\x80`e`\0\x84c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81c\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFFQ=\x80\xE2\xC7\xFAHv\x08\xF7\na\x8D\xFB\xC0\xCFAV\x99\xDCiX\x8Ct~\x8CqVl\x88\xDE`@Q`@Q\x80\x91\x03\x90\xA3PPV[`e` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x05\xD7a\x133V[\x80`f`\0\x84c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x80\x82c\xFF\xFF\xFF\xFF\x16\x7Ft\xD6f\\K&\xD5YjZ\xA1=0\x14\xE0\xC0j\xF4\xD3\"\x07Zy\x7F\x87\xB0<\xD4\xC5\xBC\x91\xCA`@Q`@Q\x80\x91\x03\x90\xA3PPV[```h\x80T\x90P\x83\x10\x15\x80a\x06IWP`\0\x82\x14[a\x08XW`@Q\x90P\x81`\x05\x1B` \x01\x81\x01`@R`\0\x83\x90P[`\0\x81\x10\x15\x80\x15a\x06uWP\x83\x81\x11\x15[\x15a\x08VW`\0`h\x82\x81T\x81\x10a\x06\x90Wa\x06\x8Fa \xC4V[[\x90`\0R` `\0 \x01T\x90P`\0\x80`\0a\x06\xAB\x84a\x13\xB1V[\x92P\x92P\x92Pa\x06\xC0\x89c\xFF\xFF\xFF\xFF\x16a\x13\xECV[c\xFF\xFF\xFF\xFF\x16a\x06\xD5\x84c\xFF\xFF\xFF\xFF\x16a\x13\xECV[c\xFF\xFF\xFF\xFF\x16\x03a\x08DW`\x01\x86Q\x01\x86R`\0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c`\x9D34`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x074W=`\0\x80>=`\0\xFD[PPPP`@Q=`\0\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07]\x91\x90a\"\x14V[\x90P`\0\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBC\xEF;U`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\xACW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xD0\x91\x90a\"rV[\x90P`@Q\x80`\xA0\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x85g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01\x83\x81RP\x88`\x01\x8AQa\x08\x12\x91\x90a\"\xCEV[\x81Q\x81\x10a\x08#Wa\x08\"a \xC4V[[` \x02` \x01\x01\x81\x90RP\x88\x88Q\x10a\x08AWPPPPPPa\x08VV[PP[\x84\x80`\x01\x90\x03\x95PPPPPPa\x06dV[P[\x93\x92PPPV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80a\x08\xB6\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03`\0\x1Ba\x13\xF6V[\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xF5W\x80\x91PPa\n\xDDV[`\x02`@Q\x80`@\x01`@R\x80`\x1A\x81R` \x01\x7FOVM_L1CrossDomainMessenger\0\0\0\0\0\0\x81RPQa\t8\x91\x90a#\x02V[\x7FOVM_L1CrossDomainMessenger\0\0\0\0\0\0`\0\x1C\x17`\0\x1Ba\t\x920`\0`@Q` \x01a\tw\x92\x91\x90a#\\V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x14\x01V[\x14a\t\xC9W`@Q\x7FT\xE43\xCD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0a\t\xFD0`\x01`@Q` \x01a\t\xE2\x92\x91\x90a#\\V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x13\xF6V[\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n\xABW\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n~W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xA2\x91\x90a#\x9AV[\x92PPPa\n\xDDV[`@Q\x7F3!D\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x90V[`\0`h\x80T\x90P\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F1.3.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\0\x80`\0a\x0B7\x87\x87\x87\x87a\x0FmV[\x90P`\0\x80a\x0BX`g`\0\x85\x81R` \x01\x90\x81R` \x01`\0 Ta\x13\xB1V[\x92P\x92PP\x80\x82\x80\x95P\x81\x96PPPPPP\x94P\x94\x92PPPV[`f` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[a\x0B\x93a\x133V[a\x0B\x9D`\0a\x14\x0CV[V[`i` R\x80`\0R`@`\0 `\0\x91P\x90P\x80Ta\x0B\xBE\x90a#\xF6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xEA\x90a#\xF6V[\x80\x15a\x0C7W\x80`\x1F\x10a\x0C\x0CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C7V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x1AW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[`\0\x80`e`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0C\xF5W\x85`@Q\x7F\x03\x1Cm\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xEC\x91\x90a$'V[`@Q\x80\x91\x03\x90\xFD[`f`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T4\x14a\rMW`@Q\x7F\x86 \xAA\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x01Ca\r\\\x91\x90a\"\xCEV[@\x90Pa\r\xCF3\x87\x83\x88\x88`i`\0\x8Ec\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `@Q` \x01a\r\x9B\x96\x95\x94\x93\x92\x91\x90a%\x99V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x14\xD2\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x92P\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x81)\xFC\x1C4`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\0`@Q\x80\x83\x03\x81\x85\x88\x80;\x15\x80\x15a\x0E\x19W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x0E-W=`\0\x80>=`\0\xFD[PPPPP`\0a\x0E@\x88\x88\x88\x88a\x0FmV[\x90P`\0\x80\x1B`g`\0\x83\x81R` \x01\x90\x81R` \x01`\0 T\x14a\x0E\x9CW\x80`@Q\x7F\x01Oo\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x93\x91\x90a\x1FGV[`@Q\x80\x91\x03\x90\xFD[`\0a\x0E\xA9\x89B\x87a\x14\xE8V[\x90P\x80`g`\0\x84\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`h\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90`\0R` `\0 \x01`\0\x90\x91\x90\x91\x90\x91PU\x87\x89c\xFF\xFF\xFF\xFF\x16\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F[V^\xFE\x82A\x1D\xA9\x88\x14\xF3V\xD0\xE7\xBC\xB8\xF0!\x9B\x8D\x97\x03\x07\xC5\xAF\xB4\xA6\x90:\x8B.5`@Q`@Q\x80\x91\x03\x90\xA4PPPP\x94\x93PPPPV[`\0`3`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\0\x84\x84\x84\x84`@Q` \x01a\x0F\x86\x94\x93\x92\x91\x90a&.V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x94\x93PPPPV[a\x0F\xAEa\x133V[\x82`e`\0\x86c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81\x81`i`\0\x87c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x91\x82a\x10:\x92\x91\x90a(\x06V[P\x83c\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFFQ=\x80\xE2\xC7\xFAHv\x08\xF7\na\x8D\xFB\xC0\xCFAV\x99\xDCiX\x8Ct~\x8CqVl\x88\xDE`@Q`@Q\x80\x91\x03\x90\xA3\x83c\xFF\xFF\xFF\xFF\x16\x7F\xA4\x7F\xCD\xF0u\xD6\x80\xD3\x81{\xFC\xA7\x97;7>\x1A_l\xFC;DGH)\x9C\xC2\xB8=\x83H\xF9\x83\x83`@Qa\x10\xBD\x92\x91\x90a(\xD6V[`@Q\x80\x91\x03\x90\xA2PPPPV[`\0\x80`\0\x80`\0\x80a\x10\xFB`h\x88\x81T\x81\x10a\x10\xEBWa\x10\xEAa \xC4V[[\x90`\0R` `\0 \x01Ta\x13\xB1V[\x92P\x92P\x92P\x82\x82\x82\x80\x96P\x81\x97P\x82\x98PPPPPPP\x91\x93\x90\x92PV[a\x11\"a\x08_V[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80\x15a\x11QWP\x80`\xFF\x16`\0\x80T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x10[a\x11\x90W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\x87\x90a)lV[`@Q\x80\x91\x03\x90\xFD[\x80`\0\x80a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\xFF\x16\x02\x17\x90UP`\x01`\0`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x11\xCDa\x14\xFEV[a\x11\xD5a\x15\xADV[a\x11\xDE\x82a\x14\x0CV[`\0\x80`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x81`@Qa\x12'\x91\x90a\x1CmV[`@Q\x80\x91\x03\x90\xA1PPV[`\0a\x12=a\x08\x87V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x12\x87W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xAB\x91\x90a#\x9AV[\x90P\x90V[a\x12\xB8a\x133V[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13'W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x1E\x90a)\xFEV[`@Q\x80\x91\x03\x90\xFD[a\x130\x81a\x14\x0CV[PV[a\x13;a\x16\x06V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x13Ya\x0FCV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xAFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xA6\x90a*jV[`@Q\x80\x91\x03\x90\xFD[V[`\0\x80`\0\x83`\xE0\x1C\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84`\xA0\x1C\x16\x91Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90P\x91\x93\x90\x92PV[`\0\x81\x90P\x91\x90PV[`\0\x81T\x90P\x91\x90PV[`\0\x81T\x90P\x91\x90PV[`\0`3`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81`3`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\0a\x14\xE0`\0\x84\x84a\x16\x0EV[\x90P\x92\x91PPV[`\0\x81\x83`\xA0\x1B\x85`\xE0\x1B\x17\x17\x90P\x93\x92PPPV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\x1Da\x08\x87V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x15tWP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15[a\x123V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x15\xABW`@Q\x7F\xC4\x05\n&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15\xFCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xF3\x90a*\xFCV[`@Q\x80\x91\x03\x90\xFD[a\x16\x04a\x16\xFFV[V[`\x003\x90P\x90V[`\0``\x82\x03Q`@\x83\x03Q` \x84\x03Q\x84Q\x80` \x87\x01\x01\x80Q`\x02\x83\x01lZ\xF4==\x93\x80>``W\xFD[\xF3\x89R\x89`\r\x8A\x03RxY=\xA1\0[6==7====a\0\0\x80`b696\x01=s\x81`H\x1B\x17`!\x8A\x03R\x7F\x9EJ\xC3O!\xC6\x19\xCE\xFC\x92l\x8B\xD9;T\xBFZ9\xC7\xAB!'\xA8\x95\xAF\x1C\xC0i\x1D~=\xFF`:\x8A\x03Rr\xFDa\0\0=\x81`\n=9\xF36`,W4=R\x7F`b\x82\x01`x\x1B\x17a\xFF\x9E\x82\x10`Y\x01\x8A\x03R\x80`\xF0\x1B\x83R`l\x81\x01`L\x8A\x03\x8C\xF0\x97P\x87a\x16\xD9Wc0\x11d%`\0R`\x04`\x1C\xFD[\x81\x83R\x83\x89R\x84` \x8A\x03R\x85`@\x8A\x03R\x86``\x8A\x03RPPPPPPP\x93\x92PPPV[`\0`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x17NW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17E\x90a*\xFCV[`@Q\x80\x91\x03\x90\xFD[a\x17^a\x17Ya\x16\x06V[a\x14\x0CV[V[`\0`@Q\x90P\x90V[`\0\x80\xFD[`\0\x80\xFD[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x17\x8D\x81a\x17tV[\x81\x14a\x17\x98W`\0\x80\xFD[PV[`\0\x815\x90Pa\x17\xAA\x81a\x17\x84V[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x17\xDB\x82a\x17\xB0V[\x90P\x91\x90PV[`\0a\x17\xED\x82a\x17\xD0V[\x90P\x91\x90PV[a\x17\xFD\x81a\x17\xE2V[\x81\x14a\x18\x08W`\0\x80\xFD[PV[`\0\x815\x90Pa\x18\x1A\x81a\x17\xF4V[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x187Wa\x186a\x17jV[[`\0a\x18E\x85\x82\x86\x01a\x17\x9BV[\x92PP` a\x18V\x85\x82\x86\x01a\x18\x0BV[\x91PP\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a\x18vWa\x18ua\x17jV[[`\0a\x18\x84\x84\x82\x85\x01a\x17\x9BV[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a\x18\xB2a\x18\xADa\x18\xA8\x84a\x17\xB0V[a\x18\x8DV[a\x17\xB0V[\x90P\x91\x90PV[`\0a\x18\xC4\x82a\x18\x97V[\x90P\x91\x90PV[`\0a\x18\xD6\x82a\x18\xB9V[\x90P\x91\x90PV[a\x18\xE6\x81a\x18\xCBV[\x82RPPV[`\0` \x82\x01\x90Pa\x19\x01`\0\x83\x01\x84a\x18\xDDV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a\x19\x1A\x81a\x19\x07V[\x81\x14a\x19%W`\0\x80\xFD[PV[`\0\x815\x90Pa\x197\x81a\x19\x11V[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x19TWa\x19Sa\x17jV[[`\0a\x19b\x85\x82\x86\x01a\x17\x9BV[\x92PP` a\x19s\x85\x82\x86\x01a\x19(V[\x91PP\x92P\x92\x90PV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x19\x96Wa\x19\x95a\x17jV[[`\0a\x19\xA4\x86\x82\x87\x01a\x17\x9BV[\x93PP` a\x19\xB5\x86\x82\x87\x01a\x19(V[\x92PP`@a\x19\xC6\x86\x82\x87\x01a\x19(V[\x91PP\x92P\x92P\x92V[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x1A\x05\x81a\x19\x07V[\x82RPPV[`\0\x81\x90P\x91\x90PV[`\0a\x1A \x82a\x1A\x0BV[\x90P\x91\x90PV[a\x1A0\x81a\x1A\x15V[\x82RPPV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x1Aea\x1A`a\x1A[\x84a\x1A6V[a\x18\x8DV[a\x1A6V[\x90P\x91\x90PV[a\x1Au\x81a\x1AJV[\x82RPPV[a\x1A\x84\x81a\x1A\x15V[\x82RPPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0[\x83\x81\x10\x15a\x1A\xC4W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x1A\xA9V[\x83\x81\x11\x15a\x1A\xD3W`\0\x84\x84\x01R[PPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a\x1A\xF5\x82a\x1A\x8AV[a\x1A\xFF\x81\x85a\x1A\x95V[\x93Pa\x1B\x0F\x81\x85` \x86\x01a\x1A\xA6V[a\x1B\x18\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0`\xA0\x83\x01`\0\x83\x01Qa\x1B;`\0\x86\x01\x82a\x19\xFCV[P` \x83\x01Qa\x1BN` \x86\x01\x82a\x1A'V[P`@\x83\x01Qa\x1Ba`@\x86\x01\x82a\x1AlV[P``\x83\x01Qa\x1Bt``\x86\x01\x82a\x1A{V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra\x1B\x8C\x82\x82a\x1A\xEAV[\x91PP\x80\x91PP\x92\x91PPV[`\0a\x1B\xA5\x83\x83a\x1B#V[\x90P\x92\x91PPV[`\0` \x82\x01\x90P\x91\x90PV[`\0a\x1B\xC5\x82a\x19\xD0V[a\x1B\xCF\x81\x85a\x19\xDBV[\x93P\x83` \x82\x02\x85\x01a\x1B\xE1\x85a\x19\xECV[\x80`\0[\x85\x81\x10\x15a\x1C\x1DW\x84\x84\x03\x89R\x81Qa\x1B\xFE\x85\x82a\x1B\x99V[\x94Pa\x1C\t\x83a\x1B\xADV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa\x1B\xE5V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1CI\x81\x84a\x1B\xBAV[\x90P\x92\x91PPV[`\0`\xFF\x82\x16\x90P\x91\x90PV[a\x1Cg\x81a\x1CQV[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\x82`\0\x83\x01\x84a\x1C^V[\x92\x91PPV[`\0a\x1C\x93\x82a\x18\xB9V[\x90P\x91\x90PV[a\x1C\xA3\x81a\x1C\x88V[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\xBE`\0\x83\x01\x84a\x1C\x9AV[\x92\x91PPV[a\x1C\xCD\x81a\x19\x07V[\x82RPPV[`\0` \x82\x01\x90Pa\x1C\xE8`\0\x83\x01\x84a\x1C\xC4V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a\x1D\x15\x82a\x1C\xEEV[a\x1D\x1F\x81\x85a\x1C\xF9V[\x93Pa\x1D/\x81\x85` \x86\x01a\x1A\xA6V[a\x1D8\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1D]\x81\x84a\x1D\nV[\x90P\x92\x91PPV[a\x1Dn\x81a\x1A\x0BV[\x81\x14a\x1DyW`\0\x80\xFD[PV[`\0\x815\x90Pa\x1D\x8B\x81a\x1DeV[\x92\x91PPV[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\x83`\x1F\x84\x01\x12a\x1D\xB6Wa\x1D\xB5a\x1D\x91V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1D\xD3Wa\x1D\xD2a\x1D\x96V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1D\xEFWa\x1D\xEEa\x1D\x9BV[[\x92P\x92\x90PV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15a\x1E\x10Wa\x1E\x0Fa\x17jV[[`\0a\x1E\x1E\x87\x82\x88\x01a\x17\x9BV[\x94PP` a\x1E/\x87\x82\x88\x01a\x1D|V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1EPWa\x1EOa\x17oV[[a\x1E\\\x87\x82\x88\x01a\x1D\xA0V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[a\x1Es\x81a\x1AJV[\x82RPPV[`\0`@\x82\x01\x90Pa\x1E\x8E`\0\x83\x01\x85a\x18\xDDV[a\x1E\x9B` \x83\x01\x84a\x1EjV[\x93\x92PPPV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a\x1E\xBE\x82a\x1A\x8AV[a\x1E\xC8\x81\x85a\x1E\xA2V[\x93Pa\x1E\xD8\x81\x85` \x86\x01a\x1A\xA6V[a\x1E\xE1\x81a\x1A\xD9V[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x1F\x06\x81\x84a\x1E\xB3V[\x90P\x92\x91PPV[a\x1F\x17\x81a\x17\xD0V[\x82RPPV[`\0` \x82\x01\x90Pa\x1F2`\0\x83\x01\x84a\x1F\x0EV[\x92\x91PPV[a\x1FA\x81a\x1A\x15V[\x82RPPV[`\0` \x82\x01\x90Pa\x1F\\`\0\x83\x01\x84a\x1F8V[\x92\x91PPV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15a\x1F|Wa\x1F{a\x17jV[[`\0a\x1F\x8A\x87\x82\x88\x01a\x17\x9BV[\x94PP` a\x1F\x9B\x87\x82\x88\x01a\x18\x0BV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xBCWa\x1F\xBBa\x17oV[[a\x1F\xC8\x87\x82\x88\x01a\x1D\xA0V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[`\0` \x82\x84\x03\x12\x15a\x1F\xECWa\x1F\xEBa\x17jV[[`\0a\x1F\xFA\x84\x82\x85\x01a\x19(V[\x91PP\x92\x91PPV[`\0a \x1Ea \x19a \x14\x84a\x17tV[a\x18\x8DV[a\x17tV[\x90P\x91\x90PV[a .\x81a \x03V[\x82RPPV[`\0``\x82\x01\x90Pa I`\0\x83\x01\x86a %V[a V` \x83\x01\x85a\x1EjV[a c`@\x83\x01\x84a\x18\xDDV[\x94\x93PPPPV[a t\x81a\x17\xD0V[\x81\x14a \x7FW`\0\x80\xFD[PV[`\0\x815\x90Pa \x91\x81a kV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a \xADWa \xACa\x17jV[[`\0a \xBB\x84\x82\x85\x01a \x82V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`2`\x04R`$`\0\xFD[`\0\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`A`\x04R`$`\0\xFD[a!0\x82a\x1A\xD9V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a!OWa!Na \xF8V[[\x80`@RPPPV[`\0a!ba\x17`V[\x90Pa!n\x82\x82a!'V[\x91\x90PV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a!\x8EWa!\x8Da \xF8V[[a!\x97\x82a\x1A\xD9V[\x90P` \x81\x01\x90P\x91\x90PV[`\0a!\xB7a!\xB2\x84a!sV[a!XV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a!\xD3Wa!\xD2a \xF3V[[a!\xDE\x84\x82\x85a\x1A\xA6V[P\x93\x92PPPV[`\0\x82`\x1F\x83\x01\x12a!\xFBWa!\xFAa\x1D\x91V[[\x81Qa\"\x0B\x84\x82` \x86\x01a!\xA4V[\x91PP\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\"*Wa\")a\x17jV[[`\0\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"HWa\"Ga\x17oV[[a\"T\x84\x82\x85\x01a!\xE6V[\x91PP\x92\x91PPV[`\0\x81Q\x90Pa\"l\x81a\x1DeV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\"\x88Wa\"\x87a\x17jV[[`\0a\"\x96\x84\x82\x85\x01a\"]V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a\"\xD9\x82a\x19\x07V[\x91Pa\"\xE4\x83a\x19\x07V[\x92P\x82\x82\x10\x15a\"\xF7Wa\"\xF6a\"\x9FV[[\x82\x82\x03\x90P\x92\x91PPV[`\0a#\r\x82a\x19\x07V[\x91Pa#\x18\x83a\x19\x07V[\x92P\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04\x83\x11\x82\x15\x15\x16\x15a#QWa#Pa\"\x9FV[[\x82\x82\x02\x90P\x92\x91PPV[`\0`@\x82\x01\x90Pa#q`\0\x83\x01\x85a\x1F\x0EV[a#~` \x83\x01\x84a\x1C\xC4V[\x93\x92PPPV[`\0\x81Q\x90Pa#\x94\x81a kV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a#\xB0Wa#\xAFa\x17jV[[`\0a#\xBE\x84\x82\x85\x01a#\x85V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\"`\x04R`$`\0\xFD[`\0`\x02\x82\x04\x90P`\x01\x82\x16\x80a$\x0EW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a$!Wa$ a#\xC7V[[P\x91\x90PV[`\0` \x82\x01\x90Pa$<`\0\x83\x01\x84a %V[\x92\x91PPV[`\0\x81``\x1B\x90P\x91\x90PV[`\0a$Z\x82a$BV[\x90P\x91\x90PV[`\0a$l\x82a$OV[\x90P\x91\x90PV[a$\x84a$\x7F\x82a\x17\xD0V[a$aV[\x82RPPV[`\0\x81\x90P\x91\x90PV[a$\xA5a$\xA0\x82a\x1A\x15V[a$\x8AV[\x82RPPV[a$\xBCa$\xB7\x82a\x1A\x0BV[a$\x8AV[\x82RPPV[`\0\x81\x90P\x92\x91PPV[\x82\x81\x837`\0\x83\x83\x01RPPPV[`\0a$\xE8\x83\x85a$\xC2V[\x93Pa$\xF5\x83\x85\x84a$\xCDV[\x82\x84\x01\x90P\x93\x92PPPV[`\0\x81\x90P\x81`\0R` `\0 \x90P\x91\x90PV[`\0\x81Ta%#\x81a#\xF6V[a%-\x81\x86a$\xC2V[\x94P`\x01\x82\x16`\0\x81\x14a%HW`\x01\x81\x14a%]Wa%\x90V[`\xFF\x19\x83\x16\x86R\x81\x15\x15\x82\x02\x86\x01\x93Pa%\x90V[a%f\x85a%\x01V[`\0[\x83\x81\x10\x15a%\x88W\x81T\x81\x89\x01R`\x01\x82\x01\x91P` \x81\x01\x90Pa%iV[\x83\x88\x01\x95PPP[PPP\x92\x91PPV[`\0a%\xA5\x82\x89a$sV[`\x14\x82\x01\x91Pa%\xB5\x82\x88a$\x94V[` \x82\x01\x91Pa%\xC5\x82\x87a$\xABV[` \x82\x01\x91Pa%\xD6\x82\x85\x87a$\xDCV[\x91Pa%\xE2\x82\x84a%\x16V[\x91P\x81\x90P\x97\x96PPPPPPPV[a%\xFB\x81a\x1A\x15V[\x82RPPV[`\0a&\r\x83\x85a\x1E\xA2V[\x93Pa&\x1A\x83\x85\x84a$\xCDV[a&#\x83a\x1A\xD9V[\x84\x01\x90P\x93\x92PPPV[`\0``\x82\x01\x90Pa&C`\0\x83\x01\x87a %V[a&P` \x83\x01\x86a%\xF2V[\x81\x81\x03`@\x83\x01Ra&c\x81\x84\x86a&\x01V[\x90P\x95\x94PPPPPV[`\0\x82\x90P\x92\x91PPV[`\0` `\x1F\x83\x01\x04\x90P\x91\x90PV[`\0\x82\x82\x1B\x90P\x92\x91PPV[`\0`\x08\x83\x02a&\xC6\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a&\x89V[a&\xD0\x86\x83a&\x89V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[`\0a'\x03a&\xFEa&\xF9\x84a\x19\x07V[a\x18\x8DV[a\x19\x07V[\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[a'\x1D\x83a&\xE8V[a'1a')\x82a'\nV[\x84\x84Ta&\x96V[\x82UPPPPV[`\0\x90V[a'Fa'9V[a'Q\x81\x84\x84a'\x14V[PPPV[[\x81\x81\x10\x15a'uWa'j`\0\x82a'>V[`\x01\x81\x01\x90Pa'WV[PPV[`\x1F\x82\x11\x15a'\xBAWa'\x8B\x81a%\x01V[a'\x94\x84a&yV[\x81\x01` \x85\x10\x15a'\xA3W\x81\x90P[a'\xB7a'\xAF\x85a&yV[\x83\x01\x82a'VV[PP[PPPV[`\0\x82\x82\x1C\x90P\x92\x91PPV[`\0a'\xDD`\0\x19\x84`\x08\x02a'\xBFV[\x19\x80\x83\x16\x91PP\x92\x91PPV[`\0a'\xF6\x83\x83a'\xCCV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a(\x10\x83\x83a&nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a()Wa((a \xF8V[[a(3\x82Ta#\xF6V[a(>\x82\x82\x85a'yV[`\0`\x1F\x83\x11`\x01\x81\x14a(mW`\0\x84\x15a([W\x82\x87\x015\x90P[a(e\x85\x82a'\xEAV[\x86UPa(\xCDV[`\x1F\x19\x84\x16a({\x86a%\x01V[`\0[\x82\x81\x10\x15a(\xA3W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa(~V[\x86\x83\x10\x15a(\xC0W\x84\x89\x015a(\xBC`\x1F\x89\x16\x82a'\xCCV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra(\xF1\x81\x84\x86a&\x01V[\x90P\x93\x92PPPV[\x7FInitializable: contract is alrea`\0\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a)V`.\x83a\x1C\xF9V[\x91Pa)a\x82a(\xFAV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra)\x85\x81a)IV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a`\0\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a)\xE8`&\x83a\x1C\xF9V[\x91Pa)\xF3\x82a)\x8CV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra*\x17\x81a)\xDBV[\x90P\x91\x90PV[\x7FOwnable: caller is not the owner`\0\x82\x01RPV[`\0a*T` \x83a\x1C\xF9V[\x91Pa*_\x82a*\x1EV[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra*\x83\x81a*GV[\x90P\x91\x90PV[\x7FInitializable: contract is not i`\0\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a*\xE6`+\x83a\x1C\xF9V[\x91Pa*\xF1\x82a*\x8AV[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra+\x15\x81a*\xD9V[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \x99\xD0-\xF5>%\xC6\x9CH\x18\"\xCA\xC2\xD3\xCC\x14\x91\x88\x1B\x84\xBB\xFAb;\xE7\n\x9D\xFA\xB8j\xD5\xBFdsolcC\0\x08\x0F\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Claim(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Claim>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Claim {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(
                value: alloy::sol_types::private::FixedBytes<32>,
            ) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(
                self,
            ) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<alloy::sol_types::private::FixedBytes<32>> for Claim {
            fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Claim> for alloy::sol_types::private::FixedBytes<32> {
            fn from(value: Claim) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Claim {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Claim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameId(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<GameId>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl GameId {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(
                value: alloy::sol_types::private::FixedBytes<32>,
            ) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(
                self,
            ) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<alloy::sol_types::private::FixedBytes<32>> for GameId {
            fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<GameId> for alloy::sol_types::private::FixedBytes<32> {
            fn from(value: GameId) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameId {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameId {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameType(u32);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<GameType> for u32 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl GameType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u32) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u32 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u32> for GameType {
            fn from(value: u32) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<GameType> for u32 {
            fn from(value: GameType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameType {
            type RustType = u32;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Hash(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Hash>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Hash {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(
                value: alloy::sol_types::private::FixedBytes<32>,
            ) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(
                self,
            ) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<alloy::sol_types::private::FixedBytes<32>> for Hash {
            fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Hash> for alloy::sol_types::private::FixedBytes<32> {
            fn from(value: Hash) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Hash {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Hash {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Timestamp(u64);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Timestamp> for u64 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<64>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Timestamp {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u64) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u64 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u64> for Timestamp {
            fn from(value: u64) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Timestamp> for u64 {
            fn from(value: Timestamp) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Timestamp {
            type RustType = u64;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Timestamp {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct GameSearchResult { uint256 index; GameId metadata; Timestamp timestamp; Claim rootClaim; bytes extraData; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameSearchResult {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub metadata: <GameId as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub timestamp: <Timestamp as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub extraData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            GameId,
            Timestamp,
            Claim,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            <GameId as alloy::sol_types::SolType>::RustType,
            <Timestamp as alloy::sol_types::SolType>::RustType,
            <Claim as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameSearchResult> for UnderlyingRustTuple<'_> {
            fn from(value: GameSearchResult) -> Self {
                (
                    value.index,
                    value.metadata,
                    value.timestamp,
                    value.rootClaim,
                    value.extraData,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameSearchResult {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    index: tuple.0,
                    metadata: tuple.1,
                    timestamp: tuple.2,
                    rootClaim: tuple.3,
                    extraData: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GameSearchResult {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GameSearchResult {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <GameId as alloy_sol_types::SolType>::tokenize(&self.metadata),
                    <Timestamp as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self.rootClaim),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.extraData,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameSearchResult {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GameSearchResult {
            const NAME: &'static str = "GameSearchResult";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GameSearchResult(uint256 index,bytes32 metadata,uint64 timestamp,bytes32 rootClaim,bytes extraData)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.index)
                        .0,
                    <GameId as alloy_sol_types::SolType>::eip712_data_word(
                            &self.metadata,
                        )
                        .0,
                    <Timestamp as alloy_sol_types::SolType>::eip712_data_word(
                            &self.timestamp,
                        )
                        .0,
                    <Claim as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rootClaim,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.extraData,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameSearchResult {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.index)
                    + <GameId as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.metadata,
                    )
                    + <Timestamp as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.timestamp,
                    )
                    + <Claim as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rootClaim,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.extraData,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.index,
                    out,
                );
                <GameId as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.metadata,
                    out,
                );
                <Timestamp as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.timestamp,
                    out,
                );
                <Claim as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rootClaim,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.extraData,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `GameAlreadyExists(bytes32)` and selector `0x014f6fe5`.
```solidity
error GameAlreadyExists(Hash uuid);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameAlreadyExists {
        #[allow(missing_docs)]
        pub uuid: <Hash as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (Hash,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (<Hash as alloy::sol_types::SolType>::RustType,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: GameAlreadyExists) -> Self {
                (value.uuid,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { uuid: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GameAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GameAlreadyExists(bytes32)";
            const SELECTOR: [u8; 4] = [1u8, 79u8, 111u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Hash as alloy_sol_types::SolType>::tokenize(&self.uuid),)
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `IncorrectBondAmount()` and selector `0x8620aa19`.
```solidity
error IncorrectBondAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncorrectBondAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncorrectBondAmount> for UnderlyingRustTuple<'_> {
            fn from(value: IncorrectBondAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncorrectBondAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncorrectBondAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncorrectBondAmount()";
            const SELECTOR: [u8; 4] = [134u8, 32u8, 170u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `NoImplementation(uint32)` and selector `0x031c6de4`.
```solidity
error NoImplementation(GameType gameType);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoImplementation {
        #[allow(missing_docs)]
        pub gameType: <GameType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (GameType,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GameType as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoImplementation> for UnderlyingRustTuple<'_> {
            fn from(value: NoImplementation) -> Self {
                (value.gameType,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { gameType: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoImplementation(uint32)";
            const SELECTOR: [u8; 4] = [3u8, 28u8, 109u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<GameType as alloy_sol_types::SolType>::tokenize(&self.gameType),)
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_NotProxyAdmin()` and selector `0xe818dcc3`.
```solidity
error ProxyAdminOwnedBase_NotProxyAdmin();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_NotProxyAdmin;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_NotProxyAdmin>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_NotProxyAdmin) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_NotProxyAdmin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProxyAdminOwnedBase_NotProxyAdmin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_NotProxyAdmin()";
            const SELECTOR: [u8; 4] = [232u8, 24u8, 220u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner()` and selector `0xc4050a26`.
```solidity
error ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError
        for ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner()";
            const SELECTOR: [u8; 4] = [196u8, 5u8, 10u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_NotProxyAdminOwner()` and selector `0x7f12c64b`.
```solidity
error ProxyAdminOwnedBase_NotProxyAdminOwner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_NotProxyAdminOwner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_NotProxyAdminOwner>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_NotProxyAdminOwner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_NotProxyAdminOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProxyAdminOwnedBase_NotProxyAdminOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_NotProxyAdminOwner()";
            const SELECTOR: [u8; 4] = [127u8, 18u8, 198u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_NotResolvedDelegateProxy()` and selector `0x54e433cd`.
```solidity
error ProxyAdminOwnedBase_NotResolvedDelegateProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_NotResolvedDelegateProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_NotResolvedDelegateProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_NotResolvedDelegateProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_NotResolvedDelegateProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProxyAdminOwnedBase_NotResolvedDelegateProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_NotResolvedDelegateProxy()";
            const SELECTOR: [u8; 4] = [84u8, 228u8, 51u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_NotSharedProxyAdminOwner()` and selector `0x075c4314`.
```solidity
error ProxyAdminOwnedBase_NotSharedProxyAdminOwner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_NotSharedProxyAdminOwner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_NotSharedProxyAdminOwner>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_NotSharedProxyAdminOwner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_NotSharedProxyAdminOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProxyAdminOwnedBase_NotSharedProxyAdminOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_NotSharedProxyAdminOwner()";
            const SELECTOR: [u8; 4] = [7u8, 92u8, 67u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ProxyAdminOwnedBase_ProxyAdminNotFound()` and selector `0x332144db`.
```solidity
error ProxyAdminOwnedBase_ProxyAdminNotFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdminOwnedBase_ProxyAdminNotFound;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdminOwnedBase_ProxyAdminNotFound>
        for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdminOwnedBase_ProxyAdminNotFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ProxyAdminOwnedBase_ProxyAdminNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProxyAdminOwnedBase_ProxyAdminNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProxyAdminOwnedBase_ProxyAdminNotFound()";
            const SELECTOR: [u8; 4] = [51u8, 33u8, 68u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ReinitializableBase_ZeroInitVersion()` and selector `0x9b01afed`.
```solidity
error ReinitializableBase_ZeroInitVersion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReinitializableBase_ZeroInitVersion;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReinitializableBase_ZeroInitVersion>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReinitializableBase_ZeroInitVersion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReinitializableBase_ZeroInitVersion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReinitializableBase_ZeroInitVersion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReinitializableBase_ZeroInitVersion()";
            const SELECTOR: [u8; 4] = [155u8, 1u8, 175u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Event with signature `DisputeGameCreated(address,uint32,bytes32)` and selector `0x5b565efe82411da98814f356d0e7bcb8f0219b8d970307c5afb4a6903a8b2e35`.
```solidity
event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DisputeGameCreated {
        #[allow(missing_docs)]
        pub disputeProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DisputeGameCreated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                GameType,
                Claim,
            );
            const SIGNATURE: &'static str = "DisputeGameCreated(address,uint32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                91u8, 86u8, 94u8, 254u8, 130u8, 65u8, 29u8, 169u8, 136u8, 20u8, 243u8,
                86u8, 208u8, 231u8, 188u8, 184u8, 240u8, 33u8, 155u8, 141u8, 151u8, 3u8,
                7u8, 197u8, 175u8, 180u8, 166u8, 144u8, 58u8, 139u8, 46u8, 53u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    disputeProxy: topics.1,
                    gameType: topics.2,
                    rootClaim: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.disputeProxy.clone(),
                    self.gameType.clone(),
                    self.rootClaim.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.disputeProxy,
                );
                out[2usize] = <GameType as alloy_sol_types::EventTopic>::encode_topic(
                    &self.gameType,
                );
                out[3usize] = <Claim as alloy_sol_types::EventTopic>::encode_topic(
                    &self.rootClaim,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DisputeGameCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DisputeGameCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DisputeGameCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ImplementationArgsSet(uint32,bytes)` and selector `0xa47fcdf075d680d3817bfca7973b373e1a5f6cfc3b444748299cc2b83d8348f9`.
```solidity
event ImplementationArgsSet(GameType indexed gameType, bytes args);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ImplementationArgsSet {
        #[allow(missing_docs)]
        pub gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub args: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ImplementationArgsSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>, GameType);
            const SIGNATURE: &'static str = "ImplementationArgsSet(uint32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8, 127u8, 205u8, 240u8, 117u8, 214u8, 128u8, 211u8, 129u8, 123u8,
                252u8, 167u8, 151u8, 59u8, 55u8, 62u8, 26u8, 95u8, 108u8, 252u8, 59u8,
                68u8, 71u8, 72u8, 41u8, 156u8, 194u8, 184u8, 61u8, 131u8, 72u8, 249u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    gameType: topics.1,
                    args: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.args,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.gameType.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <GameType as alloy_sol_types::EventTopic>::encode_topic(
                    &self.gameType,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ImplementationArgsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ImplementationArgsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ImplementationArgsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ImplementationSet(address,uint32)` and selector `0xff513d80e2c7fa487608f70a618dfbc0cf415699dc69588c747e8c71566c88de`.
```solidity
event ImplementationSet(address indexed r#impl, GameType indexed gameType);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ImplementationSet {
        #[allow(missing_docs)]
        pub r#impl: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gameType: <GameType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ImplementationSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                GameType,
            );
            const SIGNATURE: &'static str = "ImplementationSet(address,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                255u8, 81u8, 61u8, 128u8, 226u8, 199u8, 250u8, 72u8, 118u8, 8u8, 247u8,
                10u8, 97u8, 141u8, 251u8, 192u8, 207u8, 65u8, 86u8, 153u8, 220u8, 105u8,
                88u8, 140u8, 116u8, 126u8, 140u8, 113u8, 86u8, 108u8, 136u8, 222u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    r#impl: topics.1,
                    gameType: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.r#impl.clone(), self.gameType.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.r#impl,
                );
                out[2usize] = <GameType as alloy_sol_types::EventTopic>::encode_topic(
                    &self.gameType,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ImplementationSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ImplementationSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ImplementationSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `InitBondUpdated(uint32,uint256)` and selector `0x74d6665c4b26d5596a5aa13d3014e0c06af4d322075a797f87b03cd4c5bc91ca`.
```solidity
event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InitBondUpdated {
        #[allow(missing_docs)]
        pub gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newBond: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InitBondUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                GameType,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "InitBondUpdated(uint32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                116u8, 214u8, 102u8, 92u8, 75u8, 38u8, 213u8, 89u8, 106u8, 90u8, 161u8,
                61u8, 48u8, 20u8, 224u8, 192u8, 106u8, 244u8, 211u8, 34u8, 7u8, 90u8,
                121u8, 127u8, 135u8, 176u8, 60u8, 212u8, 197u8, 188u8, 145u8, 202u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    gameType: topics.1,
                    newBond: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.gameType.clone(),
                    self.newBond.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <GameType as alloy_sol_types::EventTopic>::encode_topic(
                    &self.gameType,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newBond);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InitBondUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InitBondUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InitBondUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8,
                19u8, 56u8, 82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8,
                146u8, 20u8, 96u8, 206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `create(uint32,bytes32,bytes)` and selector `0x82ecf2f6`.
```solidity
function create(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external payable returns (address proxy_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createCall {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _extraData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`create(uint32,bytes32,bytes)`](createCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createReturn {
        #[allow(missing_docs)]
        pub proxy_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                Claim,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                <Claim as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createCall> for UnderlyingRustTuple<'_> {
                fn from(value: createCall) -> Self {
                    (value._gameType, value._rootClaim, value._extraData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _rootClaim: tuple.1,
                        _extraData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createReturn) -> Self {
                    (value.proxy_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { proxy_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createCall {
            type Parameters<'a> = (GameType, Claim, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "create(uint32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [130u8, 236u8, 242u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self._rootClaim),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._extraData,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: createReturn = r.into();
                        r.proxy_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: createReturn = r.into();
                        r.proxy_
                    })
            }
        }
    };
    /**Function with signature `findLatestGames(uint32,uint256,uint256)` and selector `0x254bd683`.
```solidity
function findLatestGames(GameType _gameType, uint256 _start, uint256 _n) external view returns (GameSearchResult[] memory games_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct findLatestGamesCall {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _start: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _n: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`findLatestGames(uint32,uint256,uint256)`](findLatestGamesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct findLatestGamesReturn {
        #[allow(missing_docs)]
        pub games_: alloy::sol_types::private::Vec<
            <GameSearchResult as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<findLatestGamesCall> for UnderlyingRustTuple<'_> {
                fn from(value: findLatestGamesCall) -> Self {
                    (value._gameType, value._start, value._n)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for findLatestGamesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _start: tuple.1,
                        _n: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<GameSearchResult>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <GameSearchResult as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<findLatestGamesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: findLatestGamesReturn) -> Self {
                    (value.games_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for findLatestGamesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { games_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for findLatestGamesCall {
            type Parameters<'a> = (
                GameType,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <GameSearchResult as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<GameSearchResult>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "findLatestGames(uint32,uint256,uint256)";
            const SELECTOR: [u8; 4] = [37u8, 75u8, 214u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._n),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        GameSearchResult,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: findLatestGamesReturn = r.into();
                        r.games_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: findLatestGamesReturn = r.into();
                        r.games_
                    })
            }
        }
    };
    /**Function with signature `gameArgs(uint32)` and selector `0x74cc86ac`.
```solidity
function gameArgs(GameType) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameArgsCall(pub <GameType as alloy::sol_types::SolType>::RustType);
    ///Container type for the return parameters of the [`gameArgs(uint32)`](gameArgsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameArgsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameArgsCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameArgsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameArgsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameArgsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameArgsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameArgsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameArgsCall {
            type Parameters<'a> = (GameType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameArgs(uint32)";
            const SELECTOR: [u8; 4] = [116u8, 204u8, 134u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<GameType as alloy_sol_types::SolType>::tokenize(&self.0),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameArgsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameArgsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `gameAtIndex(uint256)` and selector `0xbb8aa1fc`.
```solidity
function gameAtIndex(uint256 _index) external view returns (GameType gameType_, Timestamp timestamp_, address proxy_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameAtIndexCall {
        #[allow(missing_docs)]
        pub _index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`gameAtIndex(uint256)`](gameAtIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameAtIndexReturn {
        #[allow(missing_docs)]
        pub gameType_: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub timestamp_: <Timestamp as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub proxy_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameAtIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameAtIndexCall) -> Self {
                    (value._index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameAtIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                Timestamp,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                <Timestamp as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameAtIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameAtIndexReturn) -> Self {
                    (value.gameType_, value.timestamp_, value.proxy_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameAtIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gameType_: tuple.0,
                        timestamp_: tuple.1,
                        proxy_: tuple.2,
                    }
                }
            }
        }
        impl gameAtIndexReturn {
            fn _tokenize(
                &self,
            ) -> <gameAtIndexCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self.gameType_),
                    <Timestamp as alloy_sol_types::SolType>::tokenize(&self.timestamp_),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proxy_,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameAtIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = gameAtIndexReturn;
            type ReturnTuple<'a> = (
                GameType,
                Timestamp,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameAtIndex(uint256)";
            const SELECTOR: [u8; 4] = [187u8, 138u8, 161u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                gameAtIndexReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `gameCount()` and selector `0x4d1975b4`.
```solidity
function gameCount() external view returns (uint256 gameCount_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameCountCall;
    ///Container type for the return parameters of the [`gameCount()`](gameCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameCountReturn {
        #[allow(missing_docs)]
        pub gameCount_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameCountReturn) -> Self {
                    (value.gameCount_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { gameCount_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameCount()";
            const SELECTOR: [u8; 4] = [77u8, 25u8, 117u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameCountReturn = r.into();
                        r.gameCount_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameCountReturn = r.into();
                        r.gameCount_
                    })
            }
        }
    };
    /**Function with signature `gameImpls(uint32)` and selector `0x1b685b9e`.
```solidity
function gameImpls(GameType) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameImplsCall(pub <GameType as alloy::sol_types::SolType>::RustType);
    ///Container type for the return parameters of the [`gameImpls(uint32)`](gameImplsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameImplsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameImplsCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameImplsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameImplsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameImplsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameImplsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameImplsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameImplsCall {
            type Parameters<'a> = (GameType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameImpls(uint32)";
            const SELECTOR: [u8; 4] = [27u8, 104u8, 91u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<GameType as alloy_sol_types::SolType>::tokenize(&self.0),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameImplsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameImplsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `games(uint32,bytes32,bytes)` and selector `0x5f0150cb`.
```solidity
function games(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external view returns (address proxy_, Timestamp timestamp_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gamesCall {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _extraData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`games(uint32,bytes32,bytes)`](gamesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gamesReturn {
        #[allow(missing_docs)]
        pub proxy_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timestamp_: <Timestamp as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                Claim,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                <Claim as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gamesCall> for UnderlyingRustTuple<'_> {
                fn from(value: gamesCall) -> Self {
                    (value._gameType, value._rootClaim, value._extraData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gamesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _rootClaim: tuple.1,
                        _extraData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                Timestamp,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <Timestamp as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gamesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gamesReturn) -> Self {
                    (value.proxy_, value.timestamp_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gamesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy_: tuple.0,
                        timestamp_: tuple.1,
                    }
                }
            }
        }
        impl gamesReturn {
            fn _tokenize(
                &self,
            ) -> <gamesCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proxy_,
                    ),
                    <Timestamp as alloy_sol_types::SolType>::tokenize(&self.timestamp_),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gamesCall {
            type Parameters<'a> = (GameType, Claim, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = gamesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address, Timestamp);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "games(uint32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [95u8, 1u8, 80u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self._rootClaim),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._extraData,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                gamesReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getGameUUID(uint32,bytes32,bytes)` and selector `0x96cd9720`.
```solidity
function getGameUUID(GameType _gameType, Claim _rootClaim, bytes memory _extraData) external pure returns (Hash uuid_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getGameUUIDCall {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _extraData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`getGameUUID(uint32,bytes32,bytes)`](getGameUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getGameUUIDReturn {
        #[allow(missing_docs)]
        pub uuid_: <Hash as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                Claim,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                <Claim as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getGameUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: getGameUUIDCall) -> Self {
                    (value._gameType, value._rootClaim, value._extraData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getGameUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _rootClaim: tuple.1,
                        _extraData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Hash,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Hash as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getGameUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getGameUUIDReturn) -> Self {
                    (value.uuid_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getGameUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { uuid_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getGameUUIDCall {
            type Parameters<'a> = (GameType, Claim, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Hash as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Hash,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getGameUUID(uint32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [150u8, 205u8, 151u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self._rootClaim),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._extraData,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Hash as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getGameUUIDReturn = r.into();
                        r.uuid_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getGameUUIDReturn = r.into();
                        r.uuid_
                    })
            }
        }
    };
    /**Function with signature `initBonds(uint32)` and selector `0x6593dc6e`.
```solidity
function initBonds(GameType) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initBondsCall(pub <GameType as alloy::sol_types::SolType>::RustType);
    ///Container type for the return parameters of the [`initBonds(uint32)`](initBondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initBondsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initBondsCall> for UnderlyingRustTuple<'_> {
                fn from(value: initBondsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initBondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initBondsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initBondsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initBondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initBondsCall {
            type Parameters<'a> = (GameType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initBonds(uint32)";
            const SELECTOR: [u8; 4] = [101u8, 147u8, 220u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<GameType as alloy_sol_types::SolType>::tokenize(&self.0),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: initBondsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: initBondsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `initVersion()` and selector `0x38d38c97`.
```solidity
function initVersion() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initVersionCall;
    ///Container type for the return parameters of the [`initVersion()`](initVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initVersionReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: initVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u8;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initVersion()";
            const SELECTOR: [u8; 4] = [56u8, 211u8, 140u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: initVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: initVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `initialize(address)` and selector `0xc4d66de8`.
```solidity
function initialize(address _owner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub _owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value._owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address)";
            const SELECTOR: [u8; 4] = [196u8, 214u8, 109u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._owner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `proxyAdmin()` and selector `0x3e47158c`.
```solidity
function proxyAdmin() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxyAdminCall;
    ///Container type for the return parameters of the [`proxyAdmin()`](proxyAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxyAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxyAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxyAdminCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxyAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxyAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxyAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxyAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxyAdminCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxyAdmin()";
            const SELECTOR: [u8; 4] = [62u8, 71u8, 21u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxyAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxyAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `proxyAdminOwner()` and selector `0xdad544e0`.
```solidity
function proxyAdminOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxyAdminOwnerCall;
    ///Container type for the return parameters of the [`proxyAdminOwner()`](proxyAdminOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxyAdminOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxyAdminOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxyAdminOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxyAdminOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxyAdminOwnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: proxyAdminOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for proxyAdminOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxyAdminOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxyAdminOwner()";
            const SELECTOR: [u8; 4] = [218u8, 213u8, 68u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxyAdminOwnerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxyAdminOwnerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setImplementation(uint32,address)` and selector `0x14f6b1a3`.
```solidity
function setImplementation(GameType _gameType, address _impl) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setImplementation_0Call {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _impl: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setImplementation(uint32,address)`](setImplementation_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setImplementation_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementation_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementation_0Call) -> Self {
                    (value._gameType, value._impl)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementation_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _impl: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementation_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementation_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementation_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setImplementation_0Return {
            fn _tokenize(
                &self,
            ) -> <setImplementation_0Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setImplementation_0Call {
            type Parameters<'a> = (GameType, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setImplementation_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setImplementation(uint32,address)";
            const SELECTOR: [u8; 4] = [20u8, 246u8, 177u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._impl,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setImplementation_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setImplementation(uint32,address,bytes)` and selector `0xb1070957`.
```solidity
function setImplementation(GameType _gameType, address _impl, bytes memory _args) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setImplementation_1Call {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _impl: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _args: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setImplementation(uint32,address,bytes)`](setImplementation_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setImplementation_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementation_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementation_1Call) -> Self {
                    (value._gameType, value._impl, value._args)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementation_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _impl: tuple.1,
                        _args: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementation_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementation_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementation_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setImplementation_1Return {
            fn _tokenize(
                &self,
            ) -> <setImplementation_1Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setImplementation_1Call {
            type Parameters<'a> = (
                GameType,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setImplementation_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setImplementation(uint32,address,bytes)";
            const SELECTOR: [u8; 4] = [177u8, 7u8, 9u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._impl,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._args,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setImplementation_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setInitBond(uint32,uint256)` and selector `0x1e334240`.
```solidity
function setInitBond(GameType _gameType, uint256 _initBond) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setInitBondCall {
        #[allow(missing_docs)]
        pub _gameType: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _initBond: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setInitBond(uint32,uint256)`](setInitBondCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setInitBondReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setInitBondCall> for UnderlyingRustTuple<'_> {
                fn from(value: setInitBondCall) -> Self {
                    (value._gameType, value._initBond)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setInitBondCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _gameType: tuple.0,
                        _initBond: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setInitBondReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setInitBondReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setInitBondReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setInitBondReturn {
            fn _tokenize(
                &self,
            ) -> <setInitBondCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setInitBondCall {
            type Parameters<'a> = (GameType, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setInitBondReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setInitBond(uint32,uint256)";
            const SELECTOR: [u8; 4] = [30u8, 51u8, 66u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self._gameType),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._initBond),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setInitBondReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `version()` and selector `0x54fd4d50`.
```solidity
function version() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionCall;
    ///Container type for the return parameters of the [`version()`](versionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionCall> for UnderlyingRustTuple<'_> {
                fn from(value: versionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: versionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for versionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "version()";
            const SELECTOR: [u8; 4] = [84u8, 253u8, 77u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`DisputeGameFactory`](self) function calls.
    #[derive(Clone)]
    pub enum DisputeGameFactoryCalls {
        #[allow(missing_docs)]
        create(createCall),
        #[allow(missing_docs)]
        findLatestGames(findLatestGamesCall),
        #[allow(missing_docs)]
        gameArgs(gameArgsCall),
        #[allow(missing_docs)]
        gameAtIndex(gameAtIndexCall),
        #[allow(missing_docs)]
        gameCount(gameCountCall),
        #[allow(missing_docs)]
        gameImpls(gameImplsCall),
        #[allow(missing_docs)]
        games(gamesCall),
        #[allow(missing_docs)]
        getGameUUID(getGameUUIDCall),
        #[allow(missing_docs)]
        initBonds(initBondsCall),
        #[allow(missing_docs)]
        initVersion(initVersionCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        proxyAdmin(proxyAdminCall),
        #[allow(missing_docs)]
        proxyAdminOwner(proxyAdminOwnerCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        setImplementation_0(setImplementation_0Call),
        #[allow(missing_docs)]
        setImplementation_1(setImplementation_1Call),
        #[allow(missing_docs)]
        setInitBond(setInitBondCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        version(versionCall),
    }
    impl DisputeGameFactoryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [20u8, 246u8, 177u8, 163u8],
            [27u8, 104u8, 91u8, 158u8],
            [30u8, 51u8, 66u8, 64u8],
            [37u8, 75u8, 214u8, 131u8],
            [56u8, 211u8, 140u8, 151u8],
            [62u8, 71u8, 21u8, 140u8],
            [77u8, 25u8, 117u8, 180u8],
            [84u8, 253u8, 77u8, 80u8],
            [95u8, 1u8, 80u8, 203u8],
            [101u8, 147u8, 220u8, 110u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 204u8, 134u8, 172u8],
            [130u8, 236u8, 242u8, 246u8],
            [141u8, 165u8, 203u8, 91u8],
            [150u8, 205u8, 151u8, 32u8],
            [177u8, 7u8, 9u8, 87u8],
            [187u8, 138u8, 161u8, 252u8],
            [196u8, 214u8, 109u8, 232u8],
            [218u8, 213u8, 68u8, 224u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(setImplementation_0),
            ::core::stringify!(gameImpls),
            ::core::stringify!(setInitBond),
            ::core::stringify!(findLatestGames),
            ::core::stringify!(initVersion),
            ::core::stringify!(proxyAdmin),
            ::core::stringify!(gameCount),
            ::core::stringify!(version),
            ::core::stringify!(games),
            ::core::stringify!(initBonds),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(gameArgs),
            ::core::stringify!(create),
            ::core::stringify!(owner),
            ::core::stringify!(getGameUUID),
            ::core::stringify!(setImplementation_1),
            ::core::stringify!(gameAtIndex),
            ::core::stringify!(initialize),
            ::core::stringify!(proxyAdminOwner),
            ::core::stringify!(transferOwnership),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <setImplementation_0Call as alloy_sol_types::SolCall>::SIGNATURE,
            <gameImplsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setInitBondCall as alloy_sol_types::SolCall>::SIGNATURE,
            <findLatestGamesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <initVersionCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proxyAdminCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <versionCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gamesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <initBondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameArgsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getGameUUIDCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setImplementation_1Call as alloy_sol_types::SolCall>::SIGNATURE,
            <gameAtIndexCall as alloy_sol_types::SolCall>::SIGNATURE,
            <initializeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proxyAdminOwnerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for DisputeGameFactoryCalls {
        const NAME: &'static str = "DisputeGameFactoryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::create(_) => <createCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::findLatestGames(_) => {
                    <findLatestGamesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gameArgs(_) => <gameArgsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::gameAtIndex(_) => {
                    <gameAtIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gameCount(_) => {
                    <gameCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gameImpls(_) => {
                    <gameImplsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::games(_) => <gamesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getGameUUID(_) => {
                    <getGameUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initBonds(_) => {
                    <initBondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initVersion(_) => {
                    <initVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proxyAdmin(_) => {
                    <proxyAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxyAdminOwner(_) => {
                    <proxyAdminOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setImplementation_0(_) => {
                    <setImplementation_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setImplementation_1(_) => {
                    <setImplementation_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setInitBond(_) => {
                    <setInitBondCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::version(_) => <versionCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<DisputeGameFactoryCalls>] = &[
                {
                    fn setImplementation_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setImplementation_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setImplementation_0)
                    }
                    setImplementation_0
                },
                {
                    fn gameImpls(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameImplsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::gameImpls)
                    }
                    gameImpls
                },
                {
                    fn setInitBond(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setInitBondCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setInitBond)
                    }
                    setInitBond
                },
                {
                    fn findLatestGames(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <findLatestGamesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::findLatestGames)
                    }
                    findLatestGames
                },
                {
                    fn initVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::initVersion)
                    }
                    initVersion
                },
                {
                    fn proxyAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <proxyAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::proxyAdmin)
                    }
                    proxyAdmin
                },
                {
                    fn gameCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameCountCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::gameCount)
                    }
                    gameCount
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::version)
                    }
                    version
                },
                {
                    fn games(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gamesCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::games)
                    }
                    games
                },
                {
                    fn initBonds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initBondsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::initBonds)
                    }
                    initBonds
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn gameArgs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameArgsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::gameArgs)
                    }
                    gameArgs
                },
                {
                    fn create(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <createCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::create)
                    }
                    create
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(DisputeGameFactoryCalls::owner)
                    }
                    owner
                },
                {
                    fn getGameUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <getGameUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::getGameUUID)
                    }
                    getGameUUID
                },
                {
                    fn setImplementation_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setImplementation_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setImplementation_1)
                    }
                    setImplementation_1
                },
                {
                    fn gameAtIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameAtIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::gameAtIndex)
                    }
                    gameAtIndex
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::initialize)
                    }
                    initialize
                },
                {
                    fn proxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <proxyAdminOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::proxyAdminOwner)
                    }
                    proxyAdminOwner
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<DisputeGameFactoryCalls>] = &[
                {
                    fn setImplementation_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setImplementation_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setImplementation_0)
                    }
                    setImplementation_0
                },
                {
                    fn gameImpls(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameImplsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::gameImpls)
                    }
                    gameImpls
                },
                {
                    fn setInitBond(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setInitBondCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setInitBond)
                    }
                    setInitBond
                },
                {
                    fn findLatestGames(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <findLatestGamesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::findLatestGames)
                    }
                    findLatestGames
                },
                {
                    fn initVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::initVersion)
                    }
                    initVersion
                },
                {
                    fn proxyAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <proxyAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::proxyAdmin)
                    }
                    proxyAdmin
                },
                {
                    fn gameCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::gameCount)
                    }
                    gameCount
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::version)
                    }
                    version
                },
                {
                    fn games(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gamesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::games)
                    }
                    games
                },
                {
                    fn initBonds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initBondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::initBonds)
                    }
                    initBonds
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn gameArgs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameArgsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::gameArgs)
                    }
                    gameArgs
                },
                {
                    fn create(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <createCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::create)
                    }
                    create
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::owner)
                    }
                    owner
                },
                {
                    fn getGameUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <getGameUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::getGameUUID)
                    }
                    getGameUUID
                },
                {
                    fn setImplementation_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <setImplementation_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::setImplementation_1)
                    }
                    setImplementation_1
                },
                {
                    fn gameAtIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <gameAtIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::gameAtIndex)
                    }
                    gameAtIndex
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::initialize)
                    }
                    initialize
                },
                {
                    fn proxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <proxyAdminOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::proxyAdminOwner)
                    }
                    proxyAdminOwner
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::create(inner) => {
                    <createCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::findLatestGames(inner) => {
                    <findLatestGamesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gameArgs(inner) => {
                    <gameArgsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gameAtIndex(inner) => {
                    <gameAtIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gameCount(inner) => {
                    <gameCountCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gameImpls(inner) => {
                    <gameImplsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::games(inner) => {
                    <gamesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getGameUUID(inner) => {
                    <getGameUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initBonds(inner) => {
                    <initBondsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initVersion(inner) => {
                    <initVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proxyAdmin(inner) => {
                    <proxyAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proxyAdminOwner(inner) => {
                    <proxyAdminOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setImplementation_0(inner) => {
                    <setImplementation_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setImplementation_1(inner) => {
                    <setImplementation_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setInitBond(inner) => {
                    <setInitBondCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::create(inner) => {
                    <createCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::findLatestGames(inner) => {
                    <findLatestGamesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameArgs(inner) => {
                    <gameArgsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameAtIndex(inner) => {
                    <gameAtIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameCount(inner) => {
                    <gameCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameImpls(inner) => {
                    <gameImplsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::games(inner) => {
                    <gamesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getGameUUID(inner) => {
                    <getGameUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initBonds(inner) => {
                    <initBondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initVersion(inner) => {
                    <initVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proxyAdmin(inner) => {
                    <proxyAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxyAdminOwner(inner) => {
                    <proxyAdminOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setImplementation_0(inner) => {
                    <setImplementation_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setImplementation_1(inner) => {
                    <setImplementation_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setInitBond(inner) => {
                    <setInitBondCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`DisputeGameFactory`](self) custom errors.
    #[derive(Clone)]
    pub enum DisputeGameFactoryErrors {
        #[allow(missing_docs)]
        GameAlreadyExists(GameAlreadyExists),
        #[allow(missing_docs)]
        IncorrectBondAmount(IncorrectBondAmount),
        #[allow(missing_docs)]
        NoImplementation(NoImplementation),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_NotProxyAdmin(ProxyAdminOwnedBase_NotProxyAdmin),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(
            ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner,
        ),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_NotProxyAdminOwner(ProxyAdminOwnedBase_NotProxyAdminOwner),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_NotResolvedDelegateProxy(
            ProxyAdminOwnedBase_NotResolvedDelegateProxy,
        ),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_NotSharedProxyAdminOwner(
            ProxyAdminOwnedBase_NotSharedProxyAdminOwner,
        ),
        #[allow(missing_docs)]
        ProxyAdminOwnedBase_ProxyAdminNotFound(ProxyAdminOwnedBase_ProxyAdminNotFound),
        #[allow(missing_docs)]
        ReinitializableBase_ZeroInitVersion(ReinitializableBase_ZeroInitVersion),
    }
    impl DisputeGameFactoryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 79u8, 111u8, 229u8],
            [3u8, 28u8, 109u8, 228u8],
            [7u8, 92u8, 67u8, 20u8],
            [51u8, 33u8, 68u8, 219u8],
            [84u8, 228u8, 51u8, 205u8],
            [127u8, 18u8, 198u8, 75u8],
            [134u8, 32u8, 170u8, 25u8],
            [155u8, 1u8, 175u8, 237u8],
            [196u8, 5u8, 10u8, 38u8],
            [232u8, 24u8, 220u8, 195u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(GameAlreadyExists),
            ::core::stringify!(NoImplementation),
            ::core::stringify!(ProxyAdminOwnedBase_NotSharedProxyAdminOwner),
            ::core::stringify!(ProxyAdminOwnedBase_ProxyAdminNotFound),
            ::core::stringify!(ProxyAdminOwnedBase_NotResolvedDelegateProxy),
            ::core::stringify!(ProxyAdminOwnedBase_NotProxyAdminOwner),
            ::core::stringify!(IncorrectBondAmount),
            ::core::stringify!(ReinitializableBase_ZeroInitVersion),
            ::core::stringify!(ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner),
            ::core::stringify!(ProxyAdminOwnedBase_NotProxyAdmin),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <GameAlreadyExists as alloy_sol_types::SolError>::SIGNATURE,
            <NoImplementation as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::SIGNATURE,
            <IncorrectBondAmount as alloy_sol_types::SolError>::SIGNATURE,
            <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::SIGNATURE,
            <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for DisputeGameFactoryErrors {
        const NAME: &'static str = "DisputeGameFactoryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::GameAlreadyExists(_) => {
                    <GameAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncorrectBondAmount(_) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoImplementation(_) => {
                    <NoImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_NotProxyAdmin(_) => {
                    <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(_) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOwner(_) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_NotResolvedDelegateProxy(_) => {
                    <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_NotSharedProxyAdminOwner(_) => {
                    <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProxyAdminOwnedBase_ProxyAdminNotFound(_) => {
                    <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReinitializableBase_ZeroInitVersion(_) => {
                    <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<DisputeGameFactoryErrors>] = &[
                {
                    fn GameAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <GameAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::GameAlreadyExists)
                    }
                    GameAlreadyExists
                },
                {
                    fn NoImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <NoImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::NoImplementation)
                    }
                    NoImplementation
                },
                {
                    fn ProxyAdminOwnedBase_NotSharedProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotSharedProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotSharedProxyAdminOwner
                },
                {
                    fn ProxyAdminOwnedBase_ProxyAdminNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_ProxyAdminNotFound,
                            )
                    }
                    ProxyAdminOwnedBase_ProxyAdminNotFound
                },
                {
                    fn ProxyAdminOwnedBase_NotResolvedDelegateProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotResolvedDelegateProxy,
                            )
                    }
                    ProxyAdminOwnedBase_NotResolvedDelegateProxy
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdminOwner
                },
                {
                    fn IncorrectBondAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <IncorrectBondAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::IncorrectBondAmount)
                    }
                    IncorrectBondAmount
                },
                {
                    fn ReinitializableBase_ZeroInitVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ReinitializableBase_ZeroInitVersion,
                            )
                    }
                    ReinitializableBase_ZeroInitVersion
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdmin,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdmin
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<DisputeGameFactoryErrors>] = &[
                {
                    fn GameAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <GameAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::GameAlreadyExists)
                    }
                    GameAlreadyExists
                },
                {
                    fn NoImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <NoImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::NoImplementation)
                    }
                    NoImplementation
                },
                {
                    fn ProxyAdminOwnedBase_NotSharedProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotSharedProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotSharedProxyAdminOwner
                },
                {
                    fn ProxyAdminOwnedBase_ProxyAdminNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_ProxyAdminNotFound,
                            )
                    }
                    ProxyAdminOwnedBase_ProxyAdminNotFound
                },
                {
                    fn ProxyAdminOwnedBase_NotResolvedDelegateProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotResolvedDelegateProxy,
                            )
                    }
                    ProxyAdminOwnedBase_NotResolvedDelegateProxy
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdminOwner
                },
                {
                    fn IncorrectBondAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <IncorrectBondAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(DisputeGameFactoryErrors::IncorrectBondAmount)
                    }
                    IncorrectBondAmount
                },
                {
                    fn ReinitializableBase_ZeroInitVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ReinitializableBase_ZeroInitVersion,
                            )
                    }
                    ReinitializableBase_ZeroInitVersion
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner
                },
                {
                    fn ProxyAdminOwnedBase_NotProxyAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<DisputeGameFactoryErrors> {
                        <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                DisputeGameFactoryErrors::ProxyAdminOwnedBase_NotProxyAdmin,
                            )
                    }
                    ProxyAdminOwnedBase_NotProxyAdmin
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::GameAlreadyExists(inner) => {
                    <GameAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IncorrectBondAmount(inner) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoImplementation(inner) => {
                    <NoImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdmin(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_NotResolvedDelegateProxy(inner) => {
                    <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_NotSharedProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ProxyAdminOwnedBase_ProxyAdminNotFound(inner) => {
                    <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReinitializableBase_ZeroInitVersion(inner) => {
                    <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::GameAlreadyExists(inner) => {
                    <GameAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IncorrectBondAmount(inner) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoImplementation(inner) => {
                    <NoImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdmin(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdmin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_NotProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotProxyAdminOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_NotResolvedDelegateProxy(inner) => {
                    <ProxyAdminOwnedBase_NotResolvedDelegateProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_NotSharedProxyAdminOwner(inner) => {
                    <ProxyAdminOwnedBase_NotSharedProxyAdminOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ProxyAdminOwnedBase_ProxyAdminNotFound(inner) => {
                    <ProxyAdminOwnedBase_ProxyAdminNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReinitializableBase_ZeroInitVersion(inner) => {
                    <ReinitializableBase_ZeroInitVersion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`DisputeGameFactory`](self) events.
    #[derive(Clone)]
    pub enum DisputeGameFactoryEvents {
        #[allow(missing_docs)]
        DisputeGameCreated(DisputeGameCreated),
        #[allow(missing_docs)]
        ImplementationArgsSet(ImplementationArgsSet),
        #[allow(missing_docs)]
        ImplementationSet(ImplementationSet),
        #[allow(missing_docs)]
        InitBondUpdated(InitBondUpdated),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
    }
    impl DisputeGameFactoryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                91u8, 86u8, 94u8, 254u8, 130u8, 65u8, 29u8, 169u8, 136u8, 20u8, 243u8,
                86u8, 208u8, 231u8, 188u8, 184u8, 240u8, 33u8, 155u8, 141u8, 151u8, 3u8,
                7u8, 197u8, 175u8, 180u8, 166u8, 144u8, 58u8, 139u8, 46u8, 53u8,
            ],
            [
                116u8, 214u8, 102u8, 92u8, 75u8, 38u8, 213u8, 89u8, 106u8, 90u8, 161u8,
                61u8, 48u8, 20u8, 224u8, 192u8, 106u8, 244u8, 211u8, 34u8, 7u8, 90u8,
                121u8, 127u8, 135u8, 176u8, 60u8, 212u8, 197u8, 188u8, 145u8, 202u8,
            ],
            [
                127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8,
                19u8, 56u8, 82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8,
                146u8, 20u8, 96u8, 206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                164u8, 127u8, 205u8, 240u8, 117u8, 214u8, 128u8, 211u8, 129u8, 123u8,
                252u8, 167u8, 151u8, 59u8, 55u8, 62u8, 26u8, 95u8, 108u8, 252u8, 59u8,
                68u8, 71u8, 72u8, 41u8, 156u8, 194u8, 184u8, 61u8, 131u8, 72u8, 249u8,
            ],
            [
                255u8, 81u8, 61u8, 128u8, 226u8, 199u8, 250u8, 72u8, 118u8, 8u8, 247u8,
                10u8, 97u8, 141u8, 251u8, 192u8, 207u8, 65u8, 86u8, 153u8, 220u8, 105u8,
                88u8, 140u8, 116u8, 126u8, 140u8, 113u8, 86u8, 108u8, 136u8, 222u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(DisputeGameCreated),
            ::core::stringify!(InitBondUpdated),
            ::core::stringify!(Initialized),
            ::core::stringify!(OwnershipTransferred),
            ::core::stringify!(ImplementationArgsSet),
            ::core::stringify!(ImplementationSet),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <DisputeGameCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <InitBondUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <Initialized as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
            <ImplementationArgsSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ImplementationSet as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for DisputeGameFactoryEvents {
        const NAME: &'static str = "DisputeGameFactoryEvents";
        const COUNT: usize = 6usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <DisputeGameCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DisputeGameCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DisputeGameCreated)
                }
                Some(
                    <ImplementationArgsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ImplementationArgsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ImplementationArgsSet)
                }
                Some(
                    <ImplementationSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ImplementationSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ImplementationSet)
                }
                Some(<InitBondUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <InitBondUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::InitBondUpdated)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for DisputeGameFactoryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DisputeGameCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ImplementationArgsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ImplementationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InitBondUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DisputeGameCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ImplementationArgsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ImplementationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InitBondUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`DisputeGameFactory`](self) contract instance.

See the [wrapper's documentation](`DisputeGameFactoryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> DisputeGameFactoryInstance<P, N> {
        DisputeGameFactoryInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<DisputeGameFactoryInstance<P, N>>,
    > {
        DisputeGameFactoryInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        DisputeGameFactoryInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`DisputeGameFactory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`DisputeGameFactory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct DisputeGameFactoryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for DisputeGameFactoryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("DisputeGameFactoryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > DisputeGameFactoryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`DisputeGameFactory`](self) contract instance.

See the [wrapper's documentation](`DisputeGameFactoryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<DisputeGameFactoryInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> DisputeGameFactoryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> DisputeGameFactoryInstance<P, N> {
            DisputeGameFactoryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > DisputeGameFactoryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`create`] function.
        pub fn create(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
            _extraData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, createCall, N> {
            self.call_builder(
                &createCall {
                    _gameType,
                    _rootClaim,
                    _extraData,
                },
            )
        }
        ///Creates a new call builder for the [`findLatestGames`] function.
        pub fn findLatestGames(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _start: alloy::sol_types::private::primitives::aliases::U256,
            _n: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, findLatestGamesCall, N> {
            self.call_builder(
                &findLatestGamesCall {
                    _gameType,
                    _start,
                    _n,
                },
            )
        }
        ///Creates a new call builder for the [`gameArgs`] function.
        pub fn gameArgs(
            &self,
            _0: <GameType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, gameArgsCall, N> {
            self.call_builder(&gameArgsCall(_0))
        }
        ///Creates a new call builder for the [`gameAtIndex`] function.
        pub fn gameAtIndex(
            &self,
            _index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, gameAtIndexCall, N> {
            self.call_builder(&gameAtIndexCall { _index })
        }
        ///Creates a new call builder for the [`gameCount`] function.
        pub fn gameCount(&self) -> alloy_contract::SolCallBuilder<&P, gameCountCall, N> {
            self.call_builder(&gameCountCall)
        }
        ///Creates a new call builder for the [`gameImpls`] function.
        pub fn gameImpls(
            &self,
            _0: <GameType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, gameImplsCall, N> {
            self.call_builder(&gameImplsCall(_0))
        }
        ///Creates a new call builder for the [`games`] function.
        pub fn games(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
            _extraData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, gamesCall, N> {
            self.call_builder(
                &gamesCall {
                    _gameType,
                    _rootClaim,
                    _extraData,
                },
            )
        }
        ///Creates a new call builder for the [`getGameUUID`] function.
        pub fn getGameUUID(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
            _extraData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, getGameUUIDCall, N> {
            self.call_builder(
                &getGameUUIDCall {
                    _gameType,
                    _rootClaim,
                    _extraData,
                },
            )
        }
        ///Creates a new call builder for the [`initBonds`] function.
        pub fn initBonds(
            &self,
            _0: <GameType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, initBondsCall, N> {
            self.call_builder(&initBondsCall(_0))
        }
        ///Creates a new call builder for the [`initVersion`] function.
        pub fn initVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initVersionCall, N> {
            self.call_builder(&initVersionCall)
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(&initializeCall { _owner })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`proxyAdmin`] function.
        pub fn proxyAdmin(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxyAdminCall, N> {
            self.call_builder(&proxyAdminCall)
        }
        ///Creates a new call builder for the [`proxyAdminOwner`] function.
        pub fn proxyAdminOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxyAdminOwnerCall, N> {
            self.call_builder(&proxyAdminOwnerCall)
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`setImplementation_0`] function.
        pub fn setImplementation_0(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _impl: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setImplementation_0Call, N> {
            self.call_builder(
                &setImplementation_0Call {
                    _gameType,
                    _impl,
                },
            )
        }
        ///Creates a new call builder for the [`setImplementation_1`] function.
        pub fn setImplementation_1(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _impl: alloy::sol_types::private::Address,
            _args: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, setImplementation_1Call, N> {
            self.call_builder(
                &setImplementation_1Call {
                    _gameType,
                    _impl,
                    _args,
                },
            )
        }
        ///Creates a new call builder for the [`setInitBond`] function.
        pub fn setInitBond(
            &self,
            _gameType: <GameType as alloy::sol_types::SolType>::RustType,
            _initBond: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setInitBondCall, N> {
            self.call_builder(
                &setInitBondCall {
                    _gameType,
                    _initBond,
                },
            )
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`version`] function.
        pub fn version(&self) -> alloy_contract::SolCallBuilder<&P, versionCall, N> {
            self.call_builder(&versionCall)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > DisputeGameFactoryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`DisputeGameCreated`] event.
        pub fn DisputeGameCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, DisputeGameCreated, N> {
            self.event_filter::<DisputeGameCreated>()
        }
        ///Creates a new event filter for the [`ImplementationArgsSet`] event.
        pub fn ImplementationArgsSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ImplementationArgsSet, N> {
            self.event_filter::<ImplementationArgsSet>()
        }
        ///Creates a new event filter for the [`ImplementationSet`] event.
        pub fn ImplementationSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ImplementationSet, N> {
            self.event_filter::<ImplementationSet>()
        }
        ///Creates a new event filter for the [`InitBondUpdated`] event.
        pub fn InitBondUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, InitBondUpdated, N> {
            self.event_filter::<InitBondUpdated>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
    }
}
