/**

Generated by the following Solidity interface...
```solidity
interface AccessManager {
    event ChallengerPermissionUpdated(address indexed challenger, bool allowed);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event ProposerPermissionUpdated(address indexed proposer, bool allowed);

    constructor(uint256 _fallbackTimeout, address _disputeGameFactory);

    function DEPLOYMENT_TIMESTAMP() external view returns (uint256);
    function DISPUTE_GAME_FACTORY() external view returns (address);
    function FALLBACK_TIMEOUT() external view returns (uint256);
    function challengers(address) external view returns (bool);
    function getLastProposalTimestamp() external view returns (uint256);
    function isAllowedChallenger(address _challenger) external view returns (bool allowed_);
    function isAllowedProposer(address _proposer) external view returns (bool allowed_);
    function isProposalPermissionlessMode() external view returns (bool);
    function owner() external view returns (address);
    function proposers(address) external view returns (bool);
    function renounceOwnership() external;
    function setChallenger(address _challenger, bool _allowed) external;
    function setProposer(address _proposer, bool _allowed) external;
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_fallbackTimeout",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_disputeGameFactory",
        "type": "address",
        "internalType": "contract IDisputeGameFactory"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEPLOYMENT_TIMESTAMP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DISPUTE_GAME_FACTORY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IDisputeGameFactory"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "FALLBACK_TIMEOUT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengers",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastProposalTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAllowedChallenger",
    "inputs": [
      {
        "name": "_challenger",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "allowed_",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAllowedProposer",
    "inputs": [
      {
        "name": "_proposer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "allowed_",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isProposalPermissionlessMode",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proposers",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallenger",
    "inputs": [
      {
        "name": "_challenger",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_allowed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProposer",
    "inputs": [
      {
        "name": "_proposer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_allowed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengerPermissionUpdated",
    "inputs": [
      {
        "name": "challenger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProposerPermissionUpdated",
    "inputs": [
      {
        "name": "proposer",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod AccessManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60e06040523480156200001157600080fd5b506040516200130638038062001306833981810160405281019062000037919062000228565b620000576200004b620000a360201b60201c565b620000ab60201b60201c565b81608081815250508073ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250504260c0818152505050506200026f565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600080fd5b6000819050919050565b620001898162000174565b81146200019557600080fd5b50565b600081519050620001a9816200017e565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620001dc82620001af565b9050919050565b6000620001f082620001cf565b9050919050565b6200020281620001e3565b81146200020e57600080fd5b50565b6000815190506200022281620001f7565b92915050565b600080604083850312156200024257620002416200016f565b5b6000620002528582860162000198565b9250506020620002658582860162000211565b9150509250929050565b60805160a05160c051611036620002d0600039600081816104c0015281816105c6015281816105ee0152818161067801526108f40152600081816103fa01528181610427015261050601526000818161032c015261079c01526110366000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c806392b5d1901161008c578063e9ed9b6411610066578063e9ed9b641461023b578063f2fde38b14610257578063fbc6def714610273578063ff59ae7d14610291576100ea565b806392b5d190146101d1578063cfea71c0146101ed578063d33b35051461021d576100ea565b8063715018a6116100c8578063715018a61461016d57806382ff53a1146101775780638620689d146101955780638da5cb5b146101b3576100ea565b80630c8b0fdf146100ef578063181774971461010d5780631d3225e31461013d575b600080fd5b6100f76102c1565b6040516101049190610b39565b60405180910390f35b61012760048036038101906101229190610bb7565b61035f565b6040516101349190610b39565b60405180910390f35b61015760048036038101906101529190610bb7565b61037f565b6040516101649190610b39565b60405180910390f35b6101756103e4565b005b61017f6103f8565b60405161018c9190610c43565b60405180910390f35b61019d61041c565b6040516101aa9190610c77565b60405180910390f35b6101bb6106a0565b6040516101c89190610ca1565b60405180910390f35b6101eb60048036038101906101e69190610ce8565b6106c9565b005b61020760048036038101906102029190610bb7565b61077a565b6040516102149190610b39565b60405180910390f35b61022561079a565b6040516102329190610c77565b60405180910390f35b61025560048036038101906102509190610ce8565b6107be565b005b610271600480360381019061026c9190610bb7565b61086f565b005b61027b6108f2565b6040516102889190610c77565b60405180910390f35b6102ab60048036038101906102a69190610bb7565b610916565b6040516102b89190610b39565b60405180910390f35b6000600160008073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561031e576001905061035c565b600061032861041c565b90507f000000000000000000000000000000000000000000000000000000000000000081426103579190610d57565b119150505b90565b60016020528060005260406000206000915054906101000a900460ff1681565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16806103dd57506103dc6102c1565b5b9050919050565b6103ec6109c0565b6103f66000610a3e565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b600080602a905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634d1975b46040518163ffffffff1660e01b8152600401602060405180830381865afa158015610490573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b49190610db7565b9050600081036104e8577f00000000000000000000000000000000000000000000000000000000000000009250505061069d565b60006001826104f79190610d57565b90505b600115610676576000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc846040518263ffffffff1660e01b815260040161055d9190610c77565b606060405180830381865afa15801561057a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059e9190610e9e565b509150915060006105b88267ffffffffffffffff16610b02565b67ffffffffffffffff1690507f000000000000000000000000000000000000000000000000000000000000000081101561061a577f0000000000000000000000000000000000000000000000000000000000000000965050505050505061069d565b6106298663ffffffff16610b0c565b63ffffffff1661063e8463ffffffff16610b0c565b63ffffffff16036106575780965050505050505061069d565b6000840361066757505050610676565b836001900393505050506104fa565b7f000000000000000000000000000000000000000000000000000000000000000093505050505b90565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6106d16109c0565b80600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f761bede702fa6507fd979a5c4213a8d5d38b47ae9f7736506eafe9149c6c6b778260405161076e9190610b39565b60405180910390a25050565b60026020528060005260406000206000915054906101000a900460ff1681565b7f000000000000000000000000000000000000000000000000000000000000000081565b6107c66109c0565b80600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f205b4586f0aad63e3849b0c69893bd6139aca673e7f16088c504691c6502cee4826040516108639190610b39565b60405180910390a25050565b6108776109c0565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036108e6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108dd90610f74565b60405180910390fd5b6108ef81610a3e565b50565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000600260008073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16806109b95750600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b9050919050565b6109c8610b16565b73ffffffffffffffffffffffffffffffffffffffff166109e66106a0565b73ffffffffffffffffffffffffffffffffffffffff1614610a3c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3390610fe0565b60405180910390fd5b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000819050919050565b6000819050919050565b600033905090565b60008115159050919050565b610b3381610b1e565b82525050565b6000602082019050610b4e6000830184610b2a565b92915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610b8482610b59565b9050919050565b610b9481610b79565b8114610b9f57600080fd5b50565b600081359050610bb181610b8b565b92915050565b600060208284031215610bcd57610bcc610b54565b5b6000610bdb84828501610ba2565b91505092915050565b6000819050919050565b6000610c09610c04610bff84610b59565b610be4565b610b59565b9050919050565b6000610c1b82610bee565b9050919050565b6000610c2d82610c10565b9050919050565b610c3d81610c22565b82525050565b6000602082019050610c586000830184610c34565b92915050565b6000819050919050565b610c7181610c5e565b82525050565b6000602082019050610c8c6000830184610c68565b92915050565b610c9b81610b79565b82525050565b6000602082019050610cb66000830184610c92565b92915050565b610cc581610b1e565b8114610cd057600080fd5b50565b600081359050610ce281610cbc565b92915050565b60008060408385031215610cff57610cfe610b54565b5b6000610d0d85828601610ba2565b9250506020610d1e85828601610cd3565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610d6282610c5e565b9150610d6d83610c5e565b925082821015610d8057610d7f610d28565b5b828203905092915050565b610d9481610c5e565b8114610d9f57600080fd5b50565b600081519050610db181610d8b565b92915050565b600060208284031215610dcd57610dcc610b54565b5b6000610ddb84828501610da2565b91505092915050565b600063ffffffff82169050919050565b610dfd81610de4565b8114610e0857600080fd5b50565b600081519050610e1a81610df4565b92915050565b600067ffffffffffffffff82169050919050565b610e3d81610e20565b8114610e4857600080fd5b50565b600081519050610e5a81610e34565b92915050565b6000610e6b82610b79565b9050919050565b610e7b81610e60565b8114610e8657600080fd5b50565b600081519050610e9881610e72565b92915050565b600080600060608486031215610eb757610eb6610b54565b5b6000610ec586828701610e0b565b9350506020610ed686828701610e4b565b9250506040610ee786828701610e89565b9150509250925092565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610f5e602683610ef1565b9150610f6982610f02565b604082019050919050565b60006020820190508181036000830152610f8d81610f51565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610fca602083610ef1565b9150610fd582610f94565b602082019050919050565b60006020820190508181036000830152610ff981610fbd565b905091905056fea2646970667358221220fdeec4a6c3e4ff2c581b2544217a113008375feeb4f22ab7d1f06056bf172c1e64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xE0`@R4\x80\x15b\0\0\x11W`\0\x80\xFD[P`@Qb\0\x13\x068\x03\x80b\0\x13\x06\x839\x81\x81\x01`@R\x81\x01\x90b\0\x007\x91\x90b\0\x02(V[b\0\0Wb\0\0Kb\0\0\xA3` \x1B` \x1CV[b\0\0\xAB` \x1B` \x1CV[\x81`\x80\x81\x81RPP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xA0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPB`\xC0\x81\x81RPPPPb\0\x02oV[`\x003\x90P\x90V[`\0\x80`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81`\0\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\0\x80\xFD[`\0\x81\x90P\x91\x90PV[b\0\x01\x89\x81b\0\x01tV[\x81\x14b\0\x01\x95W`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x01\xA9\x81b\0\x01~V[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0b\0\x01\xDC\x82b\0\x01\xAFV[\x90P\x91\x90PV[`\0b\0\x01\xF0\x82b\0\x01\xCFV[\x90P\x91\x90PV[b\0\x02\x02\x81b\0\x01\xE3V[\x81\x14b\0\x02\x0EW`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x02\"\x81b\0\x01\xF7V[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15b\0\x02BWb\0\x02Ab\0\x01oV[[`\0b\0\x02R\x85\x82\x86\x01b\0\x01\x98V[\x92PP` b\0\x02e\x85\x82\x86\x01b\0\x02\x11V[\x91PP\x92P\x92\x90PV[`\x80Q`\xA0Q`\xC0Qa\x106b\0\x02\xD0`\09`\0\x81\x81a\x04\xC0\x01R\x81\x81a\x05\xC6\x01R\x81\x81a\x05\xEE\x01R\x81\x81a\x06x\x01Ra\x08\xF4\x01R`\0\x81\x81a\x03\xFA\x01R\x81\x81a\x04'\x01Ra\x05\x06\x01R`\0\x81\x81a\x03,\x01Ra\x07\x9C\x01Ra\x106`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xEAW`\x005`\xE0\x1C\x80c\x92\xB5\xD1\x90\x11a\0\x8CW\x80c\xE9\xED\x9Bd\x11a\0fW\x80c\xE9\xED\x9Bd\x14a\x02;W\x80c\xF2\xFD\xE3\x8B\x14a\x02WW\x80c\xFB\xC6\xDE\xF7\x14a\x02sW\x80c\xFFY\xAE}\x14a\x02\x91Wa\0\xEAV[\x80c\x92\xB5\xD1\x90\x14a\x01\xD1W\x80c\xCF\xEAq\xC0\x14a\x01\xEDW\x80c\xD3;5\x05\x14a\x02\x1DWa\0\xEAV[\x80cqP\x18\xA6\x11a\0\xC8W\x80cqP\x18\xA6\x14a\x01mW\x80c\x82\xFFS\xA1\x14a\x01wW\x80c\x86 h\x9D\x14a\x01\x95W\x80c\x8D\xA5\xCB[\x14a\x01\xB3Wa\0\xEAV[\x80c\x0C\x8B\x0F\xDF\x14a\0\xEFW\x80c\x18\x17t\x97\x14a\x01\rW\x80c\x1D2%\xE3\x14a\x01=W[`\0\x80\xFD[a\0\xF7a\x02\xC1V[`@Qa\x01\x04\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01'`\x04\x806\x03\x81\x01\x90a\x01\"\x91\x90a\x0B\xB7V[a\x03_V[`@Qa\x014\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01W`\x04\x806\x03\x81\x01\x90a\x01R\x91\x90a\x0B\xB7V[a\x03\x7FV[`@Qa\x01d\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01ua\x03\xE4V[\0[a\x01\x7Fa\x03\xF8V[`@Qa\x01\x8C\x91\x90a\x0CCV[`@Q\x80\x91\x03\x90\xF3[a\x01\x9Da\x04\x1CV[`@Qa\x01\xAA\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x01\xBBa\x06\xA0V[`@Qa\x01\xC8\x91\x90a\x0C\xA1V[`@Q\x80\x91\x03\x90\xF3[a\x01\xEB`\x04\x806\x03\x81\x01\x90a\x01\xE6\x91\x90a\x0C\xE8V[a\x06\xC9V[\0[a\x02\x07`\x04\x806\x03\x81\x01\x90a\x02\x02\x91\x90a\x0B\xB7V[a\x07zV[`@Qa\x02\x14\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x02%a\x07\x9AV[`@Qa\x022\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x02U`\x04\x806\x03\x81\x01\x90a\x02P\x91\x90a\x0C\xE8V[a\x07\xBEV[\0[a\x02q`\x04\x806\x03\x81\x01\x90a\x02l\x91\x90a\x0B\xB7V[a\x08oV[\0[a\x02{a\x08\xF2V[`@Qa\x02\x88\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x02\xAB`\x04\x806\x03\x81\x01\x90a\x02\xA6\x91\x90a\x0B\xB7V[a\t\x16V[`@Qa\x02\xB8\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[`\0`\x01`\0\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x03\x1EW`\x01\x90Pa\x03\\V[`\0a\x03(a\x04\x1CV[\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ba\x03W\x91\x90a\rWV[\x11\x91PP[\x90V[`\x01` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0`\x01`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x03\xDDWPa\x03\xDCa\x02\xC1V[[\x90P\x91\x90PV[a\x03\xECa\t\xC0V[a\x03\xF6`\0a\n>V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\0\x80`*\x90P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cM\x19u\xB4`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\x90W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xB4\x91\x90a\r\xB7V[\x90P`\0\x81\x03a\x04\xE8W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x92PPPa\x06\x9DV[`\0`\x01\x82a\x04\xF7\x91\x90a\rWV[\x90P[`\x01\x15a\x06vW`\0\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFC\x84`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x05]\x91\x90a\x0CwV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05zW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x9E\x91\x90a\x0E\x9EV[P\x91P\x91P`\0a\x05\xB8\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0B\x02V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a\x06\x1AW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x96PPPPPPPa\x06\x9DV[a\x06)\x86c\xFF\xFF\xFF\xFF\x16a\x0B\x0CV[c\xFF\xFF\xFF\xFF\x16a\x06>\x84c\xFF\xFF\xFF\xFF\x16a\x0B\x0CV[c\xFF\xFF\xFF\xFF\x16\x03a\x06WW\x80\x96PPPPPPPa\x06\x9DV[`\0\x84\x03a\x06gWPPPa\x06vV[\x83`\x01\x90\x03\x93PPPPa\x04\xFAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93PPPP[\x90V[`\0\x80`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x06\xD1a\t\xC0V[\x80`\x02`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fv\x1B\xED\xE7\x02\xFAe\x07\xFD\x97\x9A\\B\x13\xA8\xD5\xD3\x8BG\xAE\x9Fw6Pn\xAF\xE9\x14\x9Clkw\x82`@Qa\x07n\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xA2PPV[`\x02` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\xC6a\t\xC0V[\x80`\x01`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F [E\x86\xF0\xAA\xD6>8I\xB0\xC6\x98\x93\xBDa9\xAC\xA6s\xE7\xF1`\x88\xC5\x04i\x1Ce\x02\xCE\xE4\x82`@Qa\x08c\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xA2PPV[a\x08wa\t\xC0V[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x08\xE6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xDD\x90a\x0FtV[`@Q\x80\x91\x03\x90\xFD[a\x08\xEF\x81a\n>V[PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\0`\x02`\0\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\t\xB9WP`\x02`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16[\x90P\x91\x90PV[a\t\xC8a\x0B\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\t\xE6a\x06\xA0V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n<W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n3\x90a\x0F\xE0V[`@Q\x80\x91\x03\x90\xFD[V[`\0\x80`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81`\0\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\0\x81\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\x003\x90P\x90V[`\0\x81\x15\x15\x90P\x91\x90PV[a\x0B3\x81a\x0B\x1EV[\x82RPPV[`\0` \x82\x01\x90Pa\x0BN`\0\x83\x01\x84a\x0B*V[\x92\x91PPV[`\0\x80\xFD[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x0B\x84\x82a\x0BYV[\x90P\x91\x90PV[a\x0B\x94\x81a\x0ByV[\x81\x14a\x0B\x9FW`\0\x80\xFD[PV[`\0\x815\x90Pa\x0B\xB1\x81a\x0B\x8BV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x0B\xCDWa\x0B\xCCa\x0BTV[[`\0a\x0B\xDB\x84\x82\x85\x01a\x0B\xA2V[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a\x0C\ta\x0C\x04a\x0B\xFF\x84a\x0BYV[a\x0B\xE4V[a\x0BYV[\x90P\x91\x90PV[`\0a\x0C\x1B\x82a\x0B\xEEV[\x90P\x91\x90PV[`\0a\x0C-\x82a\x0C\x10V[\x90P\x91\x90PV[a\x0C=\x81a\x0C\"V[\x82RPPV[`\0` \x82\x01\x90Pa\x0CX`\0\x83\x01\x84a\x0C4V[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a\x0Cq\x81a\x0C^V[\x82RPPV[`\0` \x82\x01\x90Pa\x0C\x8C`\0\x83\x01\x84a\x0ChV[\x92\x91PPV[a\x0C\x9B\x81a\x0ByV[\x82RPPV[`\0` \x82\x01\x90Pa\x0C\xB6`\0\x83\x01\x84a\x0C\x92V[\x92\x91PPV[a\x0C\xC5\x81a\x0B\x1EV[\x81\x14a\x0C\xD0W`\0\x80\xFD[PV[`\0\x815\x90Pa\x0C\xE2\x81a\x0C\xBCV[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x0C\xFFWa\x0C\xFEa\x0BTV[[`\0a\r\r\x85\x82\x86\x01a\x0B\xA2V[\x92PP` a\r\x1E\x85\x82\x86\x01a\x0C\xD3V[\x91PP\x92P\x92\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a\rb\x82a\x0C^V[\x91Pa\rm\x83a\x0C^V[\x92P\x82\x82\x10\x15a\r\x80Wa\r\x7Fa\r(V[[\x82\x82\x03\x90P\x92\x91PPV[a\r\x94\x81a\x0C^V[\x81\x14a\r\x9FW`\0\x80\xFD[PV[`\0\x81Q\x90Pa\r\xB1\x81a\r\x8BV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\r\xCDWa\r\xCCa\x0BTV[[`\0a\r\xDB\x84\x82\x85\x01a\r\xA2V[\x91PP\x92\x91PPV[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\r\xFD\x81a\r\xE4V[\x81\x14a\x0E\x08W`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0E\x1A\x81a\r\xF4V[\x92\x91PPV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x0E=\x81a\x0E V[\x81\x14a\x0EHW`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0EZ\x81a\x0E4V[\x92\x91PPV[`\0a\x0Ek\x82a\x0ByV[\x90P\x91\x90PV[a\x0E{\x81a\x0E`V[\x81\x14a\x0E\x86W`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0E\x98\x81a\x0ErV[\x92\x91PPV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x0E\xB7Wa\x0E\xB6a\x0BTV[[`\0a\x0E\xC5\x86\x82\x87\x01a\x0E\x0BV[\x93PP` a\x0E\xD6\x86\x82\x87\x01a\x0EKV[\x92PP`@a\x0E\xE7\x86\x82\x87\x01a\x0E\x89V[\x91PP\x92P\x92P\x92V[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: new owner is the zero a`\0\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a\x0F^`&\x83a\x0E\xF1V[\x91Pa\x0Fi\x82a\x0F\x02V[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x0F\x8D\x81a\x0FQV[\x90P\x91\x90PV[\x7FOwnable: caller is not the owner`\0\x82\x01RPV[`\0a\x0F\xCA` \x83a\x0E\xF1V[\x91Pa\x0F\xD5\x82a\x0F\x94V[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x0F\xF9\x81a\x0F\xBDV[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \xFD\xEE\xC4\xA6\xC3\xE4\xFF,X\x1B%D!z\x110\x087_\xEE\xB4\xF2*\xB7\xD1\xF0`V\xBF\x17,\x1EdsolcC\0\x08\x0F\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c806392b5d1901161008c578063e9ed9b6411610066578063e9ed9b641461023b578063f2fde38b14610257578063fbc6def714610273578063ff59ae7d14610291576100ea565b806392b5d190146101d1578063cfea71c0146101ed578063d33b35051461021d576100ea565b8063715018a6116100c8578063715018a61461016d57806382ff53a1146101775780638620689d146101955780638da5cb5b146101b3576100ea565b80630c8b0fdf146100ef578063181774971461010d5780631d3225e31461013d575b600080fd5b6100f76102c1565b6040516101049190610b39565b60405180910390f35b61012760048036038101906101229190610bb7565b61035f565b6040516101349190610b39565b60405180910390f35b61015760048036038101906101529190610bb7565b61037f565b6040516101649190610b39565b60405180910390f35b6101756103e4565b005b61017f6103f8565b60405161018c9190610c43565b60405180910390f35b61019d61041c565b6040516101aa9190610c77565b60405180910390f35b6101bb6106a0565b6040516101c89190610ca1565b60405180910390f35b6101eb60048036038101906101e69190610ce8565b6106c9565b005b61020760048036038101906102029190610bb7565b61077a565b6040516102149190610b39565b60405180910390f35b61022561079a565b6040516102329190610c77565b60405180910390f35b61025560048036038101906102509190610ce8565b6107be565b005b610271600480360381019061026c9190610bb7565b61086f565b005b61027b6108f2565b6040516102889190610c77565b60405180910390f35b6102ab60048036038101906102a69190610bb7565b610916565b6040516102b89190610b39565b60405180910390f35b6000600160008073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561031e576001905061035c565b600061032861041c565b90507f000000000000000000000000000000000000000000000000000000000000000081426103579190610d57565b119150505b90565b60016020528060005260406000206000915054906101000a900460ff1681565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16806103dd57506103dc6102c1565b5b9050919050565b6103ec6109c0565b6103f66000610a3e565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b600080602a905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634d1975b46040518163ffffffff1660e01b8152600401602060405180830381865afa158015610490573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b49190610db7565b9050600081036104e8577f00000000000000000000000000000000000000000000000000000000000000009250505061069d565b60006001826104f79190610d57565b90505b600115610676576000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc846040518263ffffffff1660e01b815260040161055d9190610c77565b606060405180830381865afa15801561057a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059e9190610e9e565b509150915060006105b88267ffffffffffffffff16610b02565b67ffffffffffffffff1690507f000000000000000000000000000000000000000000000000000000000000000081101561061a577f0000000000000000000000000000000000000000000000000000000000000000965050505050505061069d565b6106298663ffffffff16610b0c565b63ffffffff1661063e8463ffffffff16610b0c565b63ffffffff16036106575780965050505050505061069d565b6000840361066757505050610676565b836001900393505050506104fa565b7f000000000000000000000000000000000000000000000000000000000000000093505050505b90565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6106d16109c0565b80600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f761bede702fa6507fd979a5c4213a8d5d38b47ae9f7736506eafe9149c6c6b778260405161076e9190610b39565b60405180910390a25050565b60026020528060005260406000206000915054906101000a900460ff1681565b7f000000000000000000000000000000000000000000000000000000000000000081565b6107c66109c0565b80600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f205b4586f0aad63e3849b0c69893bd6139aca673e7f16088c504691c6502cee4826040516108639190610b39565b60405180910390a25050565b6108776109c0565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036108e6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108dd90610f74565b60405180910390fd5b6108ef81610a3e565b50565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000600260008073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16806109b95750600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b9050919050565b6109c8610b16565b73ffffffffffffffffffffffffffffffffffffffff166109e66106a0565b73ffffffffffffffffffffffffffffffffffffffff1614610a3c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3390610fe0565b60405180910390fd5b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000819050919050565b6000819050919050565b600033905090565b60008115159050919050565b610b3381610b1e565b82525050565b6000602082019050610b4e6000830184610b2a565b92915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610b8482610b59565b9050919050565b610b9481610b79565b8114610b9f57600080fd5b50565b600081359050610bb181610b8b565b92915050565b600060208284031215610bcd57610bcc610b54565b5b6000610bdb84828501610ba2565b91505092915050565b6000819050919050565b6000610c09610c04610bff84610b59565b610be4565b610b59565b9050919050565b6000610c1b82610bee565b9050919050565b6000610c2d82610c10565b9050919050565b610c3d81610c22565b82525050565b6000602082019050610c586000830184610c34565b92915050565b6000819050919050565b610c7181610c5e565b82525050565b6000602082019050610c8c6000830184610c68565b92915050565b610c9b81610b79565b82525050565b6000602082019050610cb66000830184610c92565b92915050565b610cc581610b1e565b8114610cd057600080fd5b50565b600081359050610ce281610cbc565b92915050565b60008060408385031215610cff57610cfe610b54565b5b6000610d0d85828601610ba2565b9250506020610d1e85828601610cd3565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610d6282610c5e565b9150610d6d83610c5e565b925082821015610d8057610d7f610d28565b5b828203905092915050565b610d9481610c5e565b8114610d9f57600080fd5b50565b600081519050610db181610d8b565b92915050565b600060208284031215610dcd57610dcc610b54565b5b6000610ddb84828501610da2565b91505092915050565b600063ffffffff82169050919050565b610dfd81610de4565b8114610e0857600080fd5b50565b600081519050610e1a81610df4565b92915050565b600067ffffffffffffffff82169050919050565b610e3d81610e20565b8114610e4857600080fd5b50565b600081519050610e5a81610e34565b92915050565b6000610e6b82610b79565b9050919050565b610e7b81610e60565b8114610e8657600080fd5b50565b600081519050610e9881610e72565b92915050565b600080600060608486031215610eb757610eb6610b54565b5b6000610ec586828701610e0b565b9350506020610ed686828701610e4b565b9250506040610ee786828701610e89565b9150509250925092565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610f5e602683610ef1565b9150610f6982610f02565b604082019050919050565b60006020820190508181036000830152610f8d81610f51565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610fca602083610ef1565b9150610fd582610f94565b602082019050919050565b60006020820190508181036000830152610ff981610fbd565b905091905056fea2646970667358221220fdeec4a6c3e4ff2c581b2544217a113008375feeb4f22ab7d1f06056bf172c1e64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xEAW`\x005`\xE0\x1C\x80c\x92\xB5\xD1\x90\x11a\0\x8CW\x80c\xE9\xED\x9Bd\x11a\0fW\x80c\xE9\xED\x9Bd\x14a\x02;W\x80c\xF2\xFD\xE3\x8B\x14a\x02WW\x80c\xFB\xC6\xDE\xF7\x14a\x02sW\x80c\xFFY\xAE}\x14a\x02\x91Wa\0\xEAV[\x80c\x92\xB5\xD1\x90\x14a\x01\xD1W\x80c\xCF\xEAq\xC0\x14a\x01\xEDW\x80c\xD3;5\x05\x14a\x02\x1DWa\0\xEAV[\x80cqP\x18\xA6\x11a\0\xC8W\x80cqP\x18\xA6\x14a\x01mW\x80c\x82\xFFS\xA1\x14a\x01wW\x80c\x86 h\x9D\x14a\x01\x95W\x80c\x8D\xA5\xCB[\x14a\x01\xB3Wa\0\xEAV[\x80c\x0C\x8B\x0F\xDF\x14a\0\xEFW\x80c\x18\x17t\x97\x14a\x01\rW\x80c\x1D2%\xE3\x14a\x01=W[`\0\x80\xFD[a\0\xF7a\x02\xC1V[`@Qa\x01\x04\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01'`\x04\x806\x03\x81\x01\x90a\x01\"\x91\x90a\x0B\xB7V[a\x03_V[`@Qa\x014\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01W`\x04\x806\x03\x81\x01\x90a\x01R\x91\x90a\x0B\xB7V[a\x03\x7FV[`@Qa\x01d\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x01ua\x03\xE4V[\0[a\x01\x7Fa\x03\xF8V[`@Qa\x01\x8C\x91\x90a\x0CCV[`@Q\x80\x91\x03\x90\xF3[a\x01\x9Da\x04\x1CV[`@Qa\x01\xAA\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x01\xBBa\x06\xA0V[`@Qa\x01\xC8\x91\x90a\x0C\xA1V[`@Q\x80\x91\x03\x90\xF3[a\x01\xEB`\x04\x806\x03\x81\x01\x90a\x01\xE6\x91\x90a\x0C\xE8V[a\x06\xC9V[\0[a\x02\x07`\x04\x806\x03\x81\x01\x90a\x02\x02\x91\x90a\x0B\xB7V[a\x07zV[`@Qa\x02\x14\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[a\x02%a\x07\x9AV[`@Qa\x022\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x02U`\x04\x806\x03\x81\x01\x90a\x02P\x91\x90a\x0C\xE8V[a\x07\xBEV[\0[a\x02q`\x04\x806\x03\x81\x01\x90a\x02l\x91\x90a\x0B\xB7V[a\x08oV[\0[a\x02{a\x08\xF2V[`@Qa\x02\x88\x91\x90a\x0CwV[`@Q\x80\x91\x03\x90\xF3[a\x02\xAB`\x04\x806\x03\x81\x01\x90a\x02\xA6\x91\x90a\x0B\xB7V[a\t\x16V[`@Qa\x02\xB8\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xF3[`\0`\x01`\0\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x03\x1EW`\x01\x90Pa\x03\\V[`\0a\x03(a\x04\x1CV[\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ba\x03W\x91\x90a\rWV[\x11\x91PP[\x90V[`\x01` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0`\x01`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x03\xDDWPa\x03\xDCa\x02\xC1V[[\x90P\x91\x90PV[a\x03\xECa\t\xC0V[a\x03\xF6`\0a\n>V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\0\x80`*\x90P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cM\x19u\xB4`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\x90W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xB4\x91\x90a\r\xB7V[\x90P`\0\x81\x03a\x04\xE8W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x92PPPa\x06\x9DV[`\0`\x01\x82a\x04\xF7\x91\x90a\rWV[\x90P[`\x01\x15a\x06vW`\0\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFC\x84`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x05]\x91\x90a\x0CwV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05zW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x9E\x91\x90a\x0E\x9EV[P\x91P\x91P`\0a\x05\xB8\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0B\x02V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a\x06\x1AW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x96PPPPPPPa\x06\x9DV[a\x06)\x86c\xFF\xFF\xFF\xFF\x16a\x0B\x0CV[c\xFF\xFF\xFF\xFF\x16a\x06>\x84c\xFF\xFF\xFF\xFF\x16a\x0B\x0CV[c\xFF\xFF\xFF\xFF\x16\x03a\x06WW\x80\x96PPPPPPPa\x06\x9DV[`\0\x84\x03a\x06gWPPPa\x06vV[\x83`\x01\x90\x03\x93PPPPa\x04\xFAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93PPPP[\x90V[`\0\x80`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x06\xD1a\t\xC0V[\x80`\x02`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fv\x1B\xED\xE7\x02\xFAe\x07\xFD\x97\x9A\\B\x13\xA8\xD5\xD3\x8BG\xAE\x9Fw6Pn\xAF\xE9\x14\x9Clkw\x82`@Qa\x07n\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xA2PPV[`\x02` R\x80`\0R`@`\0 `\0\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\xC6a\t\xC0V[\x80`\x01`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F [E\x86\xF0\xAA\xD6>8I\xB0\xC6\x98\x93\xBDa9\xAC\xA6s\xE7\xF1`\x88\xC5\x04i\x1Ce\x02\xCE\xE4\x82`@Qa\x08c\x91\x90a\x0B9V[`@Q\x80\x91\x03\x90\xA2PPV[a\x08wa\t\xC0V[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x08\xE6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xDD\x90a\x0FtV[`@Q\x80\x91\x03\x90\xFD[a\x08\xEF\x81a\n>V[PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\0`\x02`\0\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\t\xB9WP`\x02`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16[\x90P\x91\x90PV[a\t\xC8a\x0B\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\t\xE6a\x06\xA0V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n<W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n3\x90a\x0F\xE0V[`@Q\x80\x91\x03\x90\xFD[V[`\0\x80`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81`\0\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\0\x81\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\x003\x90P\x90V[`\0\x81\x15\x15\x90P\x91\x90PV[a\x0B3\x81a\x0B\x1EV[\x82RPPV[`\0` \x82\x01\x90Pa\x0BN`\0\x83\x01\x84a\x0B*V[\x92\x91PPV[`\0\x80\xFD[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a\x0B\x84\x82a\x0BYV[\x90P\x91\x90PV[a\x0B\x94\x81a\x0ByV[\x81\x14a\x0B\x9FW`\0\x80\xFD[PV[`\0\x815\x90Pa\x0B\xB1\x81a\x0B\x8BV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x0B\xCDWa\x0B\xCCa\x0BTV[[`\0a\x0B\xDB\x84\x82\x85\x01a\x0B\xA2V[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a\x0C\ta\x0C\x04a\x0B\xFF\x84a\x0BYV[a\x0B\xE4V[a\x0BYV[\x90P\x91\x90PV[`\0a\x0C\x1B\x82a\x0B\xEEV[\x90P\x91\x90PV[`\0a\x0C-\x82a\x0C\x10V[\x90P\x91\x90PV[a\x0C=\x81a\x0C\"V[\x82RPPV[`\0` \x82\x01\x90Pa\x0CX`\0\x83\x01\x84a\x0C4V[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a\x0Cq\x81a\x0C^V[\x82RPPV[`\0` \x82\x01\x90Pa\x0C\x8C`\0\x83\x01\x84a\x0ChV[\x92\x91PPV[a\x0C\x9B\x81a\x0ByV[\x82RPPV[`\0` \x82\x01\x90Pa\x0C\xB6`\0\x83\x01\x84a\x0C\x92V[\x92\x91PPV[a\x0C\xC5\x81a\x0B\x1EV[\x81\x14a\x0C\xD0W`\0\x80\xFD[PV[`\0\x815\x90Pa\x0C\xE2\x81a\x0C\xBCV[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a\x0C\xFFWa\x0C\xFEa\x0BTV[[`\0a\r\r\x85\x82\x86\x01a\x0B\xA2V[\x92PP` a\r\x1E\x85\x82\x86\x01a\x0C\xD3V[\x91PP\x92P\x92\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a\rb\x82a\x0C^V[\x91Pa\rm\x83a\x0C^V[\x92P\x82\x82\x10\x15a\r\x80Wa\r\x7Fa\r(V[[\x82\x82\x03\x90P\x92\x91PPV[a\r\x94\x81a\x0C^V[\x81\x14a\r\x9FW`\0\x80\xFD[PV[`\0\x81Q\x90Pa\r\xB1\x81a\r\x8BV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\r\xCDWa\r\xCCa\x0BTV[[`\0a\r\xDB\x84\x82\x85\x01a\r\xA2V[\x91PP\x92\x91PPV[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\r\xFD\x81a\r\xE4V[\x81\x14a\x0E\x08W`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0E\x1A\x81a\r\xF4V[\x92\x91PPV[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x0E=\x81a\x0E V[\x81\x14a\x0EHW`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0EZ\x81a\x0E4V[\x92\x91PPV[`\0a\x0Ek\x82a\x0ByV[\x90P\x91\x90PV[a\x0E{\x81a\x0E`V[\x81\x14a\x0E\x86W`\0\x80\xFD[PV[`\0\x81Q\x90Pa\x0E\x98\x81a\x0ErV[\x92\x91PPV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x0E\xB7Wa\x0E\xB6a\x0BTV[[`\0a\x0E\xC5\x86\x82\x87\x01a\x0E\x0BV[\x93PP` a\x0E\xD6\x86\x82\x87\x01a\x0EKV[\x92PP`@a\x0E\xE7\x86\x82\x87\x01a\x0E\x89V[\x91PP\x92P\x92P\x92V[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: new owner is the zero a`\0\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[`\0a\x0F^`&\x83a\x0E\xF1V[\x91Pa\x0Fi\x82a\x0F\x02V[`@\x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x0F\x8D\x81a\x0FQV[\x90P\x91\x90PV[\x7FOwnable: caller is not the owner`\0\x82\x01RPV[`\0a\x0F\xCA` \x83a\x0E\xF1V[\x91Pa\x0F\xD5\x82a\x0F\x94V[` \x82\x01\x90P\x91\x90PV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra\x0F\xF9\x81a\x0F\xBDV[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \xFD\xEE\xC4\xA6\xC3\xE4\xFF,X\x1B%D!z\x110\x087_\xEE\xB4\xF2*\xB7\xD1\xF0`V\xBF\x17,\x1EdsolcC\0\x08\x0F\x003",
    );
    /**Event with signature `ChallengerPermissionUpdated(address,bool)` and selector `0x761bede702fa6507fd979a5c4213a8d5d38b47ae9f7736506eafe9149c6c6b77`.
```solidity
event ChallengerPermissionUpdated(address indexed challenger, bool allowed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengerPermissionUpdated {
        #[allow(missing_docs)]
        pub challenger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengerPermissionUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ChallengerPermissionUpdated(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                118u8, 27u8, 237u8, 231u8, 2u8, 250u8, 101u8, 7u8, 253u8, 151u8, 154u8,
                92u8, 66u8, 19u8, 168u8, 213u8, 211u8, 139u8, 71u8, 174u8, 159u8, 119u8,
                54u8, 80u8, 110u8, 175u8, 233u8, 20u8, 156u8, 108u8, 107u8, 119u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    challenger: topics.1,
                    allowed: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.challenger.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.challenger,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengerPermissionUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengerPermissionUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ChallengerPermissionUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ProposerPermissionUpdated(address,bool)` and selector `0x205b4586f0aad63e3849b0c69893bd6139aca673e7f16088c504691c6502cee4`.
```solidity
event ProposerPermissionUpdated(address indexed proposer, bool allowed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProposerPermissionUpdated {
        #[allow(missing_docs)]
        pub proposer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProposerPermissionUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ProposerPermissionUpdated(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                32u8, 91u8, 69u8, 134u8, 240u8, 170u8, 214u8, 62u8, 56u8, 73u8, 176u8,
                198u8, 152u8, 147u8, 189u8, 97u8, 57u8, 172u8, 166u8, 115u8, 231u8,
                241u8, 96u8, 136u8, 197u8, 4u8, 105u8, 28u8, 101u8, 2u8, 206u8, 228u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    proposer: topics.1,
                    allowed: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.proposer.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.proposer,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProposerPermissionUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProposerPermissionUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ProposerPermissionUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 _fallbackTimeout, address _disputeGameFactory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _fallbackTimeout: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _disputeGameFactory: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._fallbackTimeout, value._disputeGameFactory)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _fallbackTimeout: tuple.0,
                        _disputeGameFactory: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._fallbackTimeout),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._disputeGameFactory,
                    ),
                )
            }
        }
    };
    /**Function with signature `DEPLOYMENT_TIMESTAMP()` and selector `0xfbc6def7`.
```solidity
function DEPLOYMENT_TIMESTAMP() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYMENT_TIMESTAMPCall;
    ///Container type for the return parameters of the [`DEPLOYMENT_TIMESTAMP()`](DEPLOYMENT_TIMESTAMPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYMENT_TIMESTAMPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEPLOYMENT_TIMESTAMPCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEPLOYMENT_TIMESTAMPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYMENT_TIMESTAMPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEPLOYMENT_TIMESTAMPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEPLOYMENT_TIMESTAMPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYMENT_TIMESTAMPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEPLOYMENT_TIMESTAMPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEPLOYMENT_TIMESTAMP()";
            const SELECTOR: [u8; 4] = [251u8, 198u8, 222u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEPLOYMENT_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEPLOYMENT_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `DISPUTE_GAME_FACTORY()` and selector `0x82ff53a1`.
```solidity
function DISPUTE_GAME_FACTORY() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISPUTE_GAME_FACTORYCall;
    ///Container type for the return parameters of the [`DISPUTE_GAME_FACTORY()`](DISPUTE_GAME_FACTORYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISPUTE_GAME_FACTORYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISPUTE_GAME_FACTORYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISPUTE_GAME_FACTORYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISPUTE_GAME_FACTORYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISPUTE_GAME_FACTORYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISPUTE_GAME_FACTORYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISPUTE_GAME_FACTORYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DISPUTE_GAME_FACTORYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DISPUTE_GAME_FACTORY()";
            const SELECTOR: [u8; 4] = [130u8, 255u8, 83u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DISPUTE_GAME_FACTORYReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DISPUTE_GAME_FACTORYReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `FALLBACK_TIMEOUT()` and selector `0xd33b3505`.
```solidity
function FALLBACK_TIMEOUT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FALLBACK_TIMEOUTCall;
    ///Container type for the return parameters of the [`FALLBACK_TIMEOUT()`](FALLBACK_TIMEOUTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FALLBACK_TIMEOUTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<FALLBACK_TIMEOUTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: FALLBACK_TIMEOUTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for FALLBACK_TIMEOUTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<FALLBACK_TIMEOUTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: FALLBACK_TIMEOUTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for FALLBACK_TIMEOUTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for FALLBACK_TIMEOUTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FALLBACK_TIMEOUT()";
            const SELECTOR: [u8; 4] = [211u8, 59u8, 53u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: FALLBACK_TIMEOUTReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: FALLBACK_TIMEOUTReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `challengers(address)` and selector `0xcfea71c0`.
```solidity
function challengers(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengersCall(pub alloy::sol_types::private::Address);
    ///Container type for the return parameters of the [`challengers(address)`](challengersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengersReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengersCall> for UnderlyingRustTuple<'_> {
                fn from(value: challengersCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: challengersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengers(address)";
            const SELECTOR: [u8; 4] = [207u8, 234u8, 113u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: challengersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: challengersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `getLastProposalTimestamp()` and selector `0x8620689d`.
```solidity
function getLastProposalTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastProposalTimestampCall;
    ///Container type for the return parameters of the [`getLastProposalTimestamp()`](getLastProposalTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastProposalTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastProposalTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastProposalTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastProposalTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastProposalTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastProposalTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastProposalTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastProposalTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastProposalTimestamp()";
            const SELECTOR: [u8; 4] = [134u8, 32u8, 104u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getLastProposalTimestampReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getLastProposalTimestampReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `isAllowedChallenger(address)` and selector `0xff59ae7d`.
```solidity
function isAllowedChallenger(address _challenger) external view returns (bool allowed_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedChallengerCall {
        #[allow(missing_docs)]
        pub _challenger: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isAllowedChallenger(address)`](isAllowedChallengerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedChallengerReturn {
        #[allow(missing_docs)]
        pub allowed_: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedChallengerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedChallengerCall) -> Self {
                    (value._challenger,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAllowedChallengerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _challenger: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedChallengerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedChallengerReturn) -> Self {
                    (value.allowed_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAllowedChallengerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { allowed_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAllowedChallengerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAllowedChallenger(address)";
            const SELECTOR: [u8; 4] = [255u8, 89u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._challenger,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAllowedChallengerReturn = r.into();
                        r.allowed_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAllowedChallengerReturn = r.into();
                        r.allowed_
                    })
            }
        }
    };
    /**Function with signature `isAllowedProposer(address)` and selector `0x1d3225e3`.
```solidity
function isAllowedProposer(address _proposer) external view returns (bool allowed_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedProposerCall {
        #[allow(missing_docs)]
        pub _proposer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isAllowedProposer(address)`](isAllowedProposerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedProposerReturn {
        #[allow(missing_docs)]
        pub allowed_: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedProposerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedProposerCall) -> Self {
                    (value._proposer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAllowedProposerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _proposer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedProposerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedProposerReturn) -> Self {
                    (value.allowed_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAllowedProposerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { allowed_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAllowedProposerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAllowedProposer(address)";
            const SELECTOR: [u8; 4] = [29u8, 50u8, 37u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._proposer,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAllowedProposerReturn = r.into();
                        r.allowed_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAllowedProposerReturn = r.into();
                        r.allowed_
                    })
            }
        }
    };
    /**Function with signature `isProposalPermissionlessMode()` and selector `0x0c8b0fdf`.
```solidity
function isProposalPermissionlessMode() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isProposalPermissionlessModeCall;
    ///Container type for the return parameters of the [`isProposalPermissionlessMode()`](isProposalPermissionlessModeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isProposalPermissionlessModeReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isProposalPermissionlessModeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isProposalPermissionlessModeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isProposalPermissionlessModeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isProposalPermissionlessModeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isProposalPermissionlessModeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isProposalPermissionlessModeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isProposalPermissionlessModeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isProposalPermissionlessMode()";
            const SELECTOR: [u8; 4] = [12u8, 139u8, 15u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isProposalPermissionlessModeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isProposalPermissionlessModeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `proposers(address)` and selector `0x18177497`.
```solidity
function proposers(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proposersCall(pub alloy::sol_types::private::Address);
    ///Container type for the return parameters of the [`proposers(address)`](proposersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proposersReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proposersCall> for UnderlyingRustTuple<'_> {
                fn from(value: proposersCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proposersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proposersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proposersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proposersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proposersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proposers(address)";
            const SELECTOR: [u8; 4] = [24u8, 23u8, 116u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proposersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proposersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallenger(address,bool)` and selector `0x92b5d190`.
```solidity
function setChallenger(address _challenger, bool _allowed) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengerCall {
        #[allow(missing_docs)]
        pub _challenger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _allowed: bool,
    }
    ///Container type for the return parameters of the [`setChallenger(address,bool)`](setChallengerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setChallengerCall) -> Self {
                    (value._challenger, value._allowed)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChallengerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _challenger: tuple.0,
                        _allowed: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setChallengerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChallengerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setChallengerReturn {
            fn _tokenize(
                &self,
            ) -> <setChallengerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallenger(address,bool)";
            const SELECTOR: [u8; 4] = [146u8, 181u8, 209u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._challenger,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._allowed,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setChallengerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setProposer(address,bool)` and selector `0xe9ed9b64`.
```solidity
function setProposer(address _proposer, bool _allowed) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProposerCall {
        #[allow(missing_docs)]
        pub _proposer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _allowed: bool,
    }
    ///Container type for the return parameters of the [`setProposer(address,bool)`](setProposerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProposerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProposerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setProposerCall) -> Self {
                    (value._proposer, value._allowed)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProposerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _proposer: tuple.0,
                        _allowed: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProposerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setProposerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProposerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setProposerReturn {
            fn _tokenize(
                &self,
            ) -> <setProposerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProposerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProposerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProposer(address,bool)";
            const SELECTOR: [u8; 4] = [233u8, 237u8, 155u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._proposer,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._allowed,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setProposerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`AccessManager`](self) function calls.
    #[derive(Clone)]
    pub enum AccessManagerCalls {
        #[allow(missing_docs)]
        DEPLOYMENT_TIMESTAMP(DEPLOYMENT_TIMESTAMPCall),
        #[allow(missing_docs)]
        DISPUTE_GAME_FACTORY(DISPUTE_GAME_FACTORYCall),
        #[allow(missing_docs)]
        FALLBACK_TIMEOUT(FALLBACK_TIMEOUTCall),
        #[allow(missing_docs)]
        challengers(challengersCall),
        #[allow(missing_docs)]
        getLastProposalTimestamp(getLastProposalTimestampCall),
        #[allow(missing_docs)]
        isAllowedChallenger(isAllowedChallengerCall),
        #[allow(missing_docs)]
        isAllowedProposer(isAllowedProposerCall),
        #[allow(missing_docs)]
        isProposalPermissionlessMode(isProposalPermissionlessModeCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        proposers(proposersCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        setChallenger(setChallengerCall),
        #[allow(missing_docs)]
        setProposer(setProposerCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    impl AccessManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [12u8, 139u8, 15u8, 223u8],
            [24u8, 23u8, 116u8, 151u8],
            [29u8, 50u8, 37u8, 227u8],
            [113u8, 80u8, 24u8, 166u8],
            [130u8, 255u8, 83u8, 161u8],
            [134u8, 32u8, 104u8, 157u8],
            [141u8, 165u8, 203u8, 91u8],
            [146u8, 181u8, 209u8, 144u8],
            [207u8, 234u8, 113u8, 192u8],
            [211u8, 59u8, 53u8, 5u8],
            [233u8, 237u8, 155u8, 100u8],
            [242u8, 253u8, 227u8, 139u8],
            [251u8, 198u8, 222u8, 247u8],
            [255u8, 89u8, 174u8, 125u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(isProposalPermissionlessMode),
            ::core::stringify!(proposers),
            ::core::stringify!(isAllowedProposer),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(DISPUTE_GAME_FACTORY),
            ::core::stringify!(getLastProposalTimestamp),
            ::core::stringify!(owner),
            ::core::stringify!(setChallenger),
            ::core::stringify!(challengers),
            ::core::stringify!(FALLBACK_TIMEOUT),
            ::core::stringify!(setProposer),
            ::core::stringify!(transferOwnership),
            ::core::stringify!(DEPLOYMENT_TIMESTAMP),
            ::core::stringify!(isAllowedChallenger),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proposersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isAllowedProposerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getLastProposalTimestampCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setChallengerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <challengersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setProposerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isAllowedChallengerCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AccessManagerCalls {
        const NAME: &'static str = "AccessManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEPLOYMENT_TIMESTAMP(_) => {
                    <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DISPUTE_GAME_FACTORY(_) => {
                    <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::FALLBACK_TIMEOUT(_) => {
                    <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengers(_) => {
                    <challengersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLastProposalTimestamp(_) => {
                    <getLastProposalTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAllowedChallenger(_) => {
                    <isAllowedChallengerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAllowedProposer(_) => {
                    <isAllowedProposerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isProposalPermissionlessMode(_) => {
                    <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proposers(_) => {
                    <proposersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallenger(_) => {
                    <setChallengerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProposer(_) => {
                    <setProposerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<AccessManagerCalls>] = &[
                {
                    fn isProposalPermissionlessMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::isProposalPermissionlessMode)
                    }
                    isProposalPermissionlessMode
                },
                {
                    fn proposers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <proposersCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(AccessManagerCalls::proposers)
                    }
                    proposers
                },
                {
                    fn isAllowedProposer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isAllowedProposerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::isAllowedProposer)
                    }
                    isAllowedProposer
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn DISPUTE_GAME_FACTORY(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::DISPUTE_GAME_FACTORY)
                    }
                    DISPUTE_GAME_FACTORY
                },
                {
                    fn getLastProposalTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <getLastProposalTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::getLastProposalTimestamp)
                    }
                    getLastProposalTimestamp
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(AccessManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn setChallenger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <setChallengerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::setChallenger)
                    }
                    setChallenger
                },
                {
                    fn challengers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <challengersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::challengers)
                    }
                    challengers
                },
                {
                    fn FALLBACK_TIMEOUT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::FALLBACK_TIMEOUT)
                    }
                    FALLBACK_TIMEOUT
                },
                {
                    fn setProposer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <setProposerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::setProposer)
                    }
                    setProposer
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn DEPLOYMENT_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::DEPLOYMENT_TIMESTAMP)
                    }
                    DEPLOYMENT_TIMESTAMP
                },
                {
                    fn isAllowedChallenger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isAllowedChallengerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(AccessManagerCalls::isAllowedChallenger)
                    }
                    isAllowedChallenger
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<AccessManagerCalls>] = &[
                {
                    fn isProposalPermissionlessMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::isProposalPermissionlessMode)
                    }
                    isProposalPermissionlessMode
                },
                {
                    fn proposers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <proposersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::proposers)
                    }
                    proposers
                },
                {
                    fn isAllowedProposer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isAllowedProposerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::isAllowedProposer)
                    }
                    isAllowedProposer
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn DISPUTE_GAME_FACTORY(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::DISPUTE_GAME_FACTORY)
                    }
                    DISPUTE_GAME_FACTORY
                },
                {
                    fn getLastProposalTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <getLastProposalTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::getLastProposalTimestamp)
                    }
                    getLastProposalTimestamp
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn setChallenger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <setChallengerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::setChallenger)
                    }
                    setChallenger
                },
                {
                    fn challengers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <challengersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::challengers)
                    }
                    challengers
                },
                {
                    fn FALLBACK_TIMEOUT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::FALLBACK_TIMEOUT)
                    }
                    FALLBACK_TIMEOUT
                },
                {
                    fn setProposer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <setProposerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::setProposer)
                    }
                    setProposer
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn DEPLOYMENT_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::DEPLOYMENT_TIMESTAMP)
                    }
                    DEPLOYMENT_TIMESTAMP
                },
                {
                    fn isAllowedChallenger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<AccessManagerCalls> {
                        <isAllowedChallengerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(AccessManagerCalls::isAllowedChallenger)
                    }
                    isAllowedChallenger
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEPLOYMENT_TIMESTAMP(inner) => {
                    <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DISPUTE_GAME_FACTORY(inner) => {
                    <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FALLBACK_TIMEOUT(inner) => {
                    <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengers(inner) => {
                    <challengersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLastProposalTimestamp(inner) => {
                    <getLastProposalTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isAllowedChallenger(inner) => {
                    <isAllowedChallengerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isAllowedProposer(inner) => {
                    <isAllowedProposerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isProposalPermissionlessMode(inner) => {
                    <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proposers(inner) => {
                    <proposersCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallenger(inner) => {
                    <setChallengerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProposer(inner) => {
                    <setProposerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEPLOYMENT_TIMESTAMP(inner) => {
                    <DEPLOYMENT_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DISPUTE_GAME_FACTORY(inner) => {
                    <DISPUTE_GAME_FACTORYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FALLBACK_TIMEOUT(inner) => {
                    <FALLBACK_TIMEOUTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengers(inner) => {
                    <challengersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLastProposalTimestamp(inner) => {
                    <getLastProposalTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAllowedChallenger(inner) => {
                    <isAllowedChallengerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAllowedProposer(inner) => {
                    <isAllowedProposerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isProposalPermissionlessMode(inner) => {
                    <isProposalPermissionlessModeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proposers(inner) => {
                    <proposersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallenger(inner) => {
                    <setChallengerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProposer(inner) => {
                    <setProposerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`AccessManager`](self) events.
    #[derive(Clone)]
    pub enum AccessManagerEvents {
        #[allow(missing_docs)]
        ChallengerPermissionUpdated(ChallengerPermissionUpdated),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        ProposerPermissionUpdated(ProposerPermissionUpdated),
    }
    impl AccessManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                32u8, 91u8, 69u8, 134u8, 240u8, 170u8, 214u8, 62u8, 56u8, 73u8, 176u8,
                198u8, 152u8, 147u8, 189u8, 97u8, 57u8, 172u8, 166u8, 115u8, 231u8,
                241u8, 96u8, 136u8, 197u8, 4u8, 105u8, 28u8, 101u8, 2u8, 206u8, 228u8,
            ],
            [
                118u8, 27u8, 237u8, 231u8, 2u8, 250u8, 101u8, 7u8, 253u8, 151u8, 154u8,
                92u8, 66u8, 19u8, 168u8, 213u8, 211u8, 139u8, 71u8, 174u8, 159u8, 119u8,
                54u8, 80u8, 110u8, 175u8, 233u8, 20u8, 156u8, 108u8, 107u8, 119u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(ProposerPermissionUpdated),
            ::core::stringify!(ChallengerPermissionUpdated),
            ::core::stringify!(OwnershipTransferred),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <ProposerPermissionUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <ChallengerPermissionUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for AccessManagerEvents {
        const NAME: &'static str = "AccessManagerEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengerPermissionUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengerPermissionUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChallengerPermissionUpdated)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <ProposerPermissionUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProposerPermissionUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ProposerPermissionUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for AccessManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengerPermissionUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProposerPermissionUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengerPermissionUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProposerPermissionUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`AccessManager`](self) contract instance.

See the [wrapper's documentation](`AccessManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> AccessManagerInstance<P, N> {
        AccessManagerInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _fallbackTimeout: alloy::sol_types::private::primitives::aliases::U256,
        _disputeGameFactory: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<AccessManagerInstance<P, N>>,
    > {
        AccessManagerInstance::<
            P,
            N,
        >::deploy(__provider, _fallbackTimeout, _disputeGameFactory)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _fallbackTimeout: alloy::sol_types::private::primitives::aliases::U256,
        _disputeGameFactory: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        AccessManagerInstance::<
            P,
            N,
        >::deploy_builder(__provider, _fallbackTimeout, _disputeGameFactory)
    }
    /**A [`AccessManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`AccessManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct AccessManagerInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for AccessManagerInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("AccessManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > AccessManagerInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`AccessManager`](self) contract instance.

See the [wrapper's documentation](`AccessManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _fallbackTimeout: alloy::sol_types::private::primitives::aliases::U256,
            _disputeGameFactory: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<AccessManagerInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                _fallbackTimeout,
                _disputeGameFactory,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _fallbackTimeout: alloy::sol_types::private::primitives::aliases::U256,
            _disputeGameFactory: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _fallbackTimeout,
                            _disputeGameFactory,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> AccessManagerInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> AccessManagerInstance<P, N> {
            AccessManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > AccessManagerInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEPLOYMENT_TIMESTAMP`] function.
        pub fn DEPLOYMENT_TIMESTAMP(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEPLOYMENT_TIMESTAMPCall, N> {
            self.call_builder(&DEPLOYMENT_TIMESTAMPCall)
        }
        ///Creates a new call builder for the [`DISPUTE_GAME_FACTORY`] function.
        pub fn DISPUTE_GAME_FACTORY(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DISPUTE_GAME_FACTORYCall, N> {
            self.call_builder(&DISPUTE_GAME_FACTORYCall)
        }
        ///Creates a new call builder for the [`FALLBACK_TIMEOUT`] function.
        pub fn FALLBACK_TIMEOUT(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, FALLBACK_TIMEOUTCall, N> {
            self.call_builder(&FALLBACK_TIMEOUTCall)
        }
        ///Creates a new call builder for the [`challengers`] function.
        pub fn challengers(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, challengersCall, N> {
            self.call_builder(&challengersCall(_0))
        }
        ///Creates a new call builder for the [`getLastProposalTimestamp`] function.
        pub fn getLastProposalTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getLastProposalTimestampCall, N> {
            self.call_builder(&getLastProposalTimestampCall)
        }
        ///Creates a new call builder for the [`isAllowedChallenger`] function.
        pub fn isAllowedChallenger(
            &self,
            _challenger: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isAllowedChallengerCall, N> {
            self.call_builder(
                &isAllowedChallengerCall {
                    _challenger,
                },
            )
        }
        ///Creates a new call builder for the [`isAllowedProposer`] function.
        pub fn isAllowedProposer(
            &self,
            _proposer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isAllowedProposerCall, N> {
            self.call_builder(&isAllowedProposerCall { _proposer })
        }
        ///Creates a new call builder for the [`isProposalPermissionlessMode`] function.
        pub fn isProposalPermissionlessMode(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, isProposalPermissionlessModeCall, N> {
            self.call_builder(&isProposalPermissionlessModeCall)
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`proposers`] function.
        pub fn proposers(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, proposersCall, N> {
            self.call_builder(&proposersCall(_0))
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`setChallenger`] function.
        pub fn setChallenger(
            &self,
            _challenger: alloy::sol_types::private::Address,
            _allowed: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setChallengerCall, N> {
            self.call_builder(
                &setChallengerCall {
                    _challenger,
                    _allowed,
                },
            )
        }
        ///Creates a new call builder for the [`setProposer`] function.
        pub fn setProposer(
            &self,
            _proposer: alloy::sol_types::private::Address,
            _allowed: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setProposerCall, N> {
            self.call_builder(
                &setProposerCall {
                    _proposer,
                    _allowed,
                },
            )
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > AccessManagerInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengerPermissionUpdated`] event.
        pub fn ChallengerPermissionUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChallengerPermissionUpdated, N> {
            self.event_filter::<ChallengerPermissionUpdated>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ProposerPermissionUpdated`] event.
        pub fn ProposerPermissionUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, ProposerPermissionUpdated, N> {
            self.event_filter::<ProposerPermissionUpdated>()
        }
    }
}
