/**

Generated by the following Solidity interface...
```solidity
interface OPSuccinctFaultDisputeGame {
    type BondDistributionMode is uint8;
    type GameStatus is uint8;
    type ProposalStatus is uint8;
    type Claim is bytes32;
    type Duration is uint64;
    type GameType is uint32;
    type Hash is bytes32;
    type Timestamp is uint64;

    error AlreadyInitialized();
    error BadAuth();
    error BondTransferFailed();
    error ClaimAlreadyChallenged();
    error ClaimAlreadyResolved();
    error GameNotFinalized();
    error GameNotOver();
    error GameOver();
    error IncorrectBondAmount();
    error IncorrectDisputeGameFactory();
    error InvalidBondDistributionMode();
    error InvalidParentGame();
    error InvalidProposalStatus();
    error NoCreditToClaim();
    error ParentGameNotResolved();
    error UnexpectedRootClaim(Claim rootClaim);

    event Challenged(address indexed challenger);
    event GameClosed(BondDistributionMode bondDistributionMode);
    event Proved(address indexed prover);
    event Resolved(GameStatus indexed status);

    constructor(Duration _maxChallengeDuration, Duration _maxProveDuration, address _disputeGameFactory, address _sp1Verifier, bytes32 _rollupConfigHash, bytes32 _aggregationVkey, bytes32 _rangeVkeyCommitment, uint256 _challengerBond, address _anchorStateRegistry, address _accessManager);

    function accessManager() external view returns (address accessManager_);
    function aggregationVkey() external view returns (bytes32 aggregationVkey_);
    function anchorStateRegistry() external view returns (address registry_);
    function bondDistributionMode() external view returns (BondDistributionMode);
    function challenge() external payable returns (ProposalStatus);
    function challengerBond() external view returns (uint256 challengerBond_);
    function claimCredit(address _recipient) external;
    function claimData() external view returns (uint32 parentIndex, address counteredBy, address prover, Claim claim, ProposalStatus status, Timestamp deadline);
    function closeGame() external;
    function createdAt() external view returns (Timestamp);
    function credit(address _recipient) external view returns (uint256 credit_);
    function disputeGameFactory() external view returns (address disputeGameFactory_);
    function extraData() external pure returns (bytes memory extraData_);
    function gameCreator() external pure returns (address creator_);
    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);
    function gameOver() external view returns (bool gameOver_);
    function gameType() external view returns (GameType gameType_);
    function initialize() external payable;
    function l1Head() external pure returns (Hash l1Head_);
    function l2BlockNumber() external pure returns (uint256 l2BlockNumber_);
    function l2SequenceNumber() external pure returns (uint256 l2SequenceNumber_);
    function maxChallengeDuration() external view returns (Duration maxChallengeDuration_);
    function maxProveDuration() external view returns (Duration maxProveDuration_);
    function normalModeCredit(address) external view returns (uint256);
    function parentIndex() external pure returns (uint32 parentIndex_);
    function prove(bytes memory proofBytes) external returns (ProposalStatus);
    function rangeVkeyCommitment() external view returns (bytes32 rangeVkeyCommitment_);
    function refundModeCredit(address) external view returns (uint256);
    function resolve() external returns (GameStatus);
    function resolvedAt() external view returns (Timestamp);
    function rollupConfigHash() external view returns (bytes32 rollupConfigHash_);
    function rootClaim() external pure returns (Claim rootClaim_);
    function sp1Verifier() external view returns (address verifier_);
    function startingBlockNumber() external view returns (uint256 startingBlockNumber_);
    function startingOutputRoot() external view returns (Hash root, uint256 l2SequenceNumber);
    function startingRootHash() external view returns (Hash startingRootHash_);
    function status() external view returns (GameStatus);
    function version() external view returns (string memory);
    function wasRespectedGameTypeWhenCreated() external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_maxChallengeDuration",
        "type": "uint64",
        "internalType": "Duration"
      },
      {
        "name": "_maxProveDuration",
        "type": "uint64",
        "internalType": "Duration"
      },
      {
        "name": "_disputeGameFactory",
        "type": "address",
        "internalType": "contract IDisputeGameFactory"
      },
      {
        "name": "_sp1Verifier",
        "type": "address",
        "internalType": "contract ISP1Verifier"
      },
      {
        "name": "_rollupConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "_aggregationVkey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "_rangeVkeyCommitment",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "_challengerBond",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_anchorStateRegistry",
        "type": "address",
        "internalType": "contract IAnchorStateRegistry"
      },
      {
        "name": "_accessManager",
        "type": "address",
        "internalType": "contract AccessManager"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "accessManager",
    "inputs": [],
    "outputs": [
      {
        "name": "accessManager_",
        "type": "address",
        "internalType": "contract AccessManager"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "aggregationVkey",
    "inputs": [],
    "outputs": [
      {
        "name": "aggregationVkey_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "anchorStateRegistry",
    "inputs": [],
    "outputs": [
      {
        "name": "registry_",
        "type": "address",
        "internalType": "contract IAnchorStateRegistry"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bondDistributionMode",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum BondDistributionMode"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challenge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum OPSuccinctFaultDisputeGame.ProposalStatus"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "challengerBond",
    "inputs": [],
    "outputs": [
      {
        "name": "challengerBond_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimCredit",
    "inputs": [
      {
        "name": "_recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimData",
    "inputs": [],
    "outputs": [
      {
        "name": "parentIndex",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "counteredBy",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "prover",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claim",
        "type": "bytes32",
        "internalType": "Claim"
      },
      {
        "name": "status",
        "type": "uint8",
        "internalType": "enum OPSuccinctFaultDisputeGame.ProposalStatus"
      },
      {
        "name": "deadline",
        "type": "uint64",
        "internalType": "Timestamp"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeGame",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createdAt",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "Timestamp"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "credit",
    "inputs": [
      {
        "name": "_recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "credit_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "disputeGameFactory",
    "inputs": [],
    "outputs": [
      {
        "name": "disputeGameFactory_",
        "type": "address",
        "internalType": "contract IDisputeGameFactory"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extraData",
    "inputs": [],
    "outputs": [
      {
        "name": "extraData_",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "gameCreator",
    "inputs": [],
    "outputs": [
      {
        "name": "creator_",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "gameData",
    "inputs": [],
    "outputs": [
      {
        "name": "gameType_",
        "type": "uint32",
        "internalType": "GameType"
      },
      {
        "name": "rootClaim_",
        "type": "bytes32",
        "internalType": "Claim"
      },
      {
        "name": "extraData_",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameOver",
    "inputs": [],
    "outputs": [
      {
        "name": "gameOver_",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gameType",
    "inputs": [],
    "outputs": [
      {
        "name": "gameType_",
        "type": "uint32",
        "internalType": "GameType"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "l1Head",
    "inputs": [],
    "outputs": [
      {
        "name": "l1Head_",
        "type": "bytes32",
        "internalType": "Hash"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "l2BlockNumber",
    "inputs": [],
    "outputs": [
      {
        "name": "l2BlockNumber_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "l2SequenceNumber",
    "inputs": [],
    "outputs": [
      {
        "name": "l2SequenceNumber_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "maxChallengeDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "maxChallengeDuration_",
        "type": "uint64",
        "internalType": "Duration"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxProveDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "maxProveDuration_",
        "type": "uint64",
        "internalType": "Duration"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "normalModeCredit",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "parentIndex",
    "inputs": [],
    "outputs": [
      {
        "name": "parentIndex_",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "prove",
    "inputs": [
      {
        "name": "proofBytes",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum OPSuccinctFaultDisputeGame.ProposalStatus"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rangeVkeyCommitment",
    "inputs": [],
    "outputs": [
      {
        "name": "rangeVkeyCommitment_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refundModeCredit",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "resolve",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum GameStatus"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolvedAt",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "Timestamp"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rollupConfigHash",
    "inputs": [],
    "outputs": [
      {
        "name": "rollupConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rootClaim",
    "inputs": [],
    "outputs": [
      {
        "name": "rootClaim_",
        "type": "bytes32",
        "internalType": "Claim"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sp1Verifier",
    "inputs": [],
    "outputs": [
      {
        "name": "verifier_",
        "type": "address",
        "internalType": "contract ISP1Verifier"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "startingBlockNumber",
    "inputs": [],
    "outputs": [
      {
        "name": "startingBlockNumber_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "startingOutputRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "root",
        "type": "bytes32",
        "internalType": "Hash"
      },
      {
        "name": "l2SequenceNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "startingRootHash",
    "inputs": [],
    "outputs": [
      {
        "name": "startingRootHash_",
        "type": "bytes32",
        "internalType": "Hash"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "status",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum GameStatus"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "version",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "wasRespectedGameTypeWhenCreated",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "Challenged",
    "inputs": [
      {
        "name": "challenger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameClosed",
    "inputs": [
      {
        "name": "bondDistributionMode",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum BondDistributionMode"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Proved",
    "inputs": [
      {
        "name": "prover",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Resolved",
    "inputs": [
      {
        "name": "status",
        "type": "uint8",
        "indexed": true,
        "internalType": "enum GameStatus"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BadAuth",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BondTransferFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ClaimAlreadyChallenged",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ClaimAlreadyResolved",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GameNotFinalized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GameNotOver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GameOver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncorrectBondAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncorrectDisputeGameFactory",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidBondDistributionMode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidParentGame",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidProposalStatus",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoCreditToClaim",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ParentGameNotResolved",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnexpectedRootClaim",
    "inputs": [
      {
        "name": "rootClaim",
        "type": "bytes32",
        "internalType": "Claim"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod OPSuccinctFaultDisputeGame {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6101e06040523480156200001257600080fd5b506040516200435638038062004356833981810160405281019062000038919062000394565b602a63ffffffff1660c08163ffffffff16815250508967ffffffffffffffff1660808167ffffffffffffffff16815250508867ffffffffffffffff1660a08167ffffffffffffffff16815250508773ffffffffffffffffffffffffffffffffffffffff1660e08173ffffffffffffffffffffffffffffffffffffffff16815250508673ffffffffffffffffffffffffffffffffffffffff166101008173ffffffffffffffffffffffffffffffffffffffff16815250508561012081815250508461014081815250508361016081815250508261018081815250508173ffffffffffffffffffffffffffffffffffffffff166101a08173ffffffffffffffffffffffffffffffffffffffff16815250508073ffffffffffffffffffffffffffffffffffffffff166101c08173ffffffffffffffffffffffffffffffffffffffff1681525050505050505050505050506200048a565b600080fd5b600067ffffffffffffffff82169050919050565b620001b08162000191565b8114620001bc57600080fd5b50565b600081519050620001d081620001a5565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006200020382620001d6565b9050919050565b60006200021782620001f6565b9050919050565b62000229816200020a565b81146200023557600080fd5b50565b60008151905062000249816200021e565b92915050565b60006200025c82620001f6565b9050919050565b6200026e816200024f565b81146200027a57600080fd5b50565b6000815190506200028e8162000263565b92915050565b6000819050919050565b620002a98162000294565b8114620002b557600080fd5b50565b600081519050620002c9816200029e565b92915050565b6000819050919050565b620002e481620002cf565b8114620002f057600080fd5b50565b6000815190506200030481620002d9565b92915050565b60006200031782620001f6565b9050919050565b62000329816200030a565b81146200033557600080fd5b50565b60008151905062000349816200031e565b92915050565b60006200035c82620001f6565b9050919050565b6200036e816200034f565b81146200037a57600080fd5b50565b6000815190506200038e8162000363565b92915050565b6000806000806000806000806000806101408b8d031215620003bb57620003ba6200018c565b5b6000620003cb8d828e01620001bf565b9a50506020620003de8d828e01620001bf565b9950506040620003f18d828e0162000238565b9850506060620004048d828e016200027d565b9750506080620004178d828e01620002b8565b96505060a06200042a8d828e01620002b8565b95505060c06200043d8d828e01620002b8565b94505060e0620004508d828e01620002f3565b935050610100620004648d828e0162000338565b925050610120620004788d828e016200037d565b9150509295989b9194979a5092959850565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c051613d9d620005b960003960008181611cd70152818161292d0152612d6c01526000818161151d0152818161195701528181611a2a01528181611ab101528181611e8501528181611f2601528181611fc70152818161227d0152612665015260008181610e7501528181610efd015281816118150152612a3c01526000818161106c01526111400152600081816111be015261285601526000818161111a015261183d01526000818161118201526114aa015260008181611c6901528181611de001528181612d1c0152612db00152600081816122b90152818161263e01526127380152600081816127600152612b0901526000818161242901526128960152613d9d6000f3fe6080604052600436106102305760003560e01c80636d9a1c8b1161012e578063bdb337d1116100ab578063d2ef73981161006f578063d2ef7398146107f0578063d5d44d801461080e578063f2b4e6171461084b578063fa24f74314610876578063fdcb6068146108a357610230565b8063bdb337d114610707578063c0d8bb7414610732578063c32e4e3e1461076f578063cf09e0d01461079a578063d2177bdd146107c557610230565b80638b85902b116100f25780638b85902b1461063057806399735e321461065b578063bbdc02db14610686578063bcbe5094146106b1578063bcef3b55146106dc57610230565b80636d9a1c8b1461058e57806370872aa5146105b9578063786b844b146105e45780637948690a146105fb5780638129fc1c1461062657610230565b80633ec4d4d6116101bc5780635c0cba33116101805780635c0cba33146104b9578063609d3334146104e457806360e274641461050f5780636361506d1461053857806368ccdc861461056357610230565b80633ec4d4d6146103ca578063529d6a8c146103fa57806352a07fa31461043757806354fd4d501461046257806357da950e1461048d57610230565b80632810e1d6116102035780632810e1d6146102e15780632b31841e1461030c578063375bfa5d14610337578063378dd48c1461037457806337b1b2291461039f57610230565b806319effeb414610235578063200d2ed214610260578063250e69bd1461028b57806325fc2ace146102b6575b600080fd5b34801561024157600080fd5b5061024a6108ce565b6040516102579190612ff2565b60405180910390f35b34801561026c57600080fd5b506102756108e8565b6040516102829190613084565b60405180910390f35b34801561029757600080fd5b506102a06108fb565b6040516102ad91906130ba565b60405180910390f35b3480156102c257600080fd5b506102cb61090e565b6040516102d89190613100565b60405180910390f35b3480156102ed57600080fd5b506102f661091b565b6040516103039190613084565b60405180910390f35b34801561031857600080fd5b50610321611068565b60405161032e919061312a565b60405180910390f35b34801561034357600080fd5b5061035e600480360381019061035991906131b4565b611090565b60405161036b9190613249565b60405180910390f35b34801561038057600080fd5b506103896113cf565b60405161039691906132ac565b60405180910390f35b3480156103ab57600080fd5b506103b46113e2565b6040516103c19190613308565b60405180910390f35b3480156103d657600080fd5b506103df6113f3565b6040516103f196959493929190613351565b60405180910390f35b34801561040657600080fd5b50610421600480360381019061041c91906133de565b61148e565b60405161042e9190613424565b60405180910390f35b34801561044357600080fd5b5061044c6114a6565b6040516104599190613494565b60405180910390f35b34801561046e57600080fd5b506104776114ce565b6040516104849190613548565b60405180910390f35b34801561049957600080fd5b506104a2611507565b6040516104b092919061356a565b60405180910390f35b3480156104c557600080fd5b506104ce611519565b6040516104db91906135b4565b60405180910390f35b3480156104f057600080fd5b506104f9611541565b6040516105069190613624565b60405180910390f35b34801561051b57600080fd5b50610536600480360381019061053191906133de565b611554565b005b34801561054457600080fd5b5061054d611800565b60405161055a9190613100565b60405180910390f35b34801561056f57600080fd5b50610578611811565b6040516105859190613424565b60405180910390f35b34801561059a57600080fd5b506105a3611839565b6040516105b0919061312a565b60405180910390f35b3480156105c557600080fd5b506105ce611861565b6040516105db9190613424565b60405180910390f35b3480156105f057600080fd5b506105f961186e565b005b34801561060757600080fd5b50610610611bf8565b60405161061d9190613646565b60405180910390f35b61062e611c09565b005b34801561063c57600080fd5b50610645612714565b6040516106529190613424565b60405180910390f35b34801561066757600080fd5b50610670612723565b60405161067d9190613424565b60405180910390f35b34801561069257600080fd5b5061069b612734565b6040516106a89190613692565b60405180910390f35b3480156106bd57600080fd5b506106c661275c565b6040516106d391906136bc565b60405180910390f35b3480156106e857600080fd5b506106f1612784565b6040516106fe91906136d7565b60405180910390f35b34801561071357600080fd5b5061071c612795565b60405161072991906130ba565b60405180910390f35b34801561073e57600080fd5b50610759600480360381019061075491906133de565b61283a565b6040516107669190613424565b60405180910390f35b34801561077b57600080fd5b50610784612852565b604051610791919061312a565b60405180910390f35b3480156107a657600080fd5b506107af61287a565b6040516107bc9190612ff2565b60405180910390f35b3480156107d157600080fd5b506107da612892565b6040516107e791906136bc565b60405180910390f35b6107f86128ba565b6040516108059190613249565b60405180910390f35b34801561081a57600080fd5b50610835600480360381019061083091906133de565b612c4d565b6040516108429190613424565b60405180910390f35b34801561085757600080fd5b50610860612d18565b60405161086d9190613713565b60405180910390f35b34801561088257600080fd5b5061088b612d40565b60405161089a9392919061372e565b60405180910390f35b3480156108af57600080fd5b506108b8612d68565b6040516108c5919061378d565b60405180910390f35b600060089054906101000a900467ffffffffffffffff1681565b600060109054906101000a900460ff1681565b600960009054906101000a900460ff1681565b6000600760000154905090565b60008060028111156109305761092f61300d565b5b600060109054906101000a900460ff1660028111156109525761095161300d565b5b14610989576040517ff1a9458100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610993612d90565b9050600060028111156109a9576109a861300d565b5b8160028111156109bc576109bb61300d565b5b036109f3576040517f92c506ae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60016002811115610a0757610a0661300d565b5b816002811115610a1a57610a1961300d565b5b03610ab8576001600060106101000a81548160ff02191690836002811115610a4557610a4461300d565b5b02179055504760056000600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fad565b610ac0612795565b610af6576040517f04643c3900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006004811115610b0a57610b0961300d565b5b600160030160009054906101000a900460ff166004811115610b2f57610b2e61300d565b5b03610baf576002600060106101000a81548160ff02191690836002811115610b5a57610b5961300d565b5b02179055504760056000610b6c6113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fac565b60016004811115610bc357610bc261300d565b5b600160030160009054906101000a900460ff166004811115610be857610be761300d565b5b03610c86576001600060106101000a81548160ff02191690836002811115610c1357610c1261300d565b5b02179055504760056000600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fab565b60026004811115610c9a57610c9961300d565b5b600160030160009054906101000a900460ff166004811115610cbf57610cbe61300d565b5b03610d3f576002600060106101000a81548160ff02191690836002811115610cea57610ce961300d565b5b02179055504760056000610cfc6113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610faa565b60036004811115610d5357610d5261300d565b5b600160030160009054906101000a900460ff166004811115610d7857610d7761300d565b5b03610f77576002600060106101000a81548160ff02191690836002811115610da357610da261300d565b5b0217905550610db06113e2565b73ffffffffffffffffffffffffffffffffffffffff166001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610e735747600560006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610f72565b7f0000000000000000000000000000000000000000000000000000000000000000600560006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f000000000000000000000000000000000000000000000000000000000000000047610f2791906137d7565b60056000610f336113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b610fa9565b6040517f7492a26900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6004600160030160006101000a81548160ff02191690836004811115610fd657610fd561300d565b5b021790555042600060086101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550600060109054906101000a900460ff1660028111156110265761102561300d565b5b7f5e186f09b9c93491f14e277eea7faa5de6a2d4bda75a79af7a3684fbfb42da6060405160405180910390a2600060109054906101000a900460ff1691505090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b600061109a612795565b156110d1576040517fdf469ccb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060e001604052806110e6611800565b81526020016007600001548152602001611106611101612784565b612ed2565b8152602001611113612723565b81526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020013373ffffffffffffffffffffffffffffffffffffffff1681525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166341493c607f0000000000000000000000000000000000000000000000000000000000000000836040516020016111ee91906138c6565b60405160208183030381529060405287876040518563ffffffff1660e01b815260040161121e949392919061391d565b60006040518083038186803b15801561123657600080fd5b505afa15801561124a573d6000803e3d6000fd5b50505050336001800160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff16600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361131d576002600160030160006101000a81548160ff021916908360048111156113135761131261300d565b5b021790555061134c565b6003600160030160006101000a81548160ff021916908360048111156113465761134561300d565b5b02179055505b6001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f5e6565d9ca2f5c8501d6418bf563322a7243ba7ace266d75eac99f4adbb30ba760405160405180910390a2600160030160009054906101000a900460ff1691505092915050565b600960019054906101000a900460ff1681565b60006113ee6000612edc565b905090565b60018060000160009054906101000a900463ffffffff16908060000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060020154908060030160009054906101000a900460ff16908060030160019054906101000a900467ffffffffffffffff16905086565b60056020528060005260406000206000915090505481565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6040518060400160405280600581526020017f322e302e3000000000000000000000000000000000000000000000000000000081525081565b60078060000154908060010154905082565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b606061154f60546024612ef8565b905090565b61155c61186e565b60006002808111156115715761157061300d565b5b600960019054906101000a900460ff1660028111156115935761159261300d565b5b036115df57600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050611694565b600160028111156115f3576115f261300d565b5b600960019054906101000a900460ff1660028111156116155761161461300d565b5b0361166157600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050611693565b6040517f078a3df400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b600081036116ce576040517f17bfe5f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506000600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008273ffffffffffffffffffffffffffffffffffffffff168260405161177e90613995565b60006040518083038185875af1925050503d80600081146117bb576040519150601f19603f3d011682016040523d82523d6000602084013e6117c0565b606091505b50509050806117fb576040517f83e6cc6b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b600061180c6034612f30565b905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000600760010154905090565b6002808111156118815761188061300d565b5b600960019054906101000a900460ff1660028111156118a3576118a261300d565b5b14806118e25750600160028111156118be576118bd61300d565b5b600960019054906101000a900460ff1660028111156118e0576118df61300d565b5b145b611bf657600060028111156118fa576118f961300d565b5b600960019054906101000a900460ff16600281111561191c5761191b61300d565b5b14611953576040517f078a3df400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630314d2b3306040518263ffffffff1660e01b81526004016119ae91906139cb565b602060405180830381865afa1580156119cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ef9190613a12565b905080611a28576040517f4851bd9b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166317cf21a9306040518263ffffffff1660e01b8152600401611a8191906139cb565b600060405180830381600087803b158015611a9b57600080fd5b505af1925050508015611aac575060015b5060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663496b9c16306040518263ffffffff1660e01b8152600401611b0891906139cb565b602060405180830381865afa158015611b25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b499190613a12565b90508015611b81576001600960016101000a81548160ff02191690836002811115611b7757611b7661300d565b5b0217905550611bad565b6002600960016101000a81548160ff02191690836002811115611ba757611ba661300d565b5b02179055505b7f9908eaac0645df9d0704d06adc9e07337c951de2f06b5f2836151d48d5e4722f600960019054906101000a900460ff16604051611beb91906132ac565b60405180910390a150505b565b6000611c046074612f49565b905090565b600060119054906101000a900460ff1615611c50576040517f0dc149f000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614611cd5576040517f940d38c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631d3225e3611d196113e2565b6040518263ffffffff1660e01b8152600401611d359190613308565b602060405180830381865afa158015611d52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d769190613a12565b611dac576040517fd386ef3e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b607e3614611dc257639824bdab6000526004601cfd5b63ffffffff8016611dd1611bf8565b63ffffffff161461227b5760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc611e22611bf8565b6040518263ffffffff1660e01b8152600401611e3e9190613a70565b606060405180830381865afa158015611e5b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e7f9190613b21565b925050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166304e50fed826040518263ffffffff1660e01b8152600401611edc91906139cb565b602060405180830381865afa158015611ef9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f1d9190613a12565b1580611fbf57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166334a346ea826040518263ffffffff1660e01b8152600401611f7d91906139cb565b602060405180830381865afa158015611f9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fbe9190613a12565b5b8061206057507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16635958a193826040518263ffffffff1660e01b815260040161201e91906139cb565b602060405180830381865afa15801561203b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061205f9190613a12565b5b15612097576040517f346119f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405180604001604052806121198373ffffffffffffffffffffffffffffffffffffffff1663bcef3b556040518163ffffffff1660e01b8152600401602060405180830381865afa1580156120f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121149190613ba0565b612ed2565b81526020018273ffffffffffffffffffffffffffffffffffffffff166399735e326040518163ffffffff1660e01b8152600401602060405180830381865afa158015612169573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218d9190613bf9565b81525060076000820151816000015560208201518160010155905050600160028111156121bd576121bc61300d565b5b8173ffffffffffffffffffffffffffffffffffffffff1663200d2ed26040518163ffffffff1660e01b8152600401602060405180830381865afa158015612208573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061222c9190613c4b565b600281111561223e5761223d61300d565b5b03612275576040517f346119f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5061234f565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637258a8077f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b81526004016122f49190613692565b6040805180830381865afa158015612310573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123349190613ca4565b60076000016000600760010160008491905055839190505550505b60076001015461235d612723565b116123a65761236a612784565b6040517ff40239db00000000000000000000000000000000000000000000000000000000815260040161239d91906136d7565b60405180910390fd5b6040518060c001604052806123b9611bf8565b63ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001612406612784565b81526020016000600481111561241f5761241e61300d565b5b81526020016124577f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16612f65565b67ffffffffffffffff164261246c9190613ce4565b67ffffffffffffffff16815250600160008201518160000160006101000a81548163ffffffff021916908363ffffffff16021790555060208201518160000160046101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506060820151816002015560808201518160030160006101000a81548160ff021916908360048111156125655761256461300d565b5b021790555060a08201518160030160016101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055509050506001600060116101000a81548160ff02191690831515021790555034600660006125c46113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461260d9190613ce4565b92505081905550426000806101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f000000000000000000000000000000000000000000000000000000000000000063ffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16633c9f397c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156126ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126f29190613d3a565b63ffffffff1614600960006101000a81548160ff021916908315150217905550565b600061271e612723565b905090565b600061272f6054612f6f565b905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60006127906014612f30565b905090565b60004267ffffffffffffffff166127ce600160030160019054906101000a900467ffffffffffffffff1667ffffffffffffffff16612f88565b67ffffffffffffffff1610806128355750600073ffffffffffffffffffffffffffffffffffffffff166001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b905090565b60066020528060005260406000206000915090505481565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60008054906101000a900467ffffffffffffffff1681565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60008060048111156128cf576128ce61300d565b5b600160030160009054906101000a900460ff1660048111156128f4576128f361300d565b5b1461292b576040517f85c345b000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663ff59ae7d336040518263ffffffff1660e01b81526004016129849190613308565b602060405180830381865afa1580156129a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129c59190613a12565b6129fb576040517fd386ef3e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612a03612795565b15612a3a576040517fdf469ccb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000003414612a93576040517f8620aa1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b33600160000160046101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060018060030160006101000a81548160ff02191690836004811115612aff57612afe61300d565b5b0217905550612b377f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16612f65565b67ffffffffffffffff1642612b4c9190613ce4565b600160030160016101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555034600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254612bc69190613ce4565b92505081905550600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f98027b38153f995c4b802a5c7e6365bee3addb25af6b29818c0c304684d8052c60405160405180910390a2600160030160009054906101000a900460ff16905090565b6000600280811115612c6257612c6161300d565b5b600960019054906101000a900460ff166002811115612c8457612c8361300d565b5b03612cd057600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050612d13565b600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490505b919050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000806060612d4d612734565b9250612d57612784565b9150612d61611541565b9050909192565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b600063ffffffff8016612da1611bf8565b63ffffffff1614612eca5760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc612df2611bf8565b6040518263ffffffff1660e01b8152600401612e0e9190613a70565b606060405180830381865afa158015612e2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e4f9190613b21565b925050508073ffffffffffffffffffffffffffffffffffffffff1663200d2ed26040518163ffffffff1660e01b8152600401602060405180830381865afa158015612e9e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ec29190613c4b565b915050612ecf565b600290505b90565b6000819050919050565b600080612ee7612f92565b90508281013560601c915050919050565b60606000612f04612f92565b905060405191508282528284820160208401378260208301016000815260208101604052505092915050565b600080612f3b612f92565b905082810135915050919050565b600080612f54612f92565b90508281013560e01c915050919050565b6000819050919050565b600080612f7a612f92565b905082810135915050919050565b6000819050919050565b6000600236033560f01c3603905090565b600067ffffffffffffffff82169050919050565b6000819050919050565b6000612fdc612fd7612fd284612fa3565b612fb7565b612fa3565b9050919050565b612fec81612fc1565b82525050565b60006020820190506130076000830184612fe3565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6003811061304d5761304c61300d565b5b50565b600081905061305e8261303c565b919050565b600061306e82613050565b9050919050565b61307e81613063565b82525050565b60006020820190506130996000830184613075565b92915050565b60008115159050919050565b6130b48161309f565b82525050565b60006020820190506130cf60008301846130ab565b92915050565b6000819050919050565b60006130ea826130d5565b9050919050565b6130fa816130df565b82525050565b600060208201905061311560008301846130f1565b92915050565b613124816130d5565b82525050565b600060208201905061313f600083018461311b565b92915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126131745761317361314f565b5b8235905067ffffffffffffffff81111561319157613190613154565b5b6020830191508360018202830111156131ad576131ac613159565b5b9250929050565b600080602083850312156131cb576131ca613145565b5b600083013567ffffffffffffffff8111156131e9576131e861314a565b5b6131f58582860161315e565b92509250509250929050565b600581106132125761321161300d565b5b50565b600081905061322382613201565b919050565b600061323382613215565b9050919050565b61324381613228565b82525050565b600060208201905061325e600083018461323a565b92915050565b600381106132755761327461300d565b5b50565b600081905061328682613264565b919050565b600061329682613278565b9050919050565b6132a68161328b565b82525050565b60006020820190506132c1600083018461329d565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006132f2826132c7565b9050919050565b613302816132e7565b82525050565b600060208201905061331d60008301846132f9565b92915050565b600063ffffffff82169050919050565b61333c81613323565b82525050565b61334b816130df565b82525050565b600060c0820190506133666000830189613333565b61337360208301886132f9565b61338060408301876132f9565b61338d6060830186613342565b61339a608083018561323a565b6133a760a0830184612fe3565b979650505050505050565b6133bb816132e7565b81146133c657600080fd5b50565b6000813590506133d8816133b2565b92915050565b6000602082840312156133f4576133f3613145565b5b6000613402848285016133c9565b91505092915050565b6000819050919050565b61341e8161340b565b82525050565b60006020820190506134396000830184613415565b92915050565b600061345a613455613450846132c7565b612fb7565b6132c7565b9050919050565b600061346c8261343f565b9050919050565b600061347e82613461565b9050919050565b61348e81613473565b82525050565b60006020820190506134a96000830184613485565b92915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156134e95780820151818401526020810190506134ce565b838111156134f8576000848401525b50505050565b6000601f19601f8301169050919050565b600061351a826134af565b61352481856134ba565b93506135348185602086016134cb565b61353d816134fe565b840191505092915050565b60006020820190508181036000830152613562818461350f565b905092915050565b600060408201905061357f60008301856130f1565b61358c6020830184613415565b9392505050565b600061359e82613461565b9050919050565b6135ae81613593565b82525050565b60006020820190506135c960008301846135a5565b92915050565b600081519050919050565b600082825260208201905092915050565b60006135f6826135cf565b61360081856135da565b93506136108185602086016134cb565b613619816134fe565b840191505092915050565b6000602082019050818103600083015261363e81846135eb565b905092915050565b600060208201905061365b6000830184613333565b92915050565b600061367c61367761367284613323565b612fb7565b613323565b9050919050565b61368c81613661565b82525050565b60006020820190506136a76000830184613683565b92915050565b6136b681612fc1565b82525050565b60006020820190506136d160008301846136ad565b92915050565b60006020820190506136ec6000830184613342565b92915050565b60006136fd82613461565b9050919050565b61370d816136f2565b82525050565b60006020820190506137286000830184613704565b92915050565b60006060820190506137436000830186613683565b6137506020830185613342565b818103604083015261376281846135eb565b9050949350505050565b600061377782613461565b9050919050565b6137878161376c565b82525050565b60006020820190506137a2600083018461377e565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006137e28261340b565b91506137ed8361340b565b925082821015613800576137ff6137a8565b5b828203905092915050565b613814816130d5565b82525050565b6138238161340b565b82525050565b613832816132e7565b82525050565b60e08201600082015161384e600085018261380b565b506020820151613861602085018261380b565b506040820151613874604085018261380b565b506060820151613887606085018261381a565b50608082015161389a608085018261380b565b5060a08201516138ad60a085018261380b565b5060c08201516138c060c0850182613829565b50505050565b600060e0820190506138db6000830184613838565b92915050565b82818337600083830152505050565b60006138fc83856135da565b93506139098385846138e1565b613912836134fe565b840190509392505050565b6000606082019050613932600083018761311b565b818103602083015261394481866135eb565b905081810360408301526139598184866138f0565b905095945050505050565b600081905092915050565b50565b600061397f600083613964565b915061398a8261396f565b600082019050919050565b60006139a082613972565b9150819050919050565b60006139b582613461565b9050919050565b6139c5816139aa565b82525050565b60006020820190506139e060008301846139bc565b92915050565b6139ef8161309f565b81146139fa57600080fd5b50565b600081519050613a0c816139e6565b92915050565b600060208284031215613a2857613a27613145565b5b6000613a36848285016139fd565b91505092915050565b6000613a5a613a55613a5084613323565b612fb7565b61340b565b9050919050565b613a6a81613a3f565b82525050565b6000602082019050613a856000830184613a61565b92915050565b613a9481613323565b8114613a9f57600080fd5b50565b600081519050613ab181613a8b565b92915050565b613ac081612fa3565b8114613acb57600080fd5b50565b600081519050613add81613ab7565b92915050565b6000613aee826132e7565b9050919050565b613afe81613ae3565b8114613b0957600080fd5b50565b600081519050613b1b81613af5565b92915050565b600080600060608486031215613b3a57613b39613145565b5b6000613b4886828701613aa2565b9350506020613b5986828701613ace565b9250506040613b6a86828701613b0c565b9150509250925092565b613b7d816130d5565b8114613b8857600080fd5b50565b600081519050613b9a81613b74565b92915050565b600060208284031215613bb657613bb5613145565b5b6000613bc484828501613b8b565b91505092915050565b613bd68161340b565b8114613be157600080fd5b50565b600081519050613bf381613bcd565b92915050565b600060208284031215613c0f57613c0e613145565b5b6000613c1d84828501613be4565b91505092915050565b60038110613c3357600080fd5b50565b600081519050613c4581613c26565b92915050565b600060208284031215613c6157613c60613145565b5b6000613c6f84828501613c36565b91505092915050565b613c81816130d5565b8114613c8c57600080fd5b50565b600081519050613c9e81613c78565b92915050565b60008060408385031215613cbb57613cba613145565b5b6000613cc985828601613c8f565b9250506020613cda85828601613be4565b9150509250929050565b6000613cef8261340b565b9150613cfa8361340b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115613d2f57613d2e6137a8565b5b828201905092915050565b600060208284031215613d5057613d4f613145565b5b6000613d5e84828501613aa2565b9150509291505056fea2646970667358221220aefefb0236aae99757411ba6b4ae7ce9ed506859fb90aa9bb6397f262eefaf1b64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\xE0`@R4\x80\x15b\0\0\x12W`\0\x80\xFD[P`@Qb\0CV8\x03\x80b\0CV\x839\x81\x81\x01`@R\x81\x01\x90b\0\08\x91\x90b\0\x03\x94V[`*c\xFF\xFF\xFF\xFF\x16`\xC0\x81c\xFF\xFF\xFF\xFF\x16\x81RPP\x89g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x88g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xA0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xE0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01\0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x85a\x01 \x81\x81RPP\x84a\x01@\x81\x81RPP\x83a\x01`\x81\x81RPP\x82a\x01\x80\x81\x81RPP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01\xA0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01\xC0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPPPPPPPPPPPb\0\x04\x8AV[`\0\x80\xFD[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xB0\x81b\0\x01\x91V[\x81\x14b\0\x01\xBCW`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x01\xD0\x81b\0\x01\xA5V[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0b\0\x02\x03\x82b\0\x01\xD6V[\x90P\x91\x90PV[`\0b\0\x02\x17\x82b\0\x01\xF6V[\x90P\x91\x90PV[b\0\x02)\x81b\0\x02\nV[\x81\x14b\0\x025W`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x02I\x81b\0\x02\x1EV[\x92\x91PPV[`\0b\0\x02\\\x82b\0\x01\xF6V[\x90P\x91\x90PV[b\0\x02n\x81b\0\x02OV[\x81\x14b\0\x02zW`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x02\x8E\x81b\0\x02cV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[b\0\x02\xA9\x81b\0\x02\x94V[\x81\x14b\0\x02\xB5W`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x02\xC9\x81b\0\x02\x9EV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[b\0\x02\xE4\x81b\0\x02\xCFV[\x81\x14b\0\x02\xF0W`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x03\x04\x81b\0\x02\xD9V[\x92\x91PPV[`\0b\0\x03\x17\x82b\0\x01\xF6V[\x90P\x91\x90PV[b\0\x03)\x81b\0\x03\nV[\x81\x14b\0\x035W`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x03I\x81b\0\x03\x1EV[\x92\x91PPV[`\0b\0\x03\\\x82b\0\x01\xF6V[\x90P\x91\x90PV[b\0\x03n\x81b\0\x03OV[\x81\x14b\0\x03zW`\0\x80\xFD[PV[`\0\x81Q\x90Pb\0\x03\x8E\x81b\0\x03cV[\x92\x91PPV[`\0\x80`\0\x80`\0\x80`\0\x80`\0\x80a\x01@\x8B\x8D\x03\x12\x15b\0\x03\xBBWb\0\x03\xBAb\0\x01\x8CV[[`\0b\0\x03\xCB\x8D\x82\x8E\x01b\0\x01\xBFV[\x9APP` b\0\x03\xDE\x8D\x82\x8E\x01b\0\x01\xBFV[\x99PP`@b\0\x03\xF1\x8D\x82\x8E\x01b\0\x028V[\x98PP``b\0\x04\x04\x8D\x82\x8E\x01b\0\x02}V[\x97PP`\x80b\0\x04\x17\x8D\x82\x8E\x01b\0\x02\xB8V[\x96PP`\xA0b\0\x04*\x8D\x82\x8E\x01b\0\x02\xB8V[\x95PP`\xC0b\0\x04=\x8D\x82\x8E\x01b\0\x02\xB8V[\x94PP`\xE0b\0\x04P\x8D\x82\x8E\x01b\0\x02\xF3V[\x93PPa\x01\0b\0\x04d\x8D\x82\x8E\x01b\0\x038V[\x92PPa\x01 b\0\x04x\x8D\x82\x8E\x01b\0\x03}V[\x91PP\x92\x95\x98\x9B\x91\x94\x97\x9AP\x92\x95\x98PV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xA0Qa\x01\xC0Qa=\x9Db\0\x05\xB9`\09`\0\x81\x81a\x1C\xD7\x01R\x81\x81a)-\x01Ra-l\x01R`\0\x81\x81a\x15\x1D\x01R\x81\x81a\x19W\x01R\x81\x81a\x1A*\x01R\x81\x81a\x1A\xB1\x01R\x81\x81a\x1E\x85\x01R\x81\x81a\x1F&\x01R\x81\x81a\x1F\xC7\x01R\x81\x81a\"}\x01Ra&e\x01R`\0\x81\x81a\x0Eu\x01R\x81\x81a\x0E\xFD\x01R\x81\x81a\x18\x15\x01Ra*<\x01R`\0\x81\x81a\x10l\x01Ra\x11@\x01R`\0\x81\x81a\x11\xBE\x01Ra(V\x01R`\0\x81\x81a\x11\x1A\x01Ra\x18=\x01R`\0\x81\x81a\x11\x82\x01Ra\x14\xAA\x01R`\0\x81\x81a\x1Ci\x01R\x81\x81a\x1D\xE0\x01R\x81\x81a-\x1C\x01Ra-\xB0\x01R`\0\x81\x81a\"\xB9\x01R\x81\x81a&>\x01Ra'8\x01R`\0\x81\x81a'`\x01Ra+\t\x01R`\0\x81\x81a$)\x01Ra(\x96\x01Ra=\x9D`\0\xF3\xFE`\x80`@R`\x046\x10a\x020W`\x005`\xE0\x1C\x80cm\x9A\x1C\x8B\x11a\x01.W\x80c\xBD\xB37\xD1\x11a\0\xABW\x80c\xD2\xEFs\x98\x11a\0oW\x80c\xD2\xEFs\x98\x14a\x07\xF0W\x80c\xD5\xD4M\x80\x14a\x08\x0EW\x80c\xF2\xB4\xE6\x17\x14a\x08KW\x80c\xFA$\xF7C\x14a\x08vW\x80c\xFD\xCB`h\x14a\x08\xA3Wa\x020V[\x80c\xBD\xB37\xD1\x14a\x07\x07W\x80c\xC0\xD8\xBBt\x14a\x072W\x80c\xC3.N>\x14a\x07oW\x80c\xCF\t\xE0\xD0\x14a\x07\x9AW\x80c\xD2\x17{\xDD\x14a\x07\xC5Wa\x020V[\x80c\x8B\x85\x90+\x11a\0\xF2W\x80c\x8B\x85\x90+\x14a\x060W\x80c\x99s^2\x14a\x06[W\x80c\xBB\xDC\x02\xDB\x14a\x06\x86W\x80c\xBC\xBEP\x94\x14a\x06\xB1W\x80c\xBC\xEF;U\x14a\x06\xDCWa\x020V[\x80cm\x9A\x1C\x8B\x14a\x05\x8EW\x80cp\x87*\xA5\x14a\x05\xB9W\x80cxk\x84K\x14a\x05\xE4W\x80cyHi\n\x14a\x05\xFBW\x80c\x81)\xFC\x1C\x14a\x06&Wa\x020V[\x80c>\xC4\xD4\xD6\x11a\x01\xBCW\x80c\\\x0C\xBA3\x11a\x01\x80W\x80c\\\x0C\xBA3\x14a\x04\xB9W\x80c`\x9D34\x14a\x04\xE4W\x80c`\xE2td\x14a\x05\x0FW\x80ccaPm\x14a\x058W\x80ch\xCC\xDC\x86\x14a\x05cWa\x020V[\x80c>\xC4\xD4\xD6\x14a\x03\xCAW\x80cR\x9Dj\x8C\x14a\x03\xFAW\x80cR\xA0\x7F\xA3\x14a\x047W\x80cT\xFDMP\x14a\x04bW\x80cW\xDA\x95\x0E\x14a\x04\x8DWa\x020V[\x80c(\x10\xE1\xD6\x11a\x02\x03W\x80c(\x10\xE1\xD6\x14a\x02\xE1W\x80c+1\x84\x1E\x14a\x03\x0CW\x80c7[\xFA]\x14a\x037W\x80c7\x8D\xD4\x8C\x14a\x03tW\x80c7\xB1\xB2)\x14a\x03\x9FWa\x020V[\x80c\x19\xEF\xFE\xB4\x14a\x025W\x80c \r.\xD2\x14a\x02`W\x80c%\x0Ei\xBD\x14a\x02\x8BW\x80c%\xFC*\xCE\x14a\x02\xB6W[`\0\x80\xFD[4\x80\x15a\x02AW`\0\x80\xFD[Pa\x02Ja\x08\xCEV[`@Qa\x02W\x91\x90a/\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02lW`\0\x80\xFD[Pa\x02ua\x08\xE8V[`@Qa\x02\x82\x91\x90a0\x84V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x97W`\0\x80\xFD[Pa\x02\xA0a\x08\xFBV[`@Qa\x02\xAD\x91\x90a0\xBAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xC2W`\0\x80\xFD[Pa\x02\xCBa\t\x0EV[`@Qa\x02\xD8\x91\x90a1\0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xEDW`\0\x80\xFD[Pa\x02\xF6a\t\x1BV[`@Qa\x03\x03\x91\x90a0\x84V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x18W`\0\x80\xFD[Pa\x03!a\x10hV[`@Qa\x03.\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03CW`\0\x80\xFD[Pa\x03^`\x04\x806\x03\x81\x01\x90a\x03Y\x91\x90a1\xB4V[a\x10\x90V[`@Qa\x03k\x91\x90a2IV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x80W`\0\x80\xFD[Pa\x03\x89a\x13\xCFV[`@Qa\x03\x96\x91\x90a2\xACV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xABW`\0\x80\xFD[Pa\x03\xB4a\x13\xE2V[`@Qa\x03\xC1\x91\x90a3\x08V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD6W`\0\x80\xFD[Pa\x03\xDFa\x13\xF3V[`@Qa\x03\xF1\x96\x95\x94\x93\x92\x91\x90a3QV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x06W`\0\x80\xFD[Pa\x04!`\x04\x806\x03\x81\x01\x90a\x04\x1C\x91\x90a3\xDEV[a\x14\x8EV[`@Qa\x04.\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04CW`\0\x80\xFD[Pa\x04La\x14\xA6V[`@Qa\x04Y\x91\x90a4\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04nW`\0\x80\xFD[Pa\x04wa\x14\xCEV[`@Qa\x04\x84\x91\x90a5HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x99W`\0\x80\xFD[Pa\x04\xA2a\x15\x07V[`@Qa\x04\xB0\x92\x91\x90a5jV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xC5W`\0\x80\xFD[Pa\x04\xCEa\x15\x19V[`@Qa\x04\xDB\x91\x90a5\xB4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF0W`\0\x80\xFD[Pa\x04\xF9a\x15AV[`@Qa\x05\x06\x91\x90a6$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x1BW`\0\x80\xFD[Pa\x056`\x04\x806\x03\x81\x01\x90a\x051\x91\x90a3\xDEV[a\x15TV[\0[4\x80\x15a\x05DW`\0\x80\xFD[Pa\x05Ma\x18\0V[`@Qa\x05Z\x91\x90a1\0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05oW`\0\x80\xFD[Pa\x05xa\x18\x11V[`@Qa\x05\x85\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x9AW`\0\x80\xFD[Pa\x05\xA3a\x189V[`@Qa\x05\xB0\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xC5W`\0\x80\xFD[Pa\x05\xCEa\x18aV[`@Qa\x05\xDB\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF0W`\0\x80\xFD[Pa\x05\xF9a\x18nV[\0[4\x80\x15a\x06\x07W`\0\x80\xFD[Pa\x06\x10a\x1B\xF8V[`@Qa\x06\x1D\x91\x90a6FV[`@Q\x80\x91\x03\x90\xF3[a\x06.a\x1C\tV[\0[4\x80\x15a\x06<W`\0\x80\xFD[Pa\x06Ea'\x14V[`@Qa\x06R\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06gW`\0\x80\xFD[Pa\x06pa'#V[`@Qa\x06}\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x92W`\0\x80\xFD[Pa\x06\x9Ba'4V[`@Qa\x06\xA8\x91\x90a6\x92V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xBDW`\0\x80\xFD[Pa\x06\xC6a'\\V[`@Qa\x06\xD3\x91\x90a6\xBCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xE8W`\0\x80\xFD[Pa\x06\xF1a'\x84V[`@Qa\x06\xFE\x91\x90a6\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x13W`\0\x80\xFD[Pa\x07\x1Ca'\x95V[`@Qa\x07)\x91\x90a0\xBAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07>W`\0\x80\xFD[Pa\x07Y`\x04\x806\x03\x81\x01\x90a\x07T\x91\x90a3\xDEV[a(:V[`@Qa\x07f\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07{W`\0\x80\xFD[Pa\x07\x84a(RV[`@Qa\x07\x91\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA6W`\0\x80\xFD[Pa\x07\xAFa(zV[`@Qa\x07\xBC\x91\x90a/\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xD1W`\0\x80\xFD[Pa\x07\xDAa(\x92V[`@Qa\x07\xE7\x91\x90a6\xBCV[`@Q\x80\x91\x03\x90\xF3[a\x07\xF8a(\xBAV[`@Qa\x08\x05\x91\x90a2IV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x1AW`\0\x80\xFD[Pa\x085`\x04\x806\x03\x81\x01\x90a\x080\x91\x90a3\xDEV[a,MV[`@Qa\x08B\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08WW`\0\x80\xFD[Pa\x08`a-\x18V[`@Qa\x08m\x91\x90a7\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x82W`\0\x80\xFD[Pa\x08\x8Ba-@V[`@Qa\x08\x9A\x93\x92\x91\x90a7.V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xAFW`\0\x80\xFD[Pa\x08\xB8a-hV[`@Qa\x08\xC5\x91\x90a7\x8DV[`@Q\x80\x91\x03\x90\xF3[`\0`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\t`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0`\x07`\0\x01T\x90P\x90V[`\0\x80`\x02\x81\x11\x15a\t0Wa\t/a0\rV[[`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\tRWa\tQa0\rV[[\x14a\t\x89W`@Q\x7F\xF1\xA9E\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0a\t\x93a-\x90V[\x90P`\0`\x02\x81\x11\x15a\t\xA9Wa\t\xA8a0\rV[[\x81`\x02\x81\x11\x15a\t\xBCWa\t\xBBa0\rV[[\x03a\t\xF3W`@Q\x7F\x92\xC5\x06\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x02\x81\x11\x15a\n\x07Wa\n\x06a0\rV[[\x81`\x02\x81\x11\x15a\n\x1AWa\n\x19a0\rV[[\x03a\n\xB8W`\x01`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\nEWa\nDa0\rV[[\x02\x17\x90UPG`\x05`\0`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xADV[a\n\xC0a'\x95V[a\n\xF6W`@Q\x7F\x04d<9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x04\x81\x11\x15a\x0B\nWa\x0B\ta0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0B/Wa\x0B.a0\rV[[\x03a\x0B\xAFW`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0BZWa\x0BYa0\rV[[\x02\x17\x90UPG`\x05`\0a\x0Bla\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xACV[`\x01`\x04\x81\x11\x15a\x0B\xC3Wa\x0B\xC2a0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0B\xE8Wa\x0B\xE7a0\rV[[\x03a\x0C\x86W`\x01`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0C\x13Wa\x0C\x12a0\rV[[\x02\x17\x90UPG`\x05`\0`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xABV[`\x02`\x04\x81\x11\x15a\x0C\x9AWa\x0C\x99a0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0C\xBFWa\x0C\xBEa0\rV[[\x03a\r?W`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0C\xEAWa\x0C\xE9a0\rV[[\x02\x17\x90UPG`\x05`\0a\x0C\xFCa\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xAAV[`\x03`\x04\x81\x11\x15a\rSWa\rRa0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\rxWa\rwa0\rV[[\x03a\x0FwW`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\r\xA3Wa\r\xA2a0\rV[[\x02\x17\x90UPa\r\xB0a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0EsWG`\x05`\0`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0FrV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x05`\0`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Ga\x0F'\x91\x90a7\xD7V[`\x05`\0a\x0F3a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP[a\x0F\xA9V[`@Q\x7Ft\x92\xA2i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[`\x04`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x0F\xD6Wa\x0F\xD5a0\rV[[\x02\x17\x90UPB`\0`\x08a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x10&Wa\x10%a0\rV[[\x7F^\x18o\t\xB9\xC94\x91\xF1N'~\xEA\x7F\xAA]\xE6\xA2\xD4\xBD\xA7Zy\xAFz6\x84\xFB\xFBB\xDA``@Q`@Q\x80\x91\x03\x90\xA2`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0a\x10\x9Aa'\x95V[\x15a\x10\xD1W`@Q\x7F\xDFF\x9C\xCB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`@Q\x80`\xE0\x01`@R\x80a\x10\xE6a\x18\0V[\x81R` \x01`\x07`\0\x01T\x81R` \x01a\x11\x06a\x11\x01a'\x84V[a.\xD2V[\x81R` \x01a\x11\x13a'#V[\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cAI<`\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`@Q` \x01a\x11\xEE\x91\x90a8\xC6V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x87\x87`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\x1E\x94\x93\x92\x91\x90a9\x1DV[`\0`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x126W`\0\x80\xFD[PZ\xFA\x15\x80\x15a\x12JW=`\0\x80>=`\0\xFD[PPPP3`\x01\x80\x01`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13\x1DW`\x02`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x13\x13Wa\x13\x12a0\rV[[\x02\x17\x90UPa\x13LV[`\x03`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x13FWa\x13Ea0\rV[[\x02\x17\x90UP[`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F^ee\xD9\xCA/\\\x85\x01\xD6A\x8B\xF5c2*rC\xBAz\xCE&mu\xEA\xC9\x9FJ\xDB\xB3\x0B\xA7`@Q`@Q\x80\x91\x03\x90\xA2`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x92\x91PPV[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0a\x13\xEE`\0a.\xDCV[\x90P\x90V[`\x01\x80`\0\x01`\0\x90T\x90a\x01\0\n\x90\x04c\xFF\xFF\xFF\xFF\x16\x90\x80`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x01\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x02\x01T\x90\x80`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90\x80`\x03\x01`\x01\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x86V[`\x05` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F2.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\x07\x80`\0\x01T\x90\x80`\x01\x01T\x90P\x82V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[``a\x15O`T`$a.\xF8V[\x90P\x90V[a\x15\\a\x18nV[`\0`\x02\x80\x81\x11\x15a\x15qWa\x15pa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x15\x93Wa\x15\x92a0\rV[[\x03a\x15\xDFW`\x06`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa\x16\x94V[`\x01`\x02\x81\x11\x15a\x15\xF3Wa\x15\xF2a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x16\x15Wa\x16\x14a0\rV[[\x03a\x16aW`\x05`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa\x16\x93V[`@Q\x7F\x07\x8A=\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[`\0\x81\x03a\x16\xCEW`@Q\x7F\x17\xBF\xE5\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x06`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`\0`\x05`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`\0\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Qa\x17~\x90a9\x95V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x17\xBBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x17\xC0V[``\x91P[PP\x90P\x80a\x17\xFBW`@Q\x7F\x83\xE6\xCCk\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPV[`\0a\x18\x0C`4a/0V[\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0`\x07`\x01\x01T\x90P\x90V[`\x02\x80\x81\x11\x15a\x18\x81Wa\x18\x80a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x18\xA3Wa\x18\xA2a0\rV[[\x14\x80a\x18\xE2WP`\x01`\x02\x81\x11\x15a\x18\xBEWa\x18\xBDa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x18\xE0Wa\x18\xDFa0\rV[[\x14[a\x1B\xF6W`\0`\x02\x81\x11\x15a\x18\xFAWa\x18\xF9a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x19\x1CWa\x19\x1Ba0\rV[[\x14a\x19SW`@Q\x7F\x07\x8A=\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x03\x14\xD2\xB30`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\xAE\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xCBW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xEF\x91\x90a:\x12V[\x90P\x80a\x1A(W`@Q\x7FHQ\xBD\x9B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x17\xCF!\xA90`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A\x81\x91\x90a9\xCBV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x1A\x9BW`\0\x80\xFD[PZ\xF1\x92PPP\x80\x15a\x1A\xACWP`\x01[P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cIk\x9C\x160`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1B\x08\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B%W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1BI\x91\x90a:\x12V[\x90P\x80\x15a\x1B\x81W`\x01`\t`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x1BwWa\x1Bva0\rV[[\x02\x17\x90UPa\x1B\xADV[`\x02`\t`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x1B\xA7Wa\x1B\xA6a0\rV[[\x02\x17\x90UP[\x7F\x99\x08\xEA\xAC\x06E\xDF\x9D\x07\x04\xD0j\xDC\x9E\x073|\x95\x1D\xE2\xF0k_(6\x15\x1DH\xD5\xE4r/`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`@Qa\x1B\xEB\x91\x90a2\xACV[`@Q\x80\x91\x03\x90\xA1PP[V[`\0a\x1C\x04`ta/IV[\x90P\x90V[`\0`\x11\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x1CPW`@Q\x7F\r\xC1I\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\xD5W`@Q\x7F\x94\r8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1D2%\xE3a\x1D\x19a\x13\xE2V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D5\x91\x90a3\x08V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1DRW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1Dv\x91\x90a:\x12V[a\x1D\xACW`@Q\x7F\xD3\x86\xEF>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`~6\x14a\x1D\xC2Wc\x98$\xBD\xAB`\0R`\x04`\x1C\xFD[c\xFF\xFF\xFF\xFF\x80\x16a\x1D\xD1a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x14a\"{W`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFCa\x1E\"a\x1B\xF8V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1E>\x91\x90a:pV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1E[W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1E\x7F\x91\x90a;!V[\x92PPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x04\xE5\x0F\xED\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1E\xDC\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1E\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\x1D\x91\x90a:\x12V[\x15\x80a\x1F\xBFWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\xA3F\xEA\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F}\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1F\x9AW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\xBE\x91\x90a:\x12V[[\x80a `WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cYX\xA1\x93\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a \x1E\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a ;W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a _\x91\x90a:\x12V[[\x15a \x97W`@Q\x7F4a\x19\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80a!\x19\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBC\xEF;U`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a \xF0W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\x14\x91\x90a;\xA0V[a.\xD2V[\x81R` \x01\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x99s^2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a!iW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\x8D\x91\x90a;\xF9V[\x81RP`\x07`\0\x82\x01Q\x81`\0\x01U` \x82\x01Q\x81`\x01\x01U\x90PP`\x01`\x02\x81\x11\x15a!\xBDWa!\xBCa0\rV[[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c \r.\xD2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\"\x08W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\",\x91\x90a<KV[`\x02\x81\x11\x15a\">Wa\"=a0\rV[[\x03a\"uW`@Q\x7F4a\x19\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[Pa#OV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16crX\xA8\x07\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\"\xF4\x91\x90a6\x92V[`@\x80Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a#\x10W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#4\x91\x90a<\xA4V[`\x07`\0\x01`\0`\x07`\x01\x01`\0\x84\x91\x90PU\x83\x91\x90PUPP[`\x07`\x01\x01Ta#]a'#V[\x11a#\xA6Wa#ja'\x84V[`@Q\x7F\xF4\x029\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\x9D\x91\x90a6\xD7V[`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xC0\x01`@R\x80a#\xB9a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x81R` \x01`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01a$\x06a'\x84V[\x81R` \x01`\0`\x04\x81\x11\x15a$\x1FWa$\x1Ea0\rV[[\x81R` \x01a$W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/eV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba$l\x91\x90a<\xE4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`\x01`\0\x82\x01Q\x81`\0\x01`\0a\x01\0\n\x81T\x81c\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83c\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\0\x01`\x04a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x01\x01`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP``\x82\x01Q\x81`\x02\x01U`\x80\x82\x01Q\x81`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a%eWa%da0\rV[[\x02\x17\x90UP`\xA0\x82\x01Q\x81`\x03\x01`\x01a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x90PP`\x01`\0`\x11a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP4`\x06`\0a%\xC4a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x82\x82Ta&\r\x91\x90a<\xE4V[\x92PP\x81\x90UPB`\0\x80a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x9F9|`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&\xCEW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\xF2\x91\x90a=:V[c\xFF\xFF\xFF\xFF\x16\x14`\t`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPV[`\0a'\x1Ea'#V[\x90P\x90V[`\0a'/`Ta/oV[\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0a'\x90`\x14a/0V[\x90P\x90V[`\0Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a'\xCE`\x01`\x03\x01`\x01\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\x88V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x80a(5WP`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x90P\x90V[`\x06` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80`\x04\x81\x11\x15a(\xCFWa(\xCEa0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a(\xF4Wa(\xF3a0\rV[[\x14a)+W`@Q\x7F\x85\xC3E\xB0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFFY\xAE}3`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)\x84\x91\x90a3\x08V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a)\xA1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a)\xC5\x91\x90a:\x12V[a)\xFBW`@Q\x7F\xD3\x86\xEF>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a*\x03a'\x95V[\x15a*:W`@Q\x7F\xDFF\x9C\xCB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x004\x14a*\x93W`@Q\x7F\x86 \xAA\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3`\x01`\0\x01`\x04a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x80`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a*\xFFWa*\xFEa0\rV[[\x02\x17\x90UPa+7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/eV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba+L\x91\x90a<\xE4V[`\x01`\x03\x01`\x01a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP4`\x06`\x003s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x82\x82Ta+\xC6\x91\x90a<\xE4V[\x92PP\x81\x90UP`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x98\x02{8\x15?\x99\\K\x80*\\~ce\xBE\xE3\xAD\xDB%\xAFk)\x81\x8C\x0C0F\x84\xD8\x05,`@Q`@Q\x80\x91\x03\x90\xA2`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[`\0`\x02\x80\x81\x11\x15a,bWa,aa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a,\x84Wa,\x83a0\rV[[\x03a,\xD0W`\x06`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa-\x13V[`\x05`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90P[\x91\x90PV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80``a-Ma'4V[\x92Pa-Wa'\x84V[\x91Pa-aa\x15AV[\x90P\x90\x91\x92V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0c\xFF\xFF\xFF\xFF\x80\x16a-\xA1a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x14a.\xCAW`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFCa-\xF2a\x1B\xF8V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\x0E\x91\x90a:pV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.+W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.O\x91\x90a;!V[\x92PPP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c \r.\xD2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.\x9EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\xC2\x91\x90a<KV[\x91PPa.\xCFV[`\x02\x90P[\x90V[`\0\x81\x90P\x91\x90PV[`\0\x80a.\xE7a/\x92V[\x90P\x82\x81\x015``\x1C\x91PP\x91\x90PV[```\0a/\x04a/\x92V[\x90P`@Q\x91P\x82\x82R\x82\x84\x82\x01` \x84\x017\x82` \x83\x01\x01`\0\x81R` \x81\x01`@RPP\x92\x91PPV[`\0\x80a/;a/\x92V[\x90P\x82\x81\x015\x91PP\x91\x90PV[`\0\x80a/Ta/\x92V[\x90P\x82\x81\x015`\xE0\x1C\x91PP\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0\x80a/za/\x92V[\x90P\x82\x81\x015\x91PP\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0`\x026\x035`\xF0\x1C6\x03\x90P\x90V[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0a/\xDCa/\xD7a/\xD2\x84a/\xA3V[a/\xB7V[a/\xA3V[\x90P\x91\x90PV[a/\xEC\x81a/\xC1V[\x82RPPV[`\0` \x82\x01\x90Pa0\x07`\0\x83\x01\x84a/\xE3V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`!`\x04R`$`\0\xFD[`\x03\x81\x10a0MWa0La0\rV[[PV[`\0\x81\x90Pa0^\x82a0<V[\x91\x90PV[`\0a0n\x82a0PV[\x90P\x91\x90PV[a0~\x81a0cV[\x82RPPV[`\0` \x82\x01\x90Pa0\x99`\0\x83\x01\x84a0uV[\x92\x91PPV[`\0\x81\x15\x15\x90P\x91\x90PV[a0\xB4\x81a0\x9FV[\x82RPPV[`\0` \x82\x01\x90Pa0\xCF`\0\x83\x01\x84a0\xABV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a0\xEA\x82a0\xD5V[\x90P\x91\x90PV[a0\xFA\x81a0\xDFV[\x82RPPV[`\0` \x82\x01\x90Pa1\x15`\0\x83\x01\x84a0\xF1V[\x92\x91PPV[a1$\x81a0\xD5V[\x82RPPV[`\0` \x82\x01\x90Pa1?`\0\x83\x01\x84a1\x1BV[\x92\x91PPV[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\x83`\x1F\x84\x01\x12a1tWa1sa1OV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\x91Wa1\x90a1TV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a1\xADWa1\xACa1YV[[\x92P\x92\x90PV[`\0\x80` \x83\x85\x03\x12\x15a1\xCBWa1\xCAa1EV[[`\0\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xE9Wa1\xE8a1JV[[a1\xF5\x85\x82\x86\x01a1^V[\x92P\x92PP\x92P\x92\x90PV[`\x05\x81\x10a2\x12Wa2\x11a0\rV[[PV[`\0\x81\x90Pa2#\x82a2\x01V[\x91\x90PV[`\0a23\x82a2\x15V[\x90P\x91\x90PV[a2C\x81a2(V[\x82RPPV[`\0` \x82\x01\x90Pa2^`\0\x83\x01\x84a2:V[\x92\x91PPV[`\x03\x81\x10a2uWa2ta0\rV[[PV[`\0\x81\x90Pa2\x86\x82a2dV[\x91\x90PV[`\0a2\x96\x82a2xV[\x90P\x91\x90PV[a2\xA6\x81a2\x8BV[\x82RPPV[`\0` \x82\x01\x90Pa2\xC1`\0\x83\x01\x84a2\x9DV[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a2\xF2\x82a2\xC7V[\x90P\x91\x90PV[a3\x02\x81a2\xE7V[\x82RPPV[`\0` \x82\x01\x90Pa3\x1D`\0\x83\x01\x84a2\xF9V[\x92\x91PPV[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a3<\x81a3#V[\x82RPPV[a3K\x81a0\xDFV[\x82RPPV[`\0`\xC0\x82\x01\x90Pa3f`\0\x83\x01\x89a33V[a3s` \x83\x01\x88a2\xF9V[a3\x80`@\x83\x01\x87a2\xF9V[a3\x8D``\x83\x01\x86a3BV[a3\x9A`\x80\x83\x01\x85a2:V[a3\xA7`\xA0\x83\x01\x84a/\xE3V[\x97\x96PPPPPPPV[a3\xBB\x81a2\xE7V[\x81\x14a3\xC6W`\0\x80\xFD[PV[`\0\x815\x90Pa3\xD8\x81a3\xB2V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a3\xF4Wa3\xF3a1EV[[`\0a4\x02\x84\x82\x85\x01a3\xC9V[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a4\x1E\x81a4\x0BV[\x82RPPV[`\0` \x82\x01\x90Pa49`\0\x83\x01\x84a4\x15V[\x92\x91PPV[`\0a4Za4Ua4P\x84a2\xC7V[a/\xB7V[a2\xC7V[\x90P\x91\x90PV[`\0a4l\x82a4?V[\x90P\x91\x90PV[`\0a4~\x82a4aV[\x90P\x91\x90PV[a4\x8E\x81a4sV[\x82RPPV[`\0` \x82\x01\x90Pa4\xA9`\0\x83\x01\x84a4\x85V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0[\x83\x81\x10\x15a4\xE9W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa4\xCEV[\x83\x81\x11\x15a4\xF8W`\0\x84\x84\x01R[PPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a5\x1A\x82a4\xAFV[a5$\x81\x85a4\xBAV[\x93Pa54\x81\x85` \x86\x01a4\xCBV[a5=\x81a4\xFEV[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra5b\x81\x84a5\x0FV[\x90P\x92\x91PPV[`\0`@\x82\x01\x90Pa5\x7F`\0\x83\x01\x85a0\xF1V[a5\x8C` \x83\x01\x84a4\x15V[\x93\x92PPPV[`\0a5\x9E\x82a4aV[\x90P\x91\x90PV[a5\xAE\x81a5\x93V[\x82RPPV[`\0` \x82\x01\x90Pa5\xC9`\0\x83\x01\x84a5\xA5V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a5\xF6\x82a5\xCFV[a6\0\x81\x85a5\xDAV[\x93Pa6\x10\x81\x85` \x86\x01a4\xCBV[a6\x19\x81a4\xFEV[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra6>\x81\x84a5\xEBV[\x90P\x92\x91PPV[`\0` \x82\x01\x90Pa6[`\0\x83\x01\x84a33V[\x92\x91PPV[`\0a6|a6wa6r\x84a3#V[a/\xB7V[a3#V[\x90P\x91\x90PV[a6\x8C\x81a6aV[\x82RPPV[`\0` \x82\x01\x90Pa6\xA7`\0\x83\x01\x84a6\x83V[\x92\x91PPV[a6\xB6\x81a/\xC1V[\x82RPPV[`\0` \x82\x01\x90Pa6\xD1`\0\x83\x01\x84a6\xADV[\x92\x91PPV[`\0` \x82\x01\x90Pa6\xEC`\0\x83\x01\x84a3BV[\x92\x91PPV[`\0a6\xFD\x82a4aV[\x90P\x91\x90PV[a7\r\x81a6\xF2V[\x82RPPV[`\0` \x82\x01\x90Pa7(`\0\x83\x01\x84a7\x04V[\x92\x91PPV[`\0``\x82\x01\x90Pa7C`\0\x83\x01\x86a6\x83V[a7P` \x83\x01\x85a3BV[\x81\x81\x03`@\x83\x01Ra7b\x81\x84a5\xEBV[\x90P\x94\x93PPPPV[`\0a7w\x82a4aV[\x90P\x91\x90PV[a7\x87\x81a7lV[\x82RPPV[`\0` \x82\x01\x90Pa7\xA2`\0\x83\x01\x84a7~V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a7\xE2\x82a4\x0BV[\x91Pa7\xED\x83a4\x0BV[\x92P\x82\x82\x10\x15a8\0Wa7\xFFa7\xA8V[[\x82\x82\x03\x90P\x92\x91PPV[a8\x14\x81a0\xD5V[\x82RPPV[a8#\x81a4\x0BV[\x82RPPV[a82\x81a2\xE7V[\x82RPPV[`\xE0\x82\x01`\0\x82\x01Qa8N`\0\x85\x01\x82a8\x0BV[P` \x82\x01Qa8a` \x85\x01\x82a8\x0BV[P`@\x82\x01Qa8t`@\x85\x01\x82a8\x0BV[P``\x82\x01Qa8\x87``\x85\x01\x82a8\x1AV[P`\x80\x82\x01Qa8\x9A`\x80\x85\x01\x82a8\x0BV[P`\xA0\x82\x01Qa8\xAD`\xA0\x85\x01\x82a8\x0BV[P`\xC0\x82\x01Qa8\xC0`\xC0\x85\x01\x82a8)V[PPPPV[`\0`\xE0\x82\x01\x90Pa8\xDB`\0\x83\x01\x84a88V[\x92\x91PPV[\x82\x81\x837`\0\x83\x83\x01RPPPV[`\0a8\xFC\x83\x85a5\xDAV[\x93Pa9\t\x83\x85\x84a8\xE1V[a9\x12\x83a4\xFEV[\x84\x01\x90P\x93\x92PPPV[`\0``\x82\x01\x90Pa92`\0\x83\x01\x87a1\x1BV[\x81\x81\x03` \x83\x01Ra9D\x81\x86a5\xEBV[\x90P\x81\x81\x03`@\x83\x01Ra9Y\x81\x84\x86a8\xF0V[\x90P\x95\x94PPPPPV[`\0\x81\x90P\x92\x91PPV[PV[`\0a9\x7F`\0\x83a9dV[\x91Pa9\x8A\x82a9oV[`\0\x82\x01\x90P\x91\x90PV[`\0a9\xA0\x82a9rV[\x91P\x81\x90P\x91\x90PV[`\0a9\xB5\x82a4aV[\x90P\x91\x90PV[a9\xC5\x81a9\xAAV[\x82RPPV[`\0` \x82\x01\x90Pa9\xE0`\0\x83\x01\x84a9\xBCV[\x92\x91PPV[a9\xEF\x81a0\x9FV[\x81\x14a9\xFAW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\x0C\x81a9\xE6V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a:(Wa:'a1EV[[`\0a:6\x84\x82\x85\x01a9\xFDV[\x91PP\x92\x91PPV[`\0a:Za:Ua:P\x84a3#V[a/\xB7V[a4\x0BV[\x90P\x91\x90PV[a:j\x81a:?V[\x82RPPV[`\0` \x82\x01\x90Pa:\x85`\0\x83\x01\x84a:aV[\x92\x91PPV[a:\x94\x81a3#V[\x81\x14a:\x9FW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\xB1\x81a:\x8BV[\x92\x91PPV[a:\xC0\x81a/\xA3V[\x81\x14a:\xCBW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\xDD\x81a:\xB7V[\x92\x91PPV[`\0a:\xEE\x82a2\xE7V[\x90P\x91\x90PV[a:\xFE\x81a:\xE3V[\x81\x14a;\tW`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\x1B\x81a:\xF5V[\x92\x91PPV[`\0\x80`\0``\x84\x86\x03\x12\x15a;:Wa;9a1EV[[`\0a;H\x86\x82\x87\x01a:\xA2V[\x93PP` a;Y\x86\x82\x87\x01a:\xCEV[\x92PP`@a;j\x86\x82\x87\x01a;\x0CV[\x91PP\x92P\x92P\x92V[a;}\x81a0\xD5V[\x81\x14a;\x88W`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\x9A\x81a;tV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a;\xB6Wa;\xB5a1EV[[`\0a;\xC4\x84\x82\x85\x01a;\x8BV[\x91PP\x92\x91PPV[a;\xD6\x81a4\x0BV[\x81\x14a;\xE1W`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\xF3\x81a;\xCDV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a<\x0FWa<\x0Ea1EV[[`\0a<\x1D\x84\x82\x85\x01a;\xE4V[\x91PP\x92\x91PPV[`\x03\x81\x10a<3W`\0\x80\xFD[PV[`\0\x81Q\x90Pa<E\x81a<&V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a<aWa<`a1EV[[`\0a<o\x84\x82\x85\x01a<6V[\x91PP\x92\x91PPV[a<\x81\x81a0\xD5V[\x81\x14a<\x8CW`\0\x80\xFD[PV[`\0\x81Q\x90Pa<\x9E\x81a<xV[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a<\xBBWa<\xBAa1EV[[`\0a<\xC9\x85\x82\x86\x01a<\x8FV[\x92PP` a<\xDA\x85\x82\x86\x01a;\xE4V[\x91PP\x92P\x92\x90PV[`\0a<\xEF\x82a4\x0BV[\x91Pa<\xFA\x83a4\x0BV[\x92P\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x03\x82\x11\x15a=/Wa=.a7\xA8V[[\x82\x82\x01\x90P\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a=PWa=Oa1EV[[`\0a=^\x84\x82\x85\x01a:\xA2V[\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 \xAE\xFE\xFB\x026\xAA\xE9\x97WA\x1B\xA6\xB4\xAE|\xE9\xEDPhY\xFB\x90\xAA\x9B\xB69\x7F&.\xEF\xAF\x1BdsolcC\0\x08\x0F\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106102305760003560e01c80636d9a1c8b1161012e578063bdb337d1116100ab578063d2ef73981161006f578063d2ef7398146107f0578063d5d44d801461080e578063f2b4e6171461084b578063fa24f74314610876578063fdcb6068146108a357610230565b8063bdb337d114610707578063c0d8bb7414610732578063c32e4e3e1461076f578063cf09e0d01461079a578063d2177bdd146107c557610230565b80638b85902b116100f25780638b85902b1461063057806399735e321461065b578063bbdc02db14610686578063bcbe5094146106b1578063bcef3b55146106dc57610230565b80636d9a1c8b1461058e57806370872aa5146105b9578063786b844b146105e45780637948690a146105fb5780638129fc1c1461062657610230565b80633ec4d4d6116101bc5780635c0cba33116101805780635c0cba33146104b9578063609d3334146104e457806360e274641461050f5780636361506d1461053857806368ccdc861461056357610230565b80633ec4d4d6146103ca578063529d6a8c146103fa57806352a07fa31461043757806354fd4d501461046257806357da950e1461048d57610230565b80632810e1d6116102035780632810e1d6146102e15780632b31841e1461030c578063375bfa5d14610337578063378dd48c1461037457806337b1b2291461039f57610230565b806319effeb414610235578063200d2ed214610260578063250e69bd1461028b57806325fc2ace146102b6575b600080fd5b34801561024157600080fd5b5061024a6108ce565b6040516102579190612ff2565b60405180910390f35b34801561026c57600080fd5b506102756108e8565b6040516102829190613084565b60405180910390f35b34801561029757600080fd5b506102a06108fb565b6040516102ad91906130ba565b60405180910390f35b3480156102c257600080fd5b506102cb61090e565b6040516102d89190613100565b60405180910390f35b3480156102ed57600080fd5b506102f661091b565b6040516103039190613084565b60405180910390f35b34801561031857600080fd5b50610321611068565b60405161032e919061312a565b60405180910390f35b34801561034357600080fd5b5061035e600480360381019061035991906131b4565b611090565b60405161036b9190613249565b60405180910390f35b34801561038057600080fd5b506103896113cf565b60405161039691906132ac565b60405180910390f35b3480156103ab57600080fd5b506103b46113e2565b6040516103c19190613308565b60405180910390f35b3480156103d657600080fd5b506103df6113f3565b6040516103f196959493929190613351565b60405180910390f35b34801561040657600080fd5b50610421600480360381019061041c91906133de565b61148e565b60405161042e9190613424565b60405180910390f35b34801561044357600080fd5b5061044c6114a6565b6040516104599190613494565b60405180910390f35b34801561046e57600080fd5b506104776114ce565b6040516104849190613548565b60405180910390f35b34801561049957600080fd5b506104a2611507565b6040516104b092919061356a565b60405180910390f35b3480156104c557600080fd5b506104ce611519565b6040516104db91906135b4565b60405180910390f35b3480156104f057600080fd5b506104f9611541565b6040516105069190613624565b60405180910390f35b34801561051b57600080fd5b50610536600480360381019061053191906133de565b611554565b005b34801561054457600080fd5b5061054d611800565b60405161055a9190613100565b60405180910390f35b34801561056f57600080fd5b50610578611811565b6040516105859190613424565b60405180910390f35b34801561059a57600080fd5b506105a3611839565b6040516105b0919061312a565b60405180910390f35b3480156105c557600080fd5b506105ce611861565b6040516105db9190613424565b60405180910390f35b3480156105f057600080fd5b506105f961186e565b005b34801561060757600080fd5b50610610611bf8565b60405161061d9190613646565b60405180910390f35b61062e611c09565b005b34801561063c57600080fd5b50610645612714565b6040516106529190613424565b60405180910390f35b34801561066757600080fd5b50610670612723565b60405161067d9190613424565b60405180910390f35b34801561069257600080fd5b5061069b612734565b6040516106a89190613692565b60405180910390f35b3480156106bd57600080fd5b506106c661275c565b6040516106d391906136bc565b60405180910390f35b3480156106e857600080fd5b506106f1612784565b6040516106fe91906136d7565b60405180910390f35b34801561071357600080fd5b5061071c612795565b60405161072991906130ba565b60405180910390f35b34801561073e57600080fd5b50610759600480360381019061075491906133de565b61283a565b6040516107669190613424565b60405180910390f35b34801561077b57600080fd5b50610784612852565b604051610791919061312a565b60405180910390f35b3480156107a657600080fd5b506107af61287a565b6040516107bc9190612ff2565b60405180910390f35b3480156107d157600080fd5b506107da612892565b6040516107e791906136bc565b60405180910390f35b6107f86128ba565b6040516108059190613249565b60405180910390f35b34801561081a57600080fd5b50610835600480360381019061083091906133de565b612c4d565b6040516108429190613424565b60405180910390f35b34801561085757600080fd5b50610860612d18565b60405161086d9190613713565b60405180910390f35b34801561088257600080fd5b5061088b612d40565b60405161089a9392919061372e565b60405180910390f35b3480156108af57600080fd5b506108b8612d68565b6040516108c5919061378d565b60405180910390f35b600060089054906101000a900467ffffffffffffffff1681565b600060109054906101000a900460ff1681565b600960009054906101000a900460ff1681565b6000600760000154905090565b60008060028111156109305761092f61300d565b5b600060109054906101000a900460ff1660028111156109525761095161300d565b5b14610989576040517ff1a9458100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610993612d90565b9050600060028111156109a9576109a861300d565b5b8160028111156109bc576109bb61300d565b5b036109f3576040517f92c506ae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60016002811115610a0757610a0661300d565b5b816002811115610a1a57610a1961300d565b5b03610ab8576001600060106101000a81548160ff02191690836002811115610a4557610a4461300d565b5b02179055504760056000600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fad565b610ac0612795565b610af6576040517f04643c3900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006004811115610b0a57610b0961300d565b5b600160030160009054906101000a900460ff166004811115610b2f57610b2e61300d565b5b03610baf576002600060106101000a81548160ff02191690836002811115610b5a57610b5961300d565b5b02179055504760056000610b6c6113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fac565b60016004811115610bc357610bc261300d565b5b600160030160009054906101000a900460ff166004811115610be857610be761300d565b5b03610c86576001600060106101000a81548160ff02191690836002811115610c1357610c1261300d565b5b02179055504760056000600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610fab565b60026004811115610c9a57610c9961300d565b5b600160030160009054906101000a900460ff166004811115610cbf57610cbe61300d565b5b03610d3f576002600060106101000a81548160ff02191690836002811115610cea57610ce961300d565b5b02179055504760056000610cfc6113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610faa565b60036004811115610d5357610d5261300d565b5b600160030160009054906101000a900460ff166004811115610d7857610d7761300d565b5b03610f77576002600060106101000a81548160ff02191690836002811115610da357610da261300d565b5b0217905550610db06113e2565b73ffffffffffffffffffffffffffffffffffffffff166001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610e735747600560006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610f72565b7f0000000000000000000000000000000000000000000000000000000000000000600560006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f000000000000000000000000000000000000000000000000000000000000000047610f2791906137d7565b60056000610f336113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b610fa9565b6040517f7492a26900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6004600160030160006101000a81548160ff02191690836004811115610fd657610fd561300d565b5b021790555042600060086101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550600060109054906101000a900460ff1660028111156110265761102561300d565b5b7f5e186f09b9c93491f14e277eea7faa5de6a2d4bda75a79af7a3684fbfb42da6060405160405180910390a2600060109054906101000a900460ff1691505090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b600061109a612795565b156110d1576040517fdf469ccb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060e001604052806110e6611800565b81526020016007600001548152602001611106611101612784565b612ed2565b8152602001611113612723565b81526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020013373ffffffffffffffffffffffffffffffffffffffff1681525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166341493c607f0000000000000000000000000000000000000000000000000000000000000000836040516020016111ee91906138c6565b60405160208183030381529060405287876040518563ffffffff1660e01b815260040161121e949392919061391d565b60006040518083038186803b15801561123657600080fd5b505afa15801561124a573d6000803e3d6000fd5b50505050336001800160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff16600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff160361131d576002600160030160006101000a81548160ff021916908360048111156113135761131261300d565b5b021790555061134c565b6003600160030160006101000a81548160ff021916908360048111156113465761134561300d565b5b02179055505b6001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f5e6565d9ca2f5c8501d6418bf563322a7243ba7ace266d75eac99f4adbb30ba760405160405180910390a2600160030160009054906101000a900460ff1691505092915050565b600960019054906101000a900460ff1681565b60006113ee6000612edc565b905090565b60018060000160009054906101000a900463ffffffff16908060000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060020154908060030160009054906101000a900460ff16908060030160019054906101000a900467ffffffffffffffff16905086565b60056020528060005260406000206000915090505481565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6040518060400160405280600581526020017f322e302e3000000000000000000000000000000000000000000000000000000081525081565b60078060000154908060010154905082565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b606061154f60546024612ef8565b905090565b61155c61186e565b60006002808111156115715761157061300d565b5b600960019054906101000a900460ff1660028111156115935761159261300d565b5b036115df57600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050611694565b600160028111156115f3576115f261300d565b5b600960019054906101000a900460ff1660028111156116155761161461300d565b5b0361166157600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050611693565b6040517f078a3df400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b600081036116ce576040517f17bfe5f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506000600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008273ffffffffffffffffffffffffffffffffffffffff168260405161177e90613995565b60006040518083038185875af1925050503d80600081146117bb576040519150601f19603f3d011682016040523d82523d6000602084013e6117c0565b606091505b50509050806117fb576040517f83e6cc6b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b600061180c6034612f30565b905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000600760010154905090565b6002808111156118815761188061300d565b5b600960019054906101000a900460ff1660028111156118a3576118a261300d565b5b14806118e25750600160028111156118be576118bd61300d565b5b600960019054906101000a900460ff1660028111156118e0576118df61300d565b5b145b611bf657600060028111156118fa576118f961300d565b5b600960019054906101000a900460ff16600281111561191c5761191b61300d565b5b14611953576040517f078a3df400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630314d2b3306040518263ffffffff1660e01b81526004016119ae91906139cb565b602060405180830381865afa1580156119cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ef9190613a12565b905080611a28576040517f4851bd9b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166317cf21a9306040518263ffffffff1660e01b8152600401611a8191906139cb565b600060405180830381600087803b158015611a9b57600080fd5b505af1925050508015611aac575060015b5060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663496b9c16306040518263ffffffff1660e01b8152600401611b0891906139cb565b602060405180830381865afa158015611b25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b499190613a12565b90508015611b81576001600960016101000a81548160ff02191690836002811115611b7757611b7661300d565b5b0217905550611bad565b6002600960016101000a81548160ff02191690836002811115611ba757611ba661300d565b5b02179055505b7f9908eaac0645df9d0704d06adc9e07337c951de2f06b5f2836151d48d5e4722f600960019054906101000a900460ff16604051611beb91906132ac565b60405180910390a150505b565b6000611c046074612f49565b905090565b600060119054906101000a900460ff1615611c50576040517f0dc149f000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614611cd5576040517f940d38c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631d3225e3611d196113e2565b6040518263ffffffff1660e01b8152600401611d359190613308565b602060405180830381865afa158015611d52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d769190613a12565b611dac576040517fd386ef3e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b607e3614611dc257639824bdab6000526004601cfd5b63ffffffff8016611dd1611bf8565b63ffffffff161461227b5760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc611e22611bf8565b6040518263ffffffff1660e01b8152600401611e3e9190613a70565b606060405180830381865afa158015611e5b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e7f9190613b21565b925050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166304e50fed826040518263ffffffff1660e01b8152600401611edc91906139cb565b602060405180830381865afa158015611ef9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f1d9190613a12565b1580611fbf57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166334a346ea826040518263ffffffff1660e01b8152600401611f7d91906139cb565b602060405180830381865afa158015611f9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fbe9190613a12565b5b8061206057507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16635958a193826040518263ffffffff1660e01b815260040161201e91906139cb565b602060405180830381865afa15801561203b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061205f9190613a12565b5b15612097576040517f346119f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405180604001604052806121198373ffffffffffffffffffffffffffffffffffffffff1663bcef3b556040518163ffffffff1660e01b8152600401602060405180830381865afa1580156120f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121149190613ba0565b612ed2565b81526020018273ffffffffffffffffffffffffffffffffffffffff166399735e326040518163ffffffff1660e01b8152600401602060405180830381865afa158015612169573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218d9190613bf9565b81525060076000820151816000015560208201518160010155905050600160028111156121bd576121bc61300d565b5b8173ffffffffffffffffffffffffffffffffffffffff1663200d2ed26040518163ffffffff1660e01b8152600401602060405180830381865afa158015612208573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061222c9190613c4b565b600281111561223e5761223d61300d565b5b03612275576040517f346119f700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5061234f565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637258a8077f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b81526004016122f49190613692565b6040805180830381865afa158015612310573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123349190613ca4565b60076000016000600760010160008491905055839190505550505b60076001015461235d612723565b116123a65761236a612784565b6040517ff40239db00000000000000000000000000000000000000000000000000000000815260040161239d91906136d7565b60405180910390fd5b6040518060c001604052806123b9611bf8565b63ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001612406612784565b81526020016000600481111561241f5761241e61300d565b5b81526020016124577f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16612f65565b67ffffffffffffffff164261246c9190613ce4565b67ffffffffffffffff16815250600160008201518160000160006101000a81548163ffffffff021916908363ffffffff16021790555060208201518160000160046101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506060820151816002015560808201518160030160006101000a81548160ff021916908360048111156125655761256461300d565b5b021790555060a08201518160030160016101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055509050506001600060116101000a81548160ff02191690831515021790555034600660006125c46113e2565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461260d9190613ce4565b92505081905550426000806101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f000000000000000000000000000000000000000000000000000000000000000063ffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16633c9f397c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156126ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126f29190613d3a565b63ffffffff1614600960006101000a81548160ff021916908315150217905550565b600061271e612723565b905090565b600061272f6054612f6f565b905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60006127906014612f30565b905090565b60004267ffffffffffffffff166127ce600160030160019054906101000a900467ffffffffffffffff1667ffffffffffffffff16612f88565b67ffffffffffffffff1610806128355750600073ffffffffffffffffffffffffffffffffffffffff166001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b905090565b60066020528060005260406000206000915090505481565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60008054906101000a900467ffffffffffffffff1681565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b60008060048111156128cf576128ce61300d565b5b600160030160009054906101000a900460ff1660048111156128f4576128f361300d565b5b1461292b576040517f85c345b000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663ff59ae7d336040518263ffffffff1660e01b81526004016129849190613308565b602060405180830381865afa1580156129a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129c59190613a12565b6129fb576040517fd386ef3e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612a03612795565b15612a3a576040517fdf469ccb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000003414612a93576040517f8620aa1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b33600160000160046101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060018060030160006101000a81548160ff02191690836004811115612aff57612afe61300d565b5b0217905550612b377f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16612f65565b67ffffffffffffffff1642612b4c9190613ce4565b600160030160016101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555034600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254612bc69190613ce4565b92505081905550600160000160049054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f98027b38153f995c4b802a5c7e6365bee3addb25af6b29818c0c304684d8052c60405160405180910390a2600160030160009054906101000a900460ff16905090565b6000600280811115612c6257612c6161300d565b5b600960019054906101000a900460ff166002811115612c8457612c8361300d565b5b03612cd057600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050612d13565b600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490505b919050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b6000806060612d4d612734565b9250612d57612784565b9150612d61611541565b9050909192565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b600063ffffffff8016612da1611bf8565b63ffffffff1614612eca5760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663bb8aa1fc612df2611bf8565b6040518263ffffffff1660e01b8152600401612e0e9190613a70565b606060405180830381865afa158015612e2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e4f9190613b21565b925050508073ffffffffffffffffffffffffffffffffffffffff1663200d2ed26040518163ffffffff1660e01b8152600401602060405180830381865afa158015612e9e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ec29190613c4b565b915050612ecf565b600290505b90565b6000819050919050565b600080612ee7612f92565b90508281013560601c915050919050565b60606000612f04612f92565b905060405191508282528284820160208401378260208301016000815260208101604052505092915050565b600080612f3b612f92565b905082810135915050919050565b600080612f54612f92565b90508281013560e01c915050919050565b6000819050919050565b600080612f7a612f92565b905082810135915050919050565b6000819050919050565b6000600236033560f01c3603905090565b600067ffffffffffffffff82169050919050565b6000819050919050565b6000612fdc612fd7612fd284612fa3565b612fb7565b612fa3565b9050919050565b612fec81612fc1565b82525050565b60006020820190506130076000830184612fe3565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6003811061304d5761304c61300d565b5b50565b600081905061305e8261303c565b919050565b600061306e82613050565b9050919050565b61307e81613063565b82525050565b60006020820190506130996000830184613075565b92915050565b60008115159050919050565b6130b48161309f565b82525050565b60006020820190506130cf60008301846130ab565b92915050565b6000819050919050565b60006130ea826130d5565b9050919050565b6130fa816130df565b82525050565b600060208201905061311560008301846130f1565b92915050565b613124816130d5565b82525050565b600060208201905061313f600083018461311b565b92915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126131745761317361314f565b5b8235905067ffffffffffffffff81111561319157613190613154565b5b6020830191508360018202830111156131ad576131ac613159565b5b9250929050565b600080602083850312156131cb576131ca613145565b5b600083013567ffffffffffffffff8111156131e9576131e861314a565b5b6131f58582860161315e565b92509250509250929050565b600581106132125761321161300d565b5b50565b600081905061322382613201565b919050565b600061323382613215565b9050919050565b61324381613228565b82525050565b600060208201905061325e600083018461323a565b92915050565b600381106132755761327461300d565b5b50565b600081905061328682613264565b919050565b600061329682613278565b9050919050565b6132a68161328b565b82525050565b60006020820190506132c1600083018461329d565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006132f2826132c7565b9050919050565b613302816132e7565b82525050565b600060208201905061331d60008301846132f9565b92915050565b600063ffffffff82169050919050565b61333c81613323565b82525050565b61334b816130df565b82525050565b600060c0820190506133666000830189613333565b61337360208301886132f9565b61338060408301876132f9565b61338d6060830186613342565b61339a608083018561323a565b6133a760a0830184612fe3565b979650505050505050565b6133bb816132e7565b81146133c657600080fd5b50565b6000813590506133d8816133b2565b92915050565b6000602082840312156133f4576133f3613145565b5b6000613402848285016133c9565b91505092915050565b6000819050919050565b61341e8161340b565b82525050565b60006020820190506134396000830184613415565b92915050565b600061345a613455613450846132c7565b612fb7565b6132c7565b9050919050565b600061346c8261343f565b9050919050565b600061347e82613461565b9050919050565b61348e81613473565b82525050565b60006020820190506134a96000830184613485565b92915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156134e95780820151818401526020810190506134ce565b838111156134f8576000848401525b50505050565b6000601f19601f8301169050919050565b600061351a826134af565b61352481856134ba565b93506135348185602086016134cb565b61353d816134fe565b840191505092915050565b60006020820190508181036000830152613562818461350f565b905092915050565b600060408201905061357f60008301856130f1565b61358c6020830184613415565b9392505050565b600061359e82613461565b9050919050565b6135ae81613593565b82525050565b60006020820190506135c960008301846135a5565b92915050565b600081519050919050565b600082825260208201905092915050565b60006135f6826135cf565b61360081856135da565b93506136108185602086016134cb565b613619816134fe565b840191505092915050565b6000602082019050818103600083015261363e81846135eb565b905092915050565b600060208201905061365b6000830184613333565b92915050565b600061367c61367761367284613323565b612fb7565b613323565b9050919050565b61368c81613661565b82525050565b60006020820190506136a76000830184613683565b92915050565b6136b681612fc1565b82525050565b60006020820190506136d160008301846136ad565b92915050565b60006020820190506136ec6000830184613342565b92915050565b60006136fd82613461565b9050919050565b61370d816136f2565b82525050565b60006020820190506137286000830184613704565b92915050565b60006060820190506137436000830186613683565b6137506020830185613342565b818103604083015261376281846135eb565b9050949350505050565b600061377782613461565b9050919050565b6137878161376c565b82525050565b60006020820190506137a2600083018461377e565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006137e28261340b565b91506137ed8361340b565b925082821015613800576137ff6137a8565b5b828203905092915050565b613814816130d5565b82525050565b6138238161340b565b82525050565b613832816132e7565b82525050565b60e08201600082015161384e600085018261380b565b506020820151613861602085018261380b565b506040820151613874604085018261380b565b506060820151613887606085018261381a565b50608082015161389a608085018261380b565b5060a08201516138ad60a085018261380b565b5060c08201516138c060c0850182613829565b50505050565b600060e0820190506138db6000830184613838565b92915050565b82818337600083830152505050565b60006138fc83856135da565b93506139098385846138e1565b613912836134fe565b840190509392505050565b6000606082019050613932600083018761311b565b818103602083015261394481866135eb565b905081810360408301526139598184866138f0565b905095945050505050565b600081905092915050565b50565b600061397f600083613964565b915061398a8261396f565b600082019050919050565b60006139a082613972565b9150819050919050565b60006139b582613461565b9050919050565b6139c5816139aa565b82525050565b60006020820190506139e060008301846139bc565b92915050565b6139ef8161309f565b81146139fa57600080fd5b50565b600081519050613a0c816139e6565b92915050565b600060208284031215613a2857613a27613145565b5b6000613a36848285016139fd565b91505092915050565b6000613a5a613a55613a5084613323565b612fb7565b61340b565b9050919050565b613a6a81613a3f565b82525050565b6000602082019050613a856000830184613a61565b92915050565b613a9481613323565b8114613a9f57600080fd5b50565b600081519050613ab181613a8b565b92915050565b613ac081612fa3565b8114613acb57600080fd5b50565b600081519050613add81613ab7565b92915050565b6000613aee826132e7565b9050919050565b613afe81613ae3565b8114613b0957600080fd5b50565b600081519050613b1b81613af5565b92915050565b600080600060608486031215613b3a57613b39613145565b5b6000613b4886828701613aa2565b9350506020613b5986828701613ace565b9250506040613b6a86828701613b0c565b9150509250925092565b613b7d816130d5565b8114613b8857600080fd5b50565b600081519050613b9a81613b74565b92915050565b600060208284031215613bb657613bb5613145565b5b6000613bc484828501613b8b565b91505092915050565b613bd68161340b565b8114613be157600080fd5b50565b600081519050613bf381613bcd565b92915050565b600060208284031215613c0f57613c0e613145565b5b6000613c1d84828501613be4565b91505092915050565b60038110613c3357600080fd5b50565b600081519050613c4581613c26565b92915050565b600060208284031215613c6157613c60613145565b5b6000613c6f84828501613c36565b91505092915050565b613c81816130d5565b8114613c8c57600080fd5b50565b600081519050613c9e81613c78565b92915050565b60008060408385031215613cbb57613cba613145565b5b6000613cc985828601613c8f565b9250506020613cda85828601613be4565b9150509250929050565b6000613cef8261340b565b9150613cfa8361340b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115613d2f57613d2e6137a8565b5b828201905092915050565b600060208284031215613d5057613d4f613145565b5b6000613d5e84828501613aa2565b9150509291505056fea2646970667358221220aefefb0236aae99757411ba6b4ae7ce9ed506859fb90aa9bb6397f262eefaf1b64736f6c634300080f0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x020W`\x005`\xE0\x1C\x80cm\x9A\x1C\x8B\x11a\x01.W\x80c\xBD\xB37\xD1\x11a\0\xABW\x80c\xD2\xEFs\x98\x11a\0oW\x80c\xD2\xEFs\x98\x14a\x07\xF0W\x80c\xD5\xD4M\x80\x14a\x08\x0EW\x80c\xF2\xB4\xE6\x17\x14a\x08KW\x80c\xFA$\xF7C\x14a\x08vW\x80c\xFD\xCB`h\x14a\x08\xA3Wa\x020V[\x80c\xBD\xB37\xD1\x14a\x07\x07W\x80c\xC0\xD8\xBBt\x14a\x072W\x80c\xC3.N>\x14a\x07oW\x80c\xCF\t\xE0\xD0\x14a\x07\x9AW\x80c\xD2\x17{\xDD\x14a\x07\xC5Wa\x020V[\x80c\x8B\x85\x90+\x11a\0\xF2W\x80c\x8B\x85\x90+\x14a\x060W\x80c\x99s^2\x14a\x06[W\x80c\xBB\xDC\x02\xDB\x14a\x06\x86W\x80c\xBC\xBEP\x94\x14a\x06\xB1W\x80c\xBC\xEF;U\x14a\x06\xDCWa\x020V[\x80cm\x9A\x1C\x8B\x14a\x05\x8EW\x80cp\x87*\xA5\x14a\x05\xB9W\x80cxk\x84K\x14a\x05\xE4W\x80cyHi\n\x14a\x05\xFBW\x80c\x81)\xFC\x1C\x14a\x06&Wa\x020V[\x80c>\xC4\xD4\xD6\x11a\x01\xBCW\x80c\\\x0C\xBA3\x11a\x01\x80W\x80c\\\x0C\xBA3\x14a\x04\xB9W\x80c`\x9D34\x14a\x04\xE4W\x80c`\xE2td\x14a\x05\x0FW\x80ccaPm\x14a\x058W\x80ch\xCC\xDC\x86\x14a\x05cWa\x020V[\x80c>\xC4\xD4\xD6\x14a\x03\xCAW\x80cR\x9Dj\x8C\x14a\x03\xFAW\x80cR\xA0\x7F\xA3\x14a\x047W\x80cT\xFDMP\x14a\x04bW\x80cW\xDA\x95\x0E\x14a\x04\x8DWa\x020V[\x80c(\x10\xE1\xD6\x11a\x02\x03W\x80c(\x10\xE1\xD6\x14a\x02\xE1W\x80c+1\x84\x1E\x14a\x03\x0CW\x80c7[\xFA]\x14a\x037W\x80c7\x8D\xD4\x8C\x14a\x03tW\x80c7\xB1\xB2)\x14a\x03\x9FWa\x020V[\x80c\x19\xEF\xFE\xB4\x14a\x025W\x80c \r.\xD2\x14a\x02`W\x80c%\x0Ei\xBD\x14a\x02\x8BW\x80c%\xFC*\xCE\x14a\x02\xB6W[`\0\x80\xFD[4\x80\x15a\x02AW`\0\x80\xFD[Pa\x02Ja\x08\xCEV[`@Qa\x02W\x91\x90a/\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02lW`\0\x80\xFD[Pa\x02ua\x08\xE8V[`@Qa\x02\x82\x91\x90a0\x84V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x97W`\0\x80\xFD[Pa\x02\xA0a\x08\xFBV[`@Qa\x02\xAD\x91\x90a0\xBAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xC2W`\0\x80\xFD[Pa\x02\xCBa\t\x0EV[`@Qa\x02\xD8\x91\x90a1\0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xEDW`\0\x80\xFD[Pa\x02\xF6a\t\x1BV[`@Qa\x03\x03\x91\x90a0\x84V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x18W`\0\x80\xFD[Pa\x03!a\x10hV[`@Qa\x03.\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03CW`\0\x80\xFD[Pa\x03^`\x04\x806\x03\x81\x01\x90a\x03Y\x91\x90a1\xB4V[a\x10\x90V[`@Qa\x03k\x91\x90a2IV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x80W`\0\x80\xFD[Pa\x03\x89a\x13\xCFV[`@Qa\x03\x96\x91\x90a2\xACV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xABW`\0\x80\xFD[Pa\x03\xB4a\x13\xE2V[`@Qa\x03\xC1\x91\x90a3\x08V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD6W`\0\x80\xFD[Pa\x03\xDFa\x13\xF3V[`@Qa\x03\xF1\x96\x95\x94\x93\x92\x91\x90a3QV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x06W`\0\x80\xFD[Pa\x04!`\x04\x806\x03\x81\x01\x90a\x04\x1C\x91\x90a3\xDEV[a\x14\x8EV[`@Qa\x04.\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04CW`\0\x80\xFD[Pa\x04La\x14\xA6V[`@Qa\x04Y\x91\x90a4\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04nW`\0\x80\xFD[Pa\x04wa\x14\xCEV[`@Qa\x04\x84\x91\x90a5HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x99W`\0\x80\xFD[Pa\x04\xA2a\x15\x07V[`@Qa\x04\xB0\x92\x91\x90a5jV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xC5W`\0\x80\xFD[Pa\x04\xCEa\x15\x19V[`@Qa\x04\xDB\x91\x90a5\xB4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF0W`\0\x80\xFD[Pa\x04\xF9a\x15AV[`@Qa\x05\x06\x91\x90a6$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x1BW`\0\x80\xFD[Pa\x056`\x04\x806\x03\x81\x01\x90a\x051\x91\x90a3\xDEV[a\x15TV[\0[4\x80\x15a\x05DW`\0\x80\xFD[Pa\x05Ma\x18\0V[`@Qa\x05Z\x91\x90a1\0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05oW`\0\x80\xFD[Pa\x05xa\x18\x11V[`@Qa\x05\x85\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x9AW`\0\x80\xFD[Pa\x05\xA3a\x189V[`@Qa\x05\xB0\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xC5W`\0\x80\xFD[Pa\x05\xCEa\x18aV[`@Qa\x05\xDB\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF0W`\0\x80\xFD[Pa\x05\xF9a\x18nV[\0[4\x80\x15a\x06\x07W`\0\x80\xFD[Pa\x06\x10a\x1B\xF8V[`@Qa\x06\x1D\x91\x90a6FV[`@Q\x80\x91\x03\x90\xF3[a\x06.a\x1C\tV[\0[4\x80\x15a\x06<W`\0\x80\xFD[Pa\x06Ea'\x14V[`@Qa\x06R\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06gW`\0\x80\xFD[Pa\x06pa'#V[`@Qa\x06}\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x92W`\0\x80\xFD[Pa\x06\x9Ba'4V[`@Qa\x06\xA8\x91\x90a6\x92V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xBDW`\0\x80\xFD[Pa\x06\xC6a'\\V[`@Qa\x06\xD3\x91\x90a6\xBCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xE8W`\0\x80\xFD[Pa\x06\xF1a'\x84V[`@Qa\x06\xFE\x91\x90a6\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x13W`\0\x80\xFD[Pa\x07\x1Ca'\x95V[`@Qa\x07)\x91\x90a0\xBAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07>W`\0\x80\xFD[Pa\x07Y`\x04\x806\x03\x81\x01\x90a\x07T\x91\x90a3\xDEV[a(:V[`@Qa\x07f\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07{W`\0\x80\xFD[Pa\x07\x84a(RV[`@Qa\x07\x91\x91\x90a1*V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA6W`\0\x80\xFD[Pa\x07\xAFa(zV[`@Qa\x07\xBC\x91\x90a/\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xD1W`\0\x80\xFD[Pa\x07\xDAa(\x92V[`@Qa\x07\xE7\x91\x90a6\xBCV[`@Q\x80\x91\x03\x90\xF3[a\x07\xF8a(\xBAV[`@Qa\x08\x05\x91\x90a2IV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x1AW`\0\x80\xFD[Pa\x085`\x04\x806\x03\x81\x01\x90a\x080\x91\x90a3\xDEV[a,MV[`@Qa\x08B\x91\x90a4$V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08WW`\0\x80\xFD[Pa\x08`a-\x18V[`@Qa\x08m\x91\x90a7\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x82W`\0\x80\xFD[Pa\x08\x8Ba-@V[`@Qa\x08\x9A\x93\x92\x91\x90a7.V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xAFW`\0\x80\xFD[Pa\x08\xB8a-hV[`@Qa\x08\xC5\x91\x90a7\x8DV[`@Q\x80\x91\x03\x90\xF3[`\0`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\t`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0`\x07`\0\x01T\x90P\x90V[`\0\x80`\x02\x81\x11\x15a\t0Wa\t/a0\rV[[`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\tRWa\tQa0\rV[[\x14a\t\x89W`@Q\x7F\xF1\xA9E\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0a\t\x93a-\x90V[\x90P`\0`\x02\x81\x11\x15a\t\xA9Wa\t\xA8a0\rV[[\x81`\x02\x81\x11\x15a\t\xBCWa\t\xBBa0\rV[[\x03a\t\xF3W`@Q\x7F\x92\xC5\x06\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x02\x81\x11\x15a\n\x07Wa\n\x06a0\rV[[\x81`\x02\x81\x11\x15a\n\x1AWa\n\x19a0\rV[[\x03a\n\xB8W`\x01`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\nEWa\nDa0\rV[[\x02\x17\x90UPG`\x05`\0`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xADV[a\n\xC0a'\x95V[a\n\xF6W`@Q\x7F\x04d<9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x04\x81\x11\x15a\x0B\nWa\x0B\ta0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0B/Wa\x0B.a0\rV[[\x03a\x0B\xAFW`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0BZWa\x0BYa0\rV[[\x02\x17\x90UPG`\x05`\0a\x0Bla\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xACV[`\x01`\x04\x81\x11\x15a\x0B\xC3Wa\x0B\xC2a0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0B\xE8Wa\x0B\xE7a0\rV[[\x03a\x0C\x86W`\x01`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0C\x13Wa\x0C\x12a0\rV[[\x02\x17\x90UPG`\x05`\0`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xABV[`\x02`\x04\x81\x11\x15a\x0C\x9AWa\x0C\x99a0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\x0C\xBFWa\x0C\xBEa0\rV[[\x03a\r?W`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x0C\xEAWa\x0C\xE9a0\rV[[\x02\x17\x90UPG`\x05`\0a\x0C\xFCa\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0F\xAAV[`\x03`\x04\x81\x11\x15a\rSWa\rRa0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a\rxWa\rwa0\rV[[\x03a\x0FwW`\x02`\0`\x10a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\r\xA3Wa\r\xA2a0\rV[[\x02\x17\x90UPa\r\xB0a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0EsWG`\x05`\0`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UPa\x0FrV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x05`\0`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Ga\x0F'\x91\x90a7\xD7V[`\x05`\0a\x0F3a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP[a\x0F\xA9V[`@Q\x7Ft\x92\xA2i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[`\x04`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x0F\xD6Wa\x0F\xD5a0\rV[[\x02\x17\x90UPB`\0`\x08a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x10&Wa\x10%a0\rV[[\x7F^\x18o\t\xB9\xC94\x91\xF1N'~\xEA\x7F\xAA]\xE6\xA2\xD4\xBD\xA7Zy\xAFz6\x84\xFB\xFBB\xDA``@Q`@Q\x80\x91\x03\x90\xA2`\0`\x10\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0a\x10\x9Aa'\x95V[\x15a\x10\xD1W`@Q\x7F\xDFF\x9C\xCB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`@Q\x80`\xE0\x01`@R\x80a\x10\xE6a\x18\0V[\x81R` \x01`\x07`\0\x01T\x81R` \x01a\x11\x06a\x11\x01a'\x84V[a.\xD2V[\x81R` \x01a\x11\x13a'#V[\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cAI<`\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`@Q` \x01a\x11\xEE\x91\x90a8\xC6V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x87\x87`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\x1E\x94\x93\x92\x91\x90a9\x1DV[`\0`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x126W`\0\x80\xFD[PZ\xFA\x15\x80\x15a\x12JW=`\0\x80>=`\0\xFD[PPPP3`\x01\x80\x01`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13\x1DW`\x02`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x13\x13Wa\x13\x12a0\rV[[\x02\x17\x90UPa\x13LV[`\x03`\x01`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a\x13FWa\x13Ea0\rV[[\x02\x17\x90UP[`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F^ee\xD9\xCA/\\\x85\x01\xD6A\x8B\xF5c2*rC\xBAz\xCE&mu\xEA\xC9\x9FJ\xDB\xB3\x0B\xA7`@Q`@Q\x80\x91\x03\x90\xA2`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x92\x91PPV[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\0a\x13\xEE`\0a.\xDCV[\x90P\x90V[`\x01\x80`\0\x01`\0\x90T\x90a\x01\0\n\x90\x04c\xFF\xFF\xFF\xFF\x16\x90\x80`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x01\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x02\x01T\x90\x80`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90\x80`\x03\x01`\x01\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x86V[`\x05` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F2.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\x07\x80`\0\x01T\x90\x80`\x01\x01T\x90P\x82V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[``a\x15O`T`$a.\xF8V[\x90P\x90V[a\x15\\a\x18nV[`\0`\x02\x80\x81\x11\x15a\x15qWa\x15pa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x15\x93Wa\x15\x92a0\rV[[\x03a\x15\xDFW`\x06`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa\x16\x94V[`\x01`\x02\x81\x11\x15a\x15\xF3Wa\x15\xF2a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x16\x15Wa\x16\x14a0\rV[[\x03a\x16aW`\x05`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa\x16\x93V[`@Q\x7F\x07\x8A=\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[`\0\x81\x03a\x16\xCEW`@Q\x7F\x17\xBF\xE5\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0`\x06`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`\0`\x05`\0\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP`\0\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Qa\x17~\x90a9\x95V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x17\xBBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x17\xC0V[``\x91P[PP\x90P\x80a\x17\xFBW`@Q\x7F\x83\xE6\xCCk\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPV[`\0a\x18\x0C`4a/0V[\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0`\x07`\x01\x01T\x90P\x90V[`\x02\x80\x81\x11\x15a\x18\x81Wa\x18\x80a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x18\xA3Wa\x18\xA2a0\rV[[\x14\x80a\x18\xE2WP`\x01`\x02\x81\x11\x15a\x18\xBEWa\x18\xBDa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x18\xE0Wa\x18\xDFa0\rV[[\x14[a\x1B\xF6W`\0`\x02\x81\x11\x15a\x18\xFAWa\x18\xF9a0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a\x19\x1CWa\x19\x1Ba0\rV[[\x14a\x19SW`@Q\x7F\x07\x8A=\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x03\x14\xD2\xB30`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\xAE\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xCBW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xEF\x91\x90a:\x12V[\x90P\x80a\x1A(W`@Q\x7FHQ\xBD\x9B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x17\xCF!\xA90`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A\x81\x91\x90a9\xCBV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x1A\x9BW`\0\x80\xFD[PZ\xF1\x92PPP\x80\x15a\x1A\xACWP`\x01[P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cIk\x9C\x160`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1B\x08\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B%W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1BI\x91\x90a:\x12V[\x90P\x80\x15a\x1B\x81W`\x01`\t`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x1BwWa\x1Bva0\rV[[\x02\x17\x90UPa\x1B\xADV[`\x02`\t`\x01a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x02\x81\x11\x15a\x1B\xA7Wa\x1B\xA6a0\rV[[\x02\x17\x90UP[\x7F\x99\x08\xEA\xAC\x06E\xDF\x9D\x07\x04\xD0j\xDC\x9E\x073|\x95\x1D\xE2\xF0k_(6\x15\x1DH\xD5\xE4r/`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`@Qa\x1B\xEB\x91\x90a2\xACV[`@Q\x80\x91\x03\x90\xA1PP[V[`\0a\x1C\x04`ta/IV[\x90P\x90V[`\0`\x11\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x1CPW`@Q\x7F\r\xC1I\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\xD5W`@Q\x7F\x94\r8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1D2%\xE3a\x1D\x19a\x13\xE2V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D5\x91\x90a3\x08V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1DRW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1Dv\x91\x90a:\x12V[a\x1D\xACW`@Q\x7F\xD3\x86\xEF>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`~6\x14a\x1D\xC2Wc\x98$\xBD\xAB`\0R`\x04`\x1C\xFD[c\xFF\xFF\xFF\xFF\x80\x16a\x1D\xD1a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x14a\"{W`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFCa\x1E\"a\x1B\xF8V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1E>\x91\x90a:pV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1E[W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1E\x7F\x91\x90a;!V[\x92PPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x04\xE5\x0F\xED\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1E\xDC\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1E\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\x1D\x91\x90a:\x12V[\x15\x80a\x1F\xBFWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\xA3F\xEA\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F}\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1F\x9AW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\xBE\x91\x90a:\x12V[[\x80a `WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cYX\xA1\x93\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a \x1E\x91\x90a9\xCBV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a ;W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a _\x91\x90a:\x12V[[\x15a \x97W`@Q\x7F4a\x19\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80a!\x19\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBC\xEF;U`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a \xF0W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\x14\x91\x90a;\xA0V[a.\xD2V[\x81R` \x01\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x99s^2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a!iW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\x8D\x91\x90a;\xF9V[\x81RP`\x07`\0\x82\x01Q\x81`\0\x01U` \x82\x01Q\x81`\x01\x01U\x90PP`\x01`\x02\x81\x11\x15a!\xBDWa!\xBCa0\rV[[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c \r.\xD2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\"\x08W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\",\x91\x90a<KV[`\x02\x81\x11\x15a\">Wa\"=a0\rV[[\x03a\"uW`@Q\x7F4a\x19\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[Pa#OV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16crX\xA8\x07\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\"\xF4\x91\x90a6\x92V[`@\x80Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a#\x10W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#4\x91\x90a<\xA4V[`\x07`\0\x01`\0`\x07`\x01\x01`\0\x84\x91\x90PU\x83\x91\x90PUPP[`\x07`\x01\x01Ta#]a'#V[\x11a#\xA6Wa#ja'\x84V[`@Q\x7F\xF4\x029\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\x9D\x91\x90a6\xD7V[`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xC0\x01`@R\x80a#\xB9a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x81R` \x01`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01a$\x06a'\x84V[\x81R` \x01`\0`\x04\x81\x11\x15a$\x1FWa$\x1Ea0\rV[[\x81R` \x01a$W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/eV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba$l\x91\x90a<\xE4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`\x01`\0\x82\x01Q\x81`\0\x01`\0a\x01\0\n\x81T\x81c\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83c\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\0\x01`\x04a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x01\x01`\0a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP``\x82\x01Q\x81`\x02\x01U`\x80\x82\x01Q\x81`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a%eWa%da0\rV[[\x02\x17\x90UP`\xA0\x82\x01Q\x81`\x03\x01`\x01a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x90PP`\x01`\0`\x11a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP4`\x06`\0a%\xC4a\x13\xE2V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x82\x82Ta&\r\x91\x90a<\xE4V[\x92PP\x81\x90UPB`\0\x80a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x9F9|`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&\xCEW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\xF2\x91\x90a=:V[c\xFF\xFF\xFF\xFF\x16\x14`\t`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPV[`\0a'\x1Ea'#V[\x90P\x90V[`\0a'/`Ta/oV[\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0a'\x90`\x14a/0V[\x90P\x90V[`\0Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a'\xCE`\x01`\x03\x01`\x01\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\x88V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x80a(5WP`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01\x80\x01`\0\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x90P\x90V[`\x06` R\x80`\0R`@`\0 `\0\x91P\x90PT\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80`\x04\x81\x11\x15a(\xCFWa(\xCEa0\rV[[`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x04\x81\x11\x15a(\xF4Wa(\xF3a0\rV[[\x14a)+W`@Q\x7F\x85\xC3E\xB0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFFY\xAE}3`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)\x84\x91\x90a3\x08V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a)\xA1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a)\xC5\x91\x90a:\x12V[a)\xFBW`@Q\x7F\xD3\x86\xEF>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a*\x03a'\x95V[\x15a*:W`@Q\x7F\xDFF\x9C\xCB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x004\x14a*\x93W`@Q\x7F\x86 \xAA\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3`\x01`\0\x01`\x04a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x80`\x03\x01`\0a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x04\x81\x11\x15a*\xFFWa*\xFEa0\rV[[\x02\x17\x90UPa+7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/eV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba+L\x91\x90a<\xE4V[`\x01`\x03\x01`\x01a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP4`\x06`\x003s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 `\0\x82\x82Ta+\xC6\x91\x90a<\xE4V[\x92PP\x81\x90UP`\x01`\0\x01`\x04\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x98\x02{8\x15?\x99\\K\x80*\\~ce\xBE\xE3\xAD\xDB%\xAFk)\x81\x8C\x0C0F\x84\xD8\x05,`@Q`@Q\x80\x91\x03\x90\xA2`\x01`\x03\x01`\0\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[`\0`\x02\x80\x81\x11\x15a,bWa,aa0\rV[[`\t`\x01\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x02\x81\x11\x15a,\x84Wa,\x83a0\rV[[\x03a,\xD0W`\x06`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90Pa-\x13V[`\x05`\0\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01`\0 T\x90P[\x91\x90PV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0\x80``a-Ma'4V[\x92Pa-Wa'\x84V[\x91Pa-aa\x15AV[\x90P\x90\x91\x92V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90P\x90V[`\0c\xFF\xFF\xFF\xFF\x80\x16a-\xA1a\x1B\xF8V[c\xFF\xFF\xFF\xFF\x16\x14a.\xCAW`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xBB\x8A\xA1\xFCa-\xF2a\x1B\xF8V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\x0E\x91\x90a:pV[```@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.+W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.O\x91\x90a;!V[\x92PPP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c \r.\xD2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.\x9EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\xC2\x91\x90a<KV[\x91PPa.\xCFV[`\x02\x90P[\x90V[`\0\x81\x90P\x91\x90PV[`\0\x80a.\xE7a/\x92V[\x90P\x82\x81\x015``\x1C\x91PP\x91\x90PV[```\0a/\x04a/\x92V[\x90P`@Q\x91P\x82\x82R\x82\x84\x82\x01` \x84\x017\x82` \x83\x01\x01`\0\x81R` \x81\x01`@RPP\x92\x91PPV[`\0\x80a/;a/\x92V[\x90P\x82\x81\x015\x91PP\x91\x90PV[`\0\x80a/Ta/\x92V[\x90P\x82\x81\x015`\xE0\x1C\x91PP\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0\x80a/za/\x92V[\x90P\x82\x81\x015\x91PP\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0`\x026\x035`\xF0\x1C6\x03\x90P\x90V[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0\x81\x90P\x91\x90PV[`\0a/\xDCa/\xD7a/\xD2\x84a/\xA3V[a/\xB7V[a/\xA3V[\x90P\x91\x90PV[a/\xEC\x81a/\xC1V[\x82RPPV[`\0` \x82\x01\x90Pa0\x07`\0\x83\x01\x84a/\xE3V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`!`\x04R`$`\0\xFD[`\x03\x81\x10a0MWa0La0\rV[[PV[`\0\x81\x90Pa0^\x82a0<V[\x91\x90PV[`\0a0n\x82a0PV[\x90P\x91\x90PV[a0~\x81a0cV[\x82RPPV[`\0` \x82\x01\x90Pa0\x99`\0\x83\x01\x84a0uV[\x92\x91PPV[`\0\x81\x15\x15\x90P\x91\x90PV[a0\xB4\x81a0\x9FV[\x82RPPV[`\0` \x82\x01\x90Pa0\xCF`\0\x83\x01\x84a0\xABV[\x92\x91PPV[`\0\x81\x90P\x91\x90PV[`\0a0\xEA\x82a0\xD5V[\x90P\x91\x90PV[a0\xFA\x81a0\xDFV[\x82RPPV[`\0` \x82\x01\x90Pa1\x15`\0\x83\x01\x84a0\xF1V[\x92\x91PPV[a1$\x81a0\xD5V[\x82RPPV[`\0` \x82\x01\x90Pa1?`\0\x83\x01\x84a1\x1BV[\x92\x91PPV[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\xFD[`\0\x80\x83`\x1F\x84\x01\x12a1tWa1sa1OV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\x91Wa1\x90a1TV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a1\xADWa1\xACa1YV[[\x92P\x92\x90PV[`\0\x80` \x83\x85\x03\x12\x15a1\xCBWa1\xCAa1EV[[`\0\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xE9Wa1\xE8a1JV[[a1\xF5\x85\x82\x86\x01a1^V[\x92P\x92PP\x92P\x92\x90PV[`\x05\x81\x10a2\x12Wa2\x11a0\rV[[PV[`\0\x81\x90Pa2#\x82a2\x01V[\x91\x90PV[`\0a23\x82a2\x15V[\x90P\x91\x90PV[a2C\x81a2(V[\x82RPPV[`\0` \x82\x01\x90Pa2^`\0\x83\x01\x84a2:V[\x92\x91PPV[`\x03\x81\x10a2uWa2ta0\rV[[PV[`\0\x81\x90Pa2\x86\x82a2dV[\x91\x90PV[`\0a2\x96\x82a2xV[\x90P\x91\x90PV[a2\xA6\x81a2\x8BV[\x82RPPV[`\0` \x82\x01\x90Pa2\xC1`\0\x83\x01\x84a2\x9DV[\x92\x91PPV[`\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[`\0a2\xF2\x82a2\xC7V[\x90P\x91\x90PV[a3\x02\x81a2\xE7V[\x82RPPV[`\0` \x82\x01\x90Pa3\x1D`\0\x83\x01\x84a2\xF9V[\x92\x91PPV[`\0c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a3<\x81a3#V[\x82RPPV[a3K\x81a0\xDFV[\x82RPPV[`\0`\xC0\x82\x01\x90Pa3f`\0\x83\x01\x89a33V[a3s` \x83\x01\x88a2\xF9V[a3\x80`@\x83\x01\x87a2\xF9V[a3\x8D``\x83\x01\x86a3BV[a3\x9A`\x80\x83\x01\x85a2:V[a3\xA7`\xA0\x83\x01\x84a/\xE3V[\x97\x96PPPPPPPV[a3\xBB\x81a2\xE7V[\x81\x14a3\xC6W`\0\x80\xFD[PV[`\0\x815\x90Pa3\xD8\x81a3\xB2V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a3\xF4Wa3\xF3a1EV[[`\0a4\x02\x84\x82\x85\x01a3\xC9V[\x91PP\x92\x91PPV[`\0\x81\x90P\x91\x90PV[a4\x1E\x81a4\x0BV[\x82RPPV[`\0` \x82\x01\x90Pa49`\0\x83\x01\x84a4\x15V[\x92\x91PPV[`\0a4Za4Ua4P\x84a2\xC7V[a/\xB7V[a2\xC7V[\x90P\x91\x90PV[`\0a4l\x82a4?V[\x90P\x91\x90PV[`\0a4~\x82a4aV[\x90P\x91\x90PV[a4\x8E\x81a4sV[\x82RPPV[`\0` \x82\x01\x90Pa4\xA9`\0\x83\x01\x84a4\x85V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0[\x83\x81\x10\x15a4\xE9W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa4\xCEV[\x83\x81\x11\x15a4\xF8W`\0\x84\x84\x01R[PPPPV[`\0`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[`\0a5\x1A\x82a4\xAFV[a5$\x81\x85a4\xBAV[\x93Pa54\x81\x85` \x86\x01a4\xCBV[a5=\x81a4\xFEV[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra5b\x81\x84a5\x0FV[\x90P\x92\x91PPV[`\0`@\x82\x01\x90Pa5\x7F`\0\x83\x01\x85a0\xF1V[a5\x8C` \x83\x01\x84a4\x15V[\x93\x92PPPV[`\0a5\x9E\x82a4aV[\x90P\x91\x90PV[a5\xAE\x81a5\x93V[\x82RPPV[`\0` \x82\x01\x90Pa5\xC9`\0\x83\x01\x84a5\xA5V[\x92\x91PPV[`\0\x81Q\x90P\x91\x90PV[`\0\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\0a5\xF6\x82a5\xCFV[a6\0\x81\x85a5\xDAV[\x93Pa6\x10\x81\x85` \x86\x01a4\xCBV[a6\x19\x81a4\xFEV[\x84\x01\x91PP\x92\x91PPV[`\0` \x82\x01\x90P\x81\x81\x03`\0\x83\x01Ra6>\x81\x84a5\xEBV[\x90P\x92\x91PPV[`\0` \x82\x01\x90Pa6[`\0\x83\x01\x84a33V[\x92\x91PPV[`\0a6|a6wa6r\x84a3#V[a/\xB7V[a3#V[\x90P\x91\x90PV[a6\x8C\x81a6aV[\x82RPPV[`\0` \x82\x01\x90Pa6\xA7`\0\x83\x01\x84a6\x83V[\x92\x91PPV[a6\xB6\x81a/\xC1V[\x82RPPV[`\0` \x82\x01\x90Pa6\xD1`\0\x83\x01\x84a6\xADV[\x92\x91PPV[`\0` \x82\x01\x90Pa6\xEC`\0\x83\x01\x84a3BV[\x92\x91PPV[`\0a6\xFD\x82a4aV[\x90P\x91\x90PV[a7\r\x81a6\xF2V[\x82RPPV[`\0` \x82\x01\x90Pa7(`\0\x83\x01\x84a7\x04V[\x92\x91PPV[`\0``\x82\x01\x90Pa7C`\0\x83\x01\x86a6\x83V[a7P` \x83\x01\x85a3BV[\x81\x81\x03`@\x83\x01Ra7b\x81\x84a5\xEBV[\x90P\x94\x93PPPPV[`\0a7w\x82a4aV[\x90P\x91\x90PV[a7\x87\x81a7lV[\x82RPPV[`\0` \x82\x01\x90Pa7\xA2`\0\x83\x01\x84a7~V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0R`\x11`\x04R`$`\0\xFD[`\0a7\xE2\x82a4\x0BV[\x91Pa7\xED\x83a4\x0BV[\x92P\x82\x82\x10\x15a8\0Wa7\xFFa7\xA8V[[\x82\x82\x03\x90P\x92\x91PPV[a8\x14\x81a0\xD5V[\x82RPPV[a8#\x81a4\x0BV[\x82RPPV[a82\x81a2\xE7V[\x82RPPV[`\xE0\x82\x01`\0\x82\x01Qa8N`\0\x85\x01\x82a8\x0BV[P` \x82\x01Qa8a` \x85\x01\x82a8\x0BV[P`@\x82\x01Qa8t`@\x85\x01\x82a8\x0BV[P``\x82\x01Qa8\x87``\x85\x01\x82a8\x1AV[P`\x80\x82\x01Qa8\x9A`\x80\x85\x01\x82a8\x0BV[P`\xA0\x82\x01Qa8\xAD`\xA0\x85\x01\x82a8\x0BV[P`\xC0\x82\x01Qa8\xC0`\xC0\x85\x01\x82a8)V[PPPPV[`\0`\xE0\x82\x01\x90Pa8\xDB`\0\x83\x01\x84a88V[\x92\x91PPV[\x82\x81\x837`\0\x83\x83\x01RPPPV[`\0a8\xFC\x83\x85a5\xDAV[\x93Pa9\t\x83\x85\x84a8\xE1V[a9\x12\x83a4\xFEV[\x84\x01\x90P\x93\x92PPPV[`\0``\x82\x01\x90Pa92`\0\x83\x01\x87a1\x1BV[\x81\x81\x03` \x83\x01Ra9D\x81\x86a5\xEBV[\x90P\x81\x81\x03`@\x83\x01Ra9Y\x81\x84\x86a8\xF0V[\x90P\x95\x94PPPPPV[`\0\x81\x90P\x92\x91PPV[PV[`\0a9\x7F`\0\x83a9dV[\x91Pa9\x8A\x82a9oV[`\0\x82\x01\x90P\x91\x90PV[`\0a9\xA0\x82a9rV[\x91P\x81\x90P\x91\x90PV[`\0a9\xB5\x82a4aV[\x90P\x91\x90PV[a9\xC5\x81a9\xAAV[\x82RPPV[`\0` \x82\x01\x90Pa9\xE0`\0\x83\x01\x84a9\xBCV[\x92\x91PPV[a9\xEF\x81a0\x9FV[\x81\x14a9\xFAW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\x0C\x81a9\xE6V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a:(Wa:'a1EV[[`\0a:6\x84\x82\x85\x01a9\xFDV[\x91PP\x92\x91PPV[`\0a:Za:Ua:P\x84a3#V[a/\xB7V[a4\x0BV[\x90P\x91\x90PV[a:j\x81a:?V[\x82RPPV[`\0` \x82\x01\x90Pa:\x85`\0\x83\x01\x84a:aV[\x92\x91PPV[a:\x94\x81a3#V[\x81\x14a:\x9FW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\xB1\x81a:\x8BV[\x92\x91PPV[a:\xC0\x81a/\xA3V[\x81\x14a:\xCBW`\0\x80\xFD[PV[`\0\x81Q\x90Pa:\xDD\x81a:\xB7V[\x92\x91PPV[`\0a:\xEE\x82a2\xE7V[\x90P\x91\x90PV[a:\xFE\x81a:\xE3V[\x81\x14a;\tW`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\x1B\x81a:\xF5V[\x92\x91PPV[`\0\x80`\0``\x84\x86\x03\x12\x15a;:Wa;9a1EV[[`\0a;H\x86\x82\x87\x01a:\xA2V[\x93PP` a;Y\x86\x82\x87\x01a:\xCEV[\x92PP`@a;j\x86\x82\x87\x01a;\x0CV[\x91PP\x92P\x92P\x92V[a;}\x81a0\xD5V[\x81\x14a;\x88W`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\x9A\x81a;tV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a;\xB6Wa;\xB5a1EV[[`\0a;\xC4\x84\x82\x85\x01a;\x8BV[\x91PP\x92\x91PPV[a;\xD6\x81a4\x0BV[\x81\x14a;\xE1W`\0\x80\xFD[PV[`\0\x81Q\x90Pa;\xF3\x81a;\xCDV[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a<\x0FWa<\x0Ea1EV[[`\0a<\x1D\x84\x82\x85\x01a;\xE4V[\x91PP\x92\x91PPV[`\x03\x81\x10a<3W`\0\x80\xFD[PV[`\0\x81Q\x90Pa<E\x81a<&V[\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a<aWa<`a1EV[[`\0a<o\x84\x82\x85\x01a<6V[\x91PP\x92\x91PPV[a<\x81\x81a0\xD5V[\x81\x14a<\x8CW`\0\x80\xFD[PV[`\0\x81Q\x90Pa<\x9E\x81a<xV[\x92\x91PPV[`\0\x80`@\x83\x85\x03\x12\x15a<\xBBWa<\xBAa1EV[[`\0a<\xC9\x85\x82\x86\x01a<\x8FV[\x92PP` a<\xDA\x85\x82\x86\x01a;\xE4V[\x91PP\x92P\x92\x90PV[`\0a<\xEF\x82a4\x0BV[\x91Pa<\xFA\x83a4\x0BV[\x92P\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x03\x82\x11\x15a=/Wa=.a7\xA8V[[\x82\x82\x01\x90P\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a=PWa=Oa1EV[[`\0a=^\x84\x82\x85\x01a:\xA2V[\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 \xAE\xFE\xFB\x026\xAA\xE9\x97WA\x1B\xA6\xB4\xAE|\xE9\xEDPhY\xFB\x90\xAA\x9B\xB69\x7F&.\xEF\xAF\x1BdsolcC\0\x08\x0F\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BondDistributionMode(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BondDistributionMode> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl BondDistributionMode {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for BondDistributionMode {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<BondDistributionMode> for u8 {
            fn from(value: BondDistributionMode) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BondDistributionMode {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BondDistributionMode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<GameStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl GameStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for GameStatus {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<GameStatus> for u8 {
            fn from(value: GameStatus) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProposalStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ProposalStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl ProposalStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for ProposalStatus {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<ProposalStatus> for u8 {
            fn from(value: ProposalStatus) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ProposalStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ProposalStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Claim(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Claim>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Claim {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(
                value: alloy::sol_types::private::FixedBytes<32>,
            ) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(
                self,
            ) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<alloy::sol_types::private::FixedBytes<32>> for Claim {
            fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Claim> for alloy::sol_types::private::FixedBytes<32> {
            fn from(value: Claim) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Claim {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Claim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Duration(u64);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Duration> for u64 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<64>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Duration {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u64) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u64 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u64> for Duration {
            fn from(value: u64) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Duration> for u64 {
            fn from(value: Duration) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Duration {
            type RustType = u64;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Duration {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameType(u32);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<GameType> for u32 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl GameType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u32) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u32 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u32> for GameType {
            fn from(value: u32) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<GameType> for u32 {
            fn from(value: GameType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameType {
            type RustType = u32;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Hash(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Hash>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Hash {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(
                value: alloy::sol_types::private::FixedBytes<32>,
            ) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(
                self,
            ) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<alloy::sol_types::private::FixedBytes<32>> for Hash {
            fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Hash> for alloy::sol_types::private::FixedBytes<32> {
            fn from(value: Hash) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Hash {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Hash {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Timestamp(u64);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Timestamp> for u64 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<64>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Timestamp {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u64) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u64 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u64> for Timestamp {
            fn from(value: u64) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Timestamp> for u64 {
            fn from(value: Timestamp) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Timestamp {
            type RustType = u64;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                64,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Timestamp {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `BadAuth()` and selector `0xd386ef3e`.
```solidity
error BadAuth();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BadAuth;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BadAuth> for UnderlyingRustTuple<'_> {
            fn from(value: BadAuth) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BadAuth {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BadAuth {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BadAuth()";
            const SELECTOR: [u8; 4] = [211u8, 134u8, 239u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `BondTransferFailed()` and selector `0x83e6cc6b`.
```solidity
error BondTransferFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BondTransferFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BondTransferFailed> for UnderlyingRustTuple<'_> {
            fn from(value: BondTransferFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BondTransferFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BondTransferFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BondTransferFailed()";
            const SELECTOR: [u8; 4] = [131u8, 230u8, 204u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ClaimAlreadyChallenged()` and selector `0x85c345b0`.
```solidity
error ClaimAlreadyChallenged();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimAlreadyChallenged;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimAlreadyChallenged> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimAlreadyChallenged) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimAlreadyChallenged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimAlreadyChallenged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimAlreadyChallenged()";
            const SELECTOR: [u8; 4] = [133u8, 195u8, 69u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ClaimAlreadyResolved()` and selector `0xf1a94581`.
```solidity
error ClaimAlreadyResolved();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimAlreadyResolved;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimAlreadyResolved> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimAlreadyResolved) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimAlreadyResolved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimAlreadyResolved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimAlreadyResolved()";
            const SELECTOR: [u8; 4] = [241u8, 169u8, 69u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `GameNotFinalized()` and selector `0x4851bd9b`.
```solidity
error GameNotFinalized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameNotFinalized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameNotFinalized> for UnderlyingRustTuple<'_> {
            fn from(value: GameNotFinalized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameNotFinalized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GameNotFinalized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GameNotFinalized()";
            const SELECTOR: [u8; 4] = [72u8, 81u8, 189u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `GameNotOver()` and selector `0x04643c39`.
```solidity
error GameNotOver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameNotOver;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameNotOver> for UnderlyingRustTuple<'_> {
            fn from(value: GameNotOver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameNotOver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GameNotOver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GameNotOver()";
            const SELECTOR: [u8; 4] = [4u8, 100u8, 60u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `GameOver()` and selector `0xdf469ccb`.
```solidity
error GameOver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameOver;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameOver> for UnderlyingRustTuple<'_> {
            fn from(value: GameOver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameOver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GameOver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GameOver()";
            const SELECTOR: [u8; 4] = [223u8, 70u8, 156u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `IncorrectBondAmount()` and selector `0x8620aa19`.
```solidity
error IncorrectBondAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncorrectBondAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncorrectBondAmount> for UnderlyingRustTuple<'_> {
            fn from(value: IncorrectBondAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncorrectBondAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncorrectBondAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncorrectBondAmount()";
            const SELECTOR: [u8; 4] = [134u8, 32u8, 170u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `IncorrectDisputeGameFactory()` and selector `0x940d38c7`.
```solidity
error IncorrectDisputeGameFactory();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncorrectDisputeGameFactory;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncorrectDisputeGameFactory>
        for UnderlyingRustTuple<'_> {
            fn from(value: IncorrectDisputeGameFactory) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for IncorrectDisputeGameFactory {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncorrectDisputeGameFactory {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncorrectDisputeGameFactory()";
            const SELECTOR: [u8; 4] = [148u8, 13u8, 56u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `InvalidBondDistributionMode()` and selector `0x078a3df4`.
```solidity
error InvalidBondDistributionMode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBondDistributionMode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBondDistributionMode>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBondDistributionMode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidBondDistributionMode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBondDistributionMode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBondDistributionMode()";
            const SELECTOR: [u8; 4] = [7u8, 138u8, 61u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `InvalidParentGame()` and selector `0x346119f7`.
```solidity
error InvalidParentGame();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidParentGame;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidParentGame> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidParentGame) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidParentGame {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidParentGame {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidParentGame()";
            const SELECTOR: [u8; 4] = [52u8, 97u8, 25u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `InvalidProposalStatus()` and selector `0x7492a269`.
```solidity
error InvalidProposalStatus();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidProposalStatus;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidProposalStatus> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidProposalStatus) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidProposalStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidProposalStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidProposalStatus()";
            const SELECTOR: [u8; 4] = [116u8, 146u8, 162u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `NoCreditToClaim()` and selector `0x17bfe5f7`.
```solidity
error NoCreditToClaim();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoCreditToClaim;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoCreditToClaim> for UnderlyingRustTuple<'_> {
            fn from(value: NoCreditToClaim) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoCreditToClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoCreditToClaim {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoCreditToClaim()";
            const SELECTOR: [u8; 4] = [23u8, 191u8, 229u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `ParentGameNotResolved()` and selector `0x92c506ae`.
```solidity
error ParentGameNotResolved();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ParentGameNotResolved;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ParentGameNotResolved> for UnderlyingRustTuple<'_> {
            fn from(value: ParentGameNotResolved) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ParentGameNotResolved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ParentGameNotResolved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ParentGameNotResolved()";
            const SELECTOR: [u8; 4] = [146u8, 197u8, 6u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Custom error with signature `UnexpectedRootClaim(bytes32)` and selector `0xf40239db`.
```solidity
error UnexpectedRootClaim(Claim rootClaim);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnexpectedRootClaim {
        #[allow(missing_docs)]
        pub rootClaim: <Claim as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (Claim,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (<Claim as alloy::sol_types::SolType>::RustType,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnexpectedRootClaim> for UnderlyingRustTuple<'_> {
            fn from(value: UnexpectedRootClaim) -> Self {
                (value.rootClaim,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnexpectedRootClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { rootClaim: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnexpectedRootClaim {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnexpectedRootClaim(bytes32)";
            const SELECTOR: [u8; 4] = [244u8, 2u8, 57u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Claim as alloy_sol_types::SolType>::tokenize(&self.rootClaim),)
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Event with signature `Challenged(address)` and selector `0x98027b38153f995c4b802a5c7e6365bee3addb25af6b29818c0c304684d8052c`.
```solidity
event Challenged(address indexed challenger);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Challenged {
        #[allow(missing_docs)]
        pub challenger: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Challenged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Challenged(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                152u8, 2u8, 123u8, 56u8, 21u8, 63u8, 153u8, 92u8, 75u8, 128u8, 42u8,
                92u8, 126u8, 99u8, 101u8, 190u8, 227u8, 173u8, 219u8, 37u8, 175u8, 107u8,
                41u8, 129u8, 140u8, 12u8, 48u8, 70u8, 132u8, 216u8, 5u8, 44u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { challenger: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.challenger.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.challenger,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Challenged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Challenged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Challenged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameClosed(uint8)` and selector `0x9908eaac0645df9d0704d06adc9e07337c951de2f06b5f2836151d48d5e4722f`.
```solidity
event GameClosed(BondDistributionMode bondDistributionMode);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameClosed {
        #[allow(missing_docs)]
        pub bondDistributionMode: <BondDistributionMode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameClosed {
            type DataTuple<'a> = (BondDistributionMode,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "GameClosed(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                153u8, 8u8, 234u8, 172u8, 6u8, 69u8, 223u8, 157u8, 7u8, 4u8, 208u8,
                106u8, 220u8, 158u8, 7u8, 51u8, 124u8, 149u8, 29u8, 226u8, 240u8, 107u8,
                95u8, 40u8, 54u8, 21u8, 29u8, 72u8, 213u8, 228u8, 114u8, 47u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bondDistributionMode: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <BondDistributionMode as alloy_sol_types::SolType>::tokenize(
                        &self.bondDistributionMode,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameClosed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameClosed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameClosed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Proved(address)` and selector `0x5e6565d9ca2f5c8501d6418bf563322a7243ba7ace266d75eac99f4adbb30ba7`.
```solidity
event Proved(address indexed prover);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Proved {
        #[allow(missing_docs)]
        pub prover: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Proved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Proved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                94u8, 101u8, 101u8, 217u8, 202u8, 47u8, 92u8, 133u8, 1u8, 214u8, 65u8,
                139u8, 245u8, 99u8, 50u8, 42u8, 114u8, 67u8, 186u8, 122u8, 206u8, 38u8,
                109u8, 117u8, 234u8, 201u8, 159u8, 74u8, 219u8, 179u8, 11u8, 167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { prover: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.prover.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.prover,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Proved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Proved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Proved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Resolved(uint8)` and selector `0x5e186f09b9c93491f14e277eea7faa5de6a2d4bda75a79af7a3684fbfb42da60`.
```solidity
event Resolved(GameStatus indexed status);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Resolved {
        #[allow(missing_docs)]
        pub status: <GameStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Resolved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>, GameStatus);
            const SIGNATURE: &'static str = "Resolved(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                94u8, 24u8, 111u8, 9u8, 185u8, 201u8, 52u8, 145u8, 241u8, 78u8, 39u8,
                126u8, 234u8, 127u8, 170u8, 93u8, 230u8, 162u8, 212u8, 189u8, 167u8,
                90u8, 121u8, 175u8, 122u8, 54u8, 132u8, 251u8, 251u8, 66u8, 218u8, 96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { status: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.status.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <GameStatus as alloy_sol_types::EventTopic>::encode_topic(
                    &self.status,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Resolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Resolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Resolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(Duration _maxChallengeDuration, Duration _maxProveDuration, address _disputeGameFactory, address _sp1Verifier, bytes32 _rollupConfigHash, bytes32 _aggregationVkey, bytes32 _rangeVkeyCommitment, uint256 _challengerBond, address _anchorStateRegistry, address _accessManager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _maxChallengeDuration: <Duration as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _maxProveDuration: <Duration as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _disputeGameFactory: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _sp1Verifier: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _rollupConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _aggregationVkey: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _rangeVkeyCommitment: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _challengerBond: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _anchorStateRegistry: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _accessManager: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                Duration,
                Duration,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Duration as alloy::sol_types::SolType>::RustType,
                <Duration as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._maxChallengeDuration,
                        value._maxProveDuration,
                        value._disputeGameFactory,
                        value._sp1Verifier,
                        value._rollupConfigHash,
                        value._aggregationVkey,
                        value._rangeVkeyCommitment,
                        value._challengerBond,
                        value._anchorStateRegistry,
                        value._accessManager,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _maxChallengeDuration: tuple.0,
                        _maxProveDuration: tuple.1,
                        _disputeGameFactory: tuple.2,
                        _sp1Verifier: tuple.3,
                        _rollupConfigHash: tuple.4,
                        _aggregationVkey: tuple.5,
                        _rangeVkeyCommitment: tuple.6,
                        _challengerBond: tuple.7,
                        _anchorStateRegistry: tuple.8,
                        _accessManager: tuple.9,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                Duration,
                Duration,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Duration as alloy_sol_types::SolType>::tokenize(
                        &self._maxChallengeDuration,
                    ),
                    <Duration as alloy_sol_types::SolType>::tokenize(
                        &self._maxProveDuration,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._disputeGameFactory,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sp1Verifier,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._rollupConfigHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._aggregationVkey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._rangeVkeyCommitment),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._challengerBond),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._anchorStateRegistry,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._accessManager,
                    ),
                )
            }
        }
    };
    /**Function with signature `accessManager()` and selector `0xfdcb6068`.
```solidity
function accessManager() external view returns (address accessManager_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct accessManagerCall;
    ///Container type for the return parameters of the [`accessManager()`](accessManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct accessManagerReturn {
        #[allow(missing_docs)]
        pub accessManager_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<accessManagerCall> for UnderlyingRustTuple<'_> {
                fn from(value: accessManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for accessManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<accessManagerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: accessManagerReturn) -> Self {
                    (value.accessManager_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for accessManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { accessManager_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for accessManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "accessManager()";
            const SELECTOR: [u8; 4] = [253u8, 203u8, 96u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: accessManagerReturn = r.into();
                        r.accessManager_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: accessManagerReturn = r.into();
                        r.accessManager_
                    })
            }
        }
    };
    /**Function with signature `aggregationVkey()` and selector `0xc32e4e3e`.
```solidity
function aggregationVkey() external view returns (bytes32 aggregationVkey_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct aggregationVkeyCall;
    ///Container type for the return parameters of the [`aggregationVkey()`](aggregationVkeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct aggregationVkeyReturn {
        #[allow(missing_docs)]
        pub aggregationVkey_: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<aggregationVkeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: aggregationVkeyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for aggregationVkeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<aggregationVkeyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: aggregationVkeyReturn) -> Self {
                    (value.aggregationVkey_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for aggregationVkeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { aggregationVkey_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for aggregationVkeyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "aggregationVkey()";
            const SELECTOR: [u8; 4] = [195u8, 46u8, 78u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: aggregationVkeyReturn = r.into();
                        r.aggregationVkey_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: aggregationVkeyReturn = r.into();
                        r.aggregationVkey_
                    })
            }
        }
    };
    /**Function with signature `anchorStateRegistry()` and selector `0x5c0cba33`.
```solidity
function anchorStateRegistry() external view returns (address registry_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct anchorStateRegistryCall;
    ///Container type for the return parameters of the [`anchorStateRegistry()`](anchorStateRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct anchorStateRegistryReturn {
        #[allow(missing_docs)]
        pub registry_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<anchorStateRegistryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: anchorStateRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for anchorStateRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<anchorStateRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: anchorStateRegistryReturn) -> Self {
                    (value.registry_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for anchorStateRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { registry_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for anchorStateRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "anchorStateRegistry()";
            const SELECTOR: [u8; 4] = [92u8, 12u8, 186u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: anchorStateRegistryReturn = r.into();
                        r.registry_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: anchorStateRegistryReturn = r.into();
                        r.registry_
                    })
            }
        }
    };
    /**Function with signature `bondDistributionMode()` and selector `0x378dd48c`.
```solidity
function bondDistributionMode() external view returns (BondDistributionMode);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bondDistributionModeCall;
    ///Container type for the return parameters of the [`bondDistributionMode()`](bondDistributionModeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bondDistributionModeReturn {
        #[allow(missing_docs)]
        pub _0: <BondDistributionMode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bondDistributionModeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bondDistributionModeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bondDistributionModeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (BondDistributionMode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BondDistributionMode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bondDistributionModeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bondDistributionModeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bondDistributionModeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bondDistributionModeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <BondDistributionMode as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (BondDistributionMode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bondDistributionMode()";
            const SELECTOR: [u8; 4] = [55u8, 141u8, 212u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<BondDistributionMode as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: bondDistributionModeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: bondDistributionModeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `challenge()` and selector `0xd2ef7398`.
```solidity
function challenge() external payable returns (ProposalStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeCall;
    ///Container type for the return parameters of the [`challenge()`](challengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeReturn {
        #[allow(missing_docs)]
        pub _0: <ProposalStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeCall> for UnderlyingRustTuple<'_> {
                fn from(value: challengeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (ProposalStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ProposalStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: challengeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <ProposalStatus as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (ProposalStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challenge()";
            const SELECTOR: [u8; 4] = [210u8, 239u8, 115u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<ProposalStatus as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: challengeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: challengeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `challengerBond()` and selector `0x68ccdc86`.
```solidity
function challengerBond() external view returns (uint256 challengerBond_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengerBondCall;
    ///Container type for the return parameters of the [`challengerBond()`](challengerBondCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengerBondReturn {
        #[allow(missing_docs)]
        pub challengerBond_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengerBondCall> for UnderlyingRustTuple<'_> {
                fn from(value: challengerBondCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengerBondCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengerBondReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengerBondReturn) -> Self {
                    (value.challengerBond_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengerBondReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { challengerBond_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengerBondCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengerBond()";
            const SELECTOR: [u8; 4] = [104u8, 204u8, 220u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: challengerBondReturn = r.into();
                        r.challengerBond_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: challengerBondReturn = r.into();
                        r.challengerBond_
                    })
            }
        }
    };
    /**Function with signature `claimCredit(address)` and selector `0x60e27464`.
```solidity
function claimCredit(address _recipient) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimCreditCall {
        #[allow(missing_docs)]
        pub _recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`claimCredit(address)`](claimCreditCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimCreditReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimCreditCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimCreditCall) -> Self {
                    (value._recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimCreditCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimCreditReturn> for UnderlyingRustTuple<'_> {
                fn from(value: claimCreditReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimCreditReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimCreditReturn {
            fn _tokenize(
                &self,
            ) -> <claimCreditCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimCreditCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimCreditReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimCredit(address)";
            const SELECTOR: [u8; 4] = [96u8, 226u8, 116u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._recipient,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimCreditReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimData()` and selector `0x3ec4d4d6`.
```solidity
function claimData() external view returns (uint32 parentIndex, address counteredBy, address prover, Claim claim, ProposalStatus status, Timestamp deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimDataCall;
    ///Container type for the return parameters of the [`claimData()`](claimDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimDataReturn {
        #[allow(missing_docs)]
        pub parentIndex: u32,
        #[allow(missing_docs)]
        pub counteredBy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub prover: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub claim: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub status: <ProposalStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub deadline: <Timestamp as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                Claim,
                ProposalStatus,
                Timestamp,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                <Claim as alloy::sol_types::SolType>::RustType,
                <ProposalStatus as alloy::sol_types::SolType>::RustType,
                <Timestamp as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: claimDataReturn) -> Self {
                    (
                        value.parentIndex,
                        value.counteredBy,
                        value.prover,
                        value.claim,
                        value.status,
                        value.deadline,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        parentIndex: tuple.0,
                        counteredBy: tuple.1,
                        prover: tuple.2,
                        claim: tuple.3,
                        status: tuple.4,
                        deadline: tuple.5,
                    }
                }
            }
        }
        impl claimDataReturn {
            fn _tokenize(
                &self,
            ) -> <claimDataCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.counteredBy,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.prover,
                    ),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self.claim),
                    <ProposalStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <Timestamp as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimDataReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                Claim,
                ProposalStatus,
                Timestamp,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimData()";
            const SELECTOR: [u8; 4] = [62u8, 196u8, 212u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimDataReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeGame()` and selector `0x786b844b`.
```solidity
function closeGame() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeGameCall;
    ///Container type for the return parameters of the [`closeGame()`](closeGameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeGameReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeGameCall> for UnderlyingRustTuple<'_> {
                fn from(value: closeGameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeGameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeGameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: closeGameReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeGameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl closeGameReturn {
            fn _tokenize(
                &self,
            ) -> <closeGameCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeGameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeGameReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeGame()";
            const SELECTOR: [u8; 4] = [120u8, 107u8, 132u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                closeGameReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createdAt()` and selector `0xcf09e0d0`.
```solidity
function createdAt() external view returns (Timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createdAtCall;
    ///Container type for the return parameters of the [`createdAt()`](createdAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createdAtReturn {
        #[allow(missing_docs)]
        pub _0: <Timestamp as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createdAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: createdAtCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createdAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Timestamp,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Timestamp as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createdAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createdAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createdAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createdAtCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Timestamp as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Timestamp,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createdAt()";
            const SELECTOR: [u8; 4] = [207u8, 9u8, 224u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Timestamp as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: createdAtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: createdAtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `credit(address)` and selector `0xd5d44d80`.
```solidity
function credit(address _recipient) external view returns (uint256 credit_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct creditCall {
        #[allow(missing_docs)]
        pub _recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`credit(address)`](creditCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct creditReturn {
        #[allow(missing_docs)]
        pub credit_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<creditCall> for UnderlyingRustTuple<'_> {
                fn from(value: creditCall) -> Self {
                    (value._recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for creditCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<creditReturn> for UnderlyingRustTuple<'_> {
                fn from(value: creditReturn) -> Self {
                    (value.credit_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for creditReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { credit_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for creditCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "credit(address)";
            const SELECTOR: [u8; 4] = [213u8, 212u8, 77u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._recipient,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: creditReturn = r.into();
                        r.credit_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: creditReturn = r.into();
                        r.credit_
                    })
            }
        }
    };
    /**Function with signature `disputeGameFactory()` and selector `0xf2b4e617`.
```solidity
function disputeGameFactory() external view returns (address disputeGameFactory_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disputeGameFactoryCall;
    ///Container type for the return parameters of the [`disputeGameFactory()`](disputeGameFactoryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disputeGameFactoryReturn {
        #[allow(missing_docs)]
        pub disputeGameFactory_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disputeGameFactoryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: disputeGameFactoryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disputeGameFactoryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disputeGameFactoryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: disputeGameFactoryReturn) -> Self {
                    (value.disputeGameFactory_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disputeGameFactoryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        disputeGameFactory_: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disputeGameFactoryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disputeGameFactory()";
            const SELECTOR: [u8; 4] = [242u8, 180u8, 230u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: disputeGameFactoryReturn = r.into();
                        r.disputeGameFactory_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: disputeGameFactoryReturn = r.into();
                        r.disputeGameFactory_
                    })
            }
        }
    };
    /**Function with signature `extraData()` and selector `0x609d3334`.
```solidity
function extraData() external pure returns (bytes memory extraData_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extraDataCall;
    ///Container type for the return parameters of the [`extraData()`](extraDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extraDataReturn {
        #[allow(missing_docs)]
        pub extraData_: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extraDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: extraDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extraDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extraDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: extraDataReturn) -> Self {
                    (value.extraData_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extraDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { extraData_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extraDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extraData()";
            const SELECTOR: [u8; 4] = [96u8, 157u8, 51u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: extraDataReturn = r.into();
                        r.extraData_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: extraDataReturn = r.into();
                        r.extraData_
                    })
            }
        }
    };
    /**Function with signature `gameCreator()` and selector `0x37b1b229`.
```solidity
function gameCreator() external pure returns (address creator_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameCreatorCall;
    ///Container type for the return parameters of the [`gameCreator()`](gameCreatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameCreatorReturn {
        #[allow(missing_docs)]
        pub creator_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameCreatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameCreatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameCreatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameCreatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameCreatorReturn) -> Self {
                    (value.creator_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameCreatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { creator_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameCreatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameCreator()";
            const SELECTOR: [u8; 4] = [55u8, 177u8, 178u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameCreatorReturn = r.into();
                        r.creator_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameCreatorReturn = r.into();
                        r.creator_
                    })
            }
        }
    };
    /**Function with signature `gameData()` and selector `0xfa24f743`.
```solidity
function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameDataCall;
    ///Container type for the return parameters of the [`gameData()`](gameDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameDataReturn {
        #[allow(missing_docs)]
        pub gameType_: <GameType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub rootClaim_: <Claim as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub extraData_: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                GameType,
                Claim,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
                <Claim as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameDataReturn) -> Self {
                    (value.gameType_, value.rootClaim_, value.extraData_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gameType_: tuple.0,
                        rootClaim_: tuple.1,
                        extraData_: tuple.2,
                    }
                }
            }
        }
        impl gameDataReturn {
            fn _tokenize(
                &self,
            ) -> <gameDataCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <GameType as alloy_sol_types::SolType>::tokenize(&self.gameType_),
                    <Claim as alloy_sol_types::SolType>::tokenize(&self.rootClaim_),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.extraData_,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = gameDataReturn;
            type ReturnTuple<'a> = (GameType, Claim, alloy::sol_types::sol_data::Bytes);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameData()";
            const SELECTOR: [u8; 4] = [250u8, 36u8, 247u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                gameDataReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `gameOver()` and selector `0xbdb337d1`.
```solidity
function gameOver() external view returns (bool gameOver_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameOverCall;
    ///Container type for the return parameters of the [`gameOver()`](gameOverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameOverReturn {
        #[allow(missing_docs)]
        pub gameOver_: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameOverCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameOverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameOverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameOverReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameOverReturn) -> Self {
                    (value.gameOver_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameOverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { gameOver_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameOverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameOver()";
            const SELECTOR: [u8; 4] = [189u8, 179u8, 55u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameOverReturn = r.into();
                        r.gameOver_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameOverReturn = r.into();
                        r.gameOver_
                    })
            }
        }
    };
    /**Function with signature `gameType()` and selector `0xbbdc02db`.
```solidity
function gameType() external view returns (GameType gameType_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameTypeCall;
    ///Container type for the return parameters of the [`gameType()`](gameTypeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gameTypeReturn {
        #[allow(missing_docs)]
        pub gameType_: <GameType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameTypeCall> for UnderlyingRustTuple<'_> {
                fn from(value: gameTypeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameTypeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gameTypeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gameTypeReturn) -> Self {
                    (value.gameType_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gameTypeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { gameType_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gameTypeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <GameType as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (GameType,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gameType()";
            const SELECTOR: [u8; 4] = [187u8, 220u8, 2u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<GameType as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gameTypeReturn = r.into();
                        r.gameType_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gameTypeReturn = r.into();
                        r.gameType_
                    })
            }
        }
    };
    /**Function with signature `initialize()` and selector `0x8129fc1c`.
```solidity
function initialize() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall;
    ///Container type for the return parameters of the [`initialize()`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize()";
            const SELECTOR: [u8; 4] = [129u8, 41u8, 252u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l1Head()` and selector `0x6361506d`.
```solidity
function l1Head() external pure returns (Hash l1Head_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1HeadCall;
    ///Container type for the return parameters of the [`l1Head()`](l1HeadCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1HeadReturn {
        #[allow(missing_docs)]
        pub l1Head_: <Hash as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1HeadCall> for UnderlyingRustTuple<'_> {
                fn from(value: l1HeadCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1HeadCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Hash,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Hash as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1HeadReturn> for UnderlyingRustTuple<'_> {
                fn from(value: l1HeadReturn) -> Self {
                    (value.l1Head_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1HeadReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { l1Head_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l1HeadCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Hash as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Hash,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l1Head()";
            const SELECTOR: [u8; 4] = [99u8, 97u8, 80u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Hash as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: l1HeadReturn = r.into();
                        r.l1Head_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: l1HeadReturn = r.into();
                        r.l1Head_
                    })
            }
        }
    };
    /**Function with signature `l2BlockNumber()` and selector `0x8b85902b`.
```solidity
function l2BlockNumber() external pure returns (uint256 l2BlockNumber_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2BlockNumberCall;
    ///Container type for the return parameters of the [`l2BlockNumber()`](l2BlockNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2BlockNumberReturn {
        #[allow(missing_docs)]
        pub l2BlockNumber_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2BlockNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: l2BlockNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l2BlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2BlockNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: l2BlockNumberReturn) -> Self {
                    (value.l2BlockNumber_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l2BlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { l2BlockNumber_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l2BlockNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l2BlockNumber()";
            const SELECTOR: [u8; 4] = [139u8, 133u8, 144u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: l2BlockNumberReturn = r.into();
                        r.l2BlockNumber_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: l2BlockNumberReturn = r.into();
                        r.l2BlockNumber_
                    })
            }
        }
    };
    /**Function with signature `l2SequenceNumber()` and selector `0x99735e32`.
```solidity
function l2SequenceNumber() external pure returns (uint256 l2SequenceNumber_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2SequenceNumberCall;
    ///Container type for the return parameters of the [`l2SequenceNumber()`](l2SequenceNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2SequenceNumberReturn {
        #[allow(missing_docs)]
        pub l2SequenceNumber_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2SequenceNumberCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2SequenceNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2SequenceNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2SequenceNumberReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2SequenceNumberReturn) -> Self {
                    (value.l2SequenceNumber_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2SequenceNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { l2SequenceNumber_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l2SequenceNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l2SequenceNumber()";
            const SELECTOR: [u8; 4] = [153u8, 115u8, 94u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: l2SequenceNumberReturn = r.into();
                        r.l2SequenceNumber_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: l2SequenceNumberReturn = r.into();
                        r.l2SequenceNumber_
                    })
            }
        }
    };
    /**Function with signature `maxChallengeDuration()` and selector `0xd2177bdd`.
```solidity
function maxChallengeDuration() external view returns (Duration maxChallengeDuration_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxChallengeDurationCall;
    ///Container type for the return parameters of the [`maxChallengeDuration()`](maxChallengeDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxChallengeDurationReturn {
        #[allow(missing_docs)]
        pub maxChallengeDuration_: <Duration as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxChallengeDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxChallengeDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxChallengeDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Duration,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Duration as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxChallengeDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxChallengeDurationReturn) -> Self {
                    (value.maxChallengeDuration_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxChallengeDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxChallengeDuration_: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxChallengeDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Duration as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Duration,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxChallengeDuration()";
            const SELECTOR: [u8; 4] = [210u8, 23u8, 123u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Duration as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: maxChallengeDurationReturn = r.into();
                        r.maxChallengeDuration_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: maxChallengeDurationReturn = r.into();
                        r.maxChallengeDuration_
                    })
            }
        }
    };
    /**Function with signature `maxProveDuration()` and selector `0xbcbe5094`.
```solidity
function maxProveDuration() external view returns (Duration maxProveDuration_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxProveDurationCall;
    ///Container type for the return parameters of the [`maxProveDuration()`](maxProveDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxProveDurationReturn {
        #[allow(missing_docs)]
        pub maxProveDuration_: <Duration as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxProveDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxProveDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxProveDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Duration,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Duration as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxProveDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxProveDurationReturn) -> Self {
                    (value.maxProveDuration_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxProveDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { maxProveDuration_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxProveDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Duration as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Duration,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxProveDuration()";
            const SELECTOR: [u8; 4] = [188u8, 190u8, 80u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Duration as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: maxProveDurationReturn = r.into();
                        r.maxProveDuration_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: maxProveDurationReturn = r.into();
                        r.maxProveDuration_
                    })
            }
        }
    };
    /**Function with signature `normalModeCredit(address)` and selector `0x529d6a8c`.
```solidity
function normalModeCredit(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct normalModeCreditCall(pub alloy::sol_types::private::Address);
    ///Container type for the return parameters of the [`normalModeCredit(address)`](normalModeCreditCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct normalModeCreditReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<normalModeCreditCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: normalModeCreditCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for normalModeCreditCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<normalModeCreditReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: normalModeCreditReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for normalModeCreditReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for normalModeCreditCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "normalModeCredit(address)";
            const SELECTOR: [u8; 4] = [82u8, 157u8, 106u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: normalModeCreditReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: normalModeCreditReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `parentIndex()` and selector `0x7948690a`.
```solidity
function parentIndex() external pure returns (uint32 parentIndex_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parentIndexCall;
    ///Container type for the return parameters of the [`parentIndex()`](parentIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parentIndexReturn {
        #[allow(missing_docs)]
        pub parentIndex_: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parentIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: parentIndexCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parentIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parentIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parentIndexReturn) -> Self {
                    (value.parentIndex_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parentIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parentIndex_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parentIndexCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u32;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parentIndex()";
            const SELECTOR: [u8; 4] = [121u8, 72u8, 105u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: parentIndexReturn = r.into();
                        r.parentIndex_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: parentIndexReturn = r.into();
                        r.parentIndex_
                    })
            }
        }
    };
    /**Function with signature `prove(bytes)` and selector `0x375bfa5d`.
```solidity
function prove(bytes memory proofBytes) external returns (ProposalStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveCall {
        #[allow(missing_docs)]
        pub proofBytes: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`prove(bytes)`](proveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveReturn {
        #[allow(missing_docs)]
        pub _0: <ProposalStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveCall) -> Self {
                    (value.proofBytes,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { proofBytes: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (ProposalStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ProposalStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <ProposalStatus as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (ProposalStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "prove(bytes)";
            const SELECTOR: [u8; 4] = [55u8, 91u8, 250u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proofBytes,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<ProposalStatus as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proveReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proveReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `rangeVkeyCommitment()` and selector `0x2b31841e`.
```solidity
function rangeVkeyCommitment() external view returns (bytes32 rangeVkeyCommitment_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rangeVkeyCommitmentCall;
    ///Container type for the return parameters of the [`rangeVkeyCommitment()`](rangeVkeyCommitmentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rangeVkeyCommitmentReturn {
        #[allow(missing_docs)]
        pub rangeVkeyCommitment_: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rangeVkeyCommitmentCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: rangeVkeyCommitmentCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rangeVkeyCommitmentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rangeVkeyCommitmentReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: rangeVkeyCommitmentReturn) -> Self {
                    (value.rangeVkeyCommitment_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rangeVkeyCommitmentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rangeVkeyCommitment_: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rangeVkeyCommitmentCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rangeVkeyCommitment()";
            const SELECTOR: [u8; 4] = [43u8, 49u8, 132u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: rangeVkeyCommitmentReturn = r.into();
                        r.rangeVkeyCommitment_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: rangeVkeyCommitmentReturn = r.into();
                        r.rangeVkeyCommitment_
                    })
            }
        }
    };
    /**Function with signature `refundModeCredit(address)` and selector `0xc0d8bb74`.
```solidity
function refundModeCredit(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundModeCreditCall(pub alloy::sol_types::private::Address);
    ///Container type for the return parameters of the [`refundModeCredit(address)`](refundModeCreditCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundModeCreditReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundModeCreditCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: refundModeCreditCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refundModeCreditCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundModeCreditReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: refundModeCreditReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refundModeCreditReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refundModeCreditCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refundModeCredit(address)";
            const SELECTOR: [u8; 4] = [192u8, 216u8, 187u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: refundModeCreditReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: refundModeCreditReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `resolve()` and selector `0x2810e1d6`.
```solidity
function resolve() external returns (GameStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveCall;
    ///Container type for the return parameters of the [`resolve()`](resolveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveReturn {
        #[allow(missing_docs)]
        pub _0: <GameStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveCall> for UnderlyingRustTuple<'_> {
                fn from(value: resolveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resolveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <GameStatus as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (GameStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolve()";
            const SELECTOR: [u8; 4] = [40u8, 16u8, 225u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<GameStatus as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: resolveReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: resolveReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `resolvedAt()` and selector `0x19effeb4`.
```solidity
function resolvedAt() external view returns (Timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolvedAtCall;
    ///Container type for the return parameters of the [`resolvedAt()`](resolvedAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolvedAtReturn {
        #[allow(missing_docs)]
        pub _0: <Timestamp as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolvedAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: resolvedAtCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolvedAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Timestamp,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Timestamp as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolvedAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resolvedAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolvedAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolvedAtCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Timestamp as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Timestamp,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolvedAt()";
            const SELECTOR: [u8; 4] = [25u8, 239u8, 254u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Timestamp as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: resolvedAtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: resolvedAtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `rollupConfigHash()` and selector `0x6d9a1c8b`.
```solidity
function rollupConfigHash() external view returns (bytes32 rollupConfigHash_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rollupConfigHashCall;
    ///Container type for the return parameters of the [`rollupConfigHash()`](rollupConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rollupConfigHashReturn {
        #[allow(missing_docs)]
        pub rollupConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rollupConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: rollupConfigHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rollupConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rollupConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: rollupConfigHashReturn) -> Self {
                    (value.rollupConfigHash_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rollupConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { rollupConfigHash_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rollupConfigHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rollupConfigHash()";
            const SELECTOR: [u8; 4] = [109u8, 154u8, 28u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: rollupConfigHashReturn = r.into();
                        r.rollupConfigHash_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: rollupConfigHashReturn = r.into();
                        r.rollupConfigHash_
                    })
            }
        }
    };
    /**Function with signature `rootClaim()` and selector `0xbcef3b55`.
```solidity
function rootClaim() external pure returns (Claim rootClaim_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootClaimCall;
    ///Container type for the return parameters of the [`rootClaim()`](rootClaimCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootClaimReturn {
        #[allow(missing_docs)]
        pub rootClaim_: <Claim as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootClaimCall> for UnderlyingRustTuple<'_> {
                fn from(value: rootClaimCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootClaimCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Claim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Claim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootClaimReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rootClaimReturn) -> Self {
                    (value.rootClaim_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootClaimReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { rootClaim_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rootClaimCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Claim as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Claim,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rootClaim()";
            const SELECTOR: [u8; 4] = [188u8, 239u8, 59u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Claim as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: rootClaimReturn = r.into();
                        r.rootClaim_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: rootClaimReturn = r.into();
                        r.rootClaim_
                    })
            }
        }
    };
    /**Function with signature `sp1Verifier()` and selector `0x52a07fa3`.
```solidity
function sp1Verifier() external view returns (address verifier_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sp1VerifierCall;
    ///Container type for the return parameters of the [`sp1Verifier()`](sp1VerifierCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sp1VerifierReturn {
        #[allow(missing_docs)]
        pub verifier_: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sp1VerifierCall> for UnderlyingRustTuple<'_> {
                fn from(value: sp1VerifierCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sp1VerifierCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sp1VerifierReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sp1VerifierReturn) -> Self {
                    (value.verifier_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sp1VerifierReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { verifier_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sp1VerifierCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sp1Verifier()";
            const SELECTOR: [u8; 4] = [82u8, 160u8, 127u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: sp1VerifierReturn = r.into();
                        r.verifier_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: sp1VerifierReturn = r.into();
                        r.verifier_
                    })
            }
        }
    };
    /**Function with signature `startingBlockNumber()` and selector `0x70872aa5`.
```solidity
function startingBlockNumber() external view returns (uint256 startingBlockNumber_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingBlockNumberCall;
    ///Container type for the return parameters of the [`startingBlockNumber()`](startingBlockNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingBlockNumberReturn {
        #[allow(missing_docs)]
        pub startingBlockNumber_: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingBlockNumberCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingBlockNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingBlockNumberReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingBlockNumberReturn) -> Self {
                    (value.startingBlockNumber_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockNumber_: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startingBlockNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startingBlockNumber()";
            const SELECTOR: [u8; 4] = [112u8, 135u8, 42u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: startingBlockNumberReturn = r.into();
                        r.startingBlockNumber_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: startingBlockNumberReturn = r.into();
                        r.startingBlockNumber_
                    })
            }
        }
    };
    /**Function with signature `startingOutputRoot()` and selector `0x57da950e`.
```solidity
function startingOutputRoot() external view returns (Hash root, uint256 l2SequenceNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingOutputRootCall;
    ///Container type for the return parameters of the [`startingOutputRoot()`](startingOutputRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingOutputRootReturn {
        #[allow(missing_docs)]
        pub root: <Hash as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub l2SequenceNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingOutputRootCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingOutputRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingOutputRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Hash, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Hash as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingOutputRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingOutputRootReturn) -> Self {
                    (value.root, value.l2SequenceNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingOutputRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        root: tuple.0,
                        l2SequenceNumber: tuple.1,
                    }
                }
            }
        }
        impl startingOutputRootReturn {
            fn _tokenize(
                &self,
            ) -> <startingOutputRootCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <Hash as alloy_sol_types::SolType>::tokenize(&self.root),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2SequenceNumber),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startingOutputRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startingOutputRootReturn;
            type ReturnTuple<'a> = (Hash, alloy::sol_types::sol_data::Uint<256>);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startingOutputRoot()";
            const SELECTOR: [u8; 4] = [87u8, 218u8, 149u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                startingOutputRootReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startingRootHash()` and selector `0x25fc2ace`.
```solidity
function startingRootHash() external view returns (Hash startingRootHash_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingRootHashCall;
    ///Container type for the return parameters of the [`startingRootHash()`](startingRootHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startingRootHashReturn {
        #[allow(missing_docs)]
        pub startingRootHash_: <Hash as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingRootHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingRootHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingRootHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Hash,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Hash as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startingRootHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startingRootHashReturn) -> Self {
                    (value.startingRootHash_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startingRootHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { startingRootHash_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startingRootHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Hash as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Hash,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startingRootHash()";
            const SELECTOR: [u8; 4] = [37u8, 252u8, 42u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Hash as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: startingRootHashReturn = r.into();
                        r.startingRootHash_
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: startingRootHashReturn = r.into();
                        r.startingRootHash_
                    })
            }
        }
    };
    /**Function with signature `status()` and selector `0x200d2ed2`.
```solidity
function status() external view returns (GameStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct statusCall;
    ///Container type for the return parameters of the [`status()`](statusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct statusReturn {
        #[allow(missing_docs)]
        pub _0: <GameStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<statusCall> for UnderlyingRustTuple<'_> {
                fn from(value: statusCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for statusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (GameStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<statusReturn> for UnderlyingRustTuple<'_> {
                fn from(value: statusReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for statusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for statusCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <GameStatus as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (GameStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "status()";
            const SELECTOR: [u8; 4] = [32u8, 13u8, 46u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<GameStatus as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: statusReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: statusReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `version()` and selector `0x54fd4d50`.
```solidity
function version() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionCall;
    ///Container type for the return parameters of the [`version()`](versionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionCall> for UnderlyingRustTuple<'_> {
                fn from(value: versionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: versionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for versionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "version()";
            const SELECTOR: [u8; 4] = [84u8, 253u8, 77u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    /**Function with signature `wasRespectedGameTypeWhenCreated()` and selector `0x250e69bd`.
```solidity
function wasRespectedGameTypeWhenCreated() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasRespectedGameTypeWhenCreatedCall;
    ///Container type for the return parameters of the [`wasRespectedGameTypeWhenCreated()`](wasRespectedGameTypeWhenCreatedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasRespectedGameTypeWhenCreatedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasRespectedGameTypeWhenCreatedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: wasRespectedGameTypeWhenCreatedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for wasRespectedGameTypeWhenCreatedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasRespectedGameTypeWhenCreatedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: wasRespectedGameTypeWhenCreatedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for wasRespectedGameTypeWhenCreatedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for wasRespectedGameTypeWhenCreatedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "wasRespectedGameTypeWhenCreated()";
            const SELECTOR: [u8; 4] = [37u8, 14u8, 105u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: wasRespectedGameTypeWhenCreatedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: wasRespectedGameTypeWhenCreatedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`OPSuccinctFaultDisputeGame`](self) function calls.
    #[derive(Clone)]
    pub enum OPSuccinctFaultDisputeGameCalls {
        #[allow(missing_docs)]
        accessManager(accessManagerCall),
        #[allow(missing_docs)]
        aggregationVkey(aggregationVkeyCall),
        #[allow(missing_docs)]
        anchorStateRegistry(anchorStateRegistryCall),
        #[allow(missing_docs)]
        bondDistributionMode(bondDistributionModeCall),
        #[allow(missing_docs)]
        challenge(challengeCall),
        #[allow(missing_docs)]
        challengerBond(challengerBondCall),
        #[allow(missing_docs)]
        claimCredit(claimCreditCall),
        #[allow(missing_docs)]
        claimData(claimDataCall),
        #[allow(missing_docs)]
        closeGame(closeGameCall),
        #[allow(missing_docs)]
        createdAt(createdAtCall),
        #[allow(missing_docs)]
        credit(creditCall),
        #[allow(missing_docs)]
        disputeGameFactory(disputeGameFactoryCall),
        #[allow(missing_docs)]
        extraData(extraDataCall),
        #[allow(missing_docs)]
        gameCreator(gameCreatorCall),
        #[allow(missing_docs)]
        gameData(gameDataCall),
        #[allow(missing_docs)]
        gameOver(gameOverCall),
        #[allow(missing_docs)]
        gameType(gameTypeCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        l1Head(l1HeadCall),
        #[allow(missing_docs)]
        l2BlockNumber(l2BlockNumberCall),
        #[allow(missing_docs)]
        l2SequenceNumber(l2SequenceNumberCall),
        #[allow(missing_docs)]
        maxChallengeDuration(maxChallengeDurationCall),
        #[allow(missing_docs)]
        maxProveDuration(maxProveDurationCall),
        #[allow(missing_docs)]
        normalModeCredit(normalModeCreditCall),
        #[allow(missing_docs)]
        parentIndex(parentIndexCall),
        #[allow(missing_docs)]
        prove(proveCall),
        #[allow(missing_docs)]
        rangeVkeyCommitment(rangeVkeyCommitmentCall),
        #[allow(missing_docs)]
        refundModeCredit(refundModeCreditCall),
        #[allow(missing_docs)]
        resolve(resolveCall),
        #[allow(missing_docs)]
        resolvedAt(resolvedAtCall),
        #[allow(missing_docs)]
        rollupConfigHash(rollupConfigHashCall),
        #[allow(missing_docs)]
        rootClaim(rootClaimCall),
        #[allow(missing_docs)]
        sp1Verifier(sp1VerifierCall),
        #[allow(missing_docs)]
        startingBlockNumber(startingBlockNumberCall),
        #[allow(missing_docs)]
        startingOutputRoot(startingOutputRootCall),
        #[allow(missing_docs)]
        startingRootHash(startingRootHashCall),
        #[allow(missing_docs)]
        status(statusCall),
        #[allow(missing_docs)]
        version(versionCall),
        #[allow(missing_docs)]
        wasRespectedGameTypeWhenCreated(wasRespectedGameTypeWhenCreatedCall),
    }
    impl OPSuccinctFaultDisputeGameCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [25u8, 239u8, 254u8, 180u8],
            [32u8, 13u8, 46u8, 210u8],
            [37u8, 14u8, 105u8, 189u8],
            [37u8, 252u8, 42u8, 206u8],
            [40u8, 16u8, 225u8, 214u8],
            [43u8, 49u8, 132u8, 30u8],
            [55u8, 91u8, 250u8, 93u8],
            [55u8, 141u8, 212u8, 140u8],
            [55u8, 177u8, 178u8, 41u8],
            [62u8, 196u8, 212u8, 214u8],
            [82u8, 157u8, 106u8, 140u8],
            [82u8, 160u8, 127u8, 163u8],
            [84u8, 253u8, 77u8, 80u8],
            [87u8, 218u8, 149u8, 14u8],
            [92u8, 12u8, 186u8, 51u8],
            [96u8, 157u8, 51u8, 52u8],
            [96u8, 226u8, 116u8, 100u8],
            [99u8, 97u8, 80u8, 109u8],
            [104u8, 204u8, 220u8, 134u8],
            [109u8, 154u8, 28u8, 139u8],
            [112u8, 135u8, 42u8, 165u8],
            [120u8, 107u8, 132u8, 75u8],
            [121u8, 72u8, 105u8, 10u8],
            [129u8, 41u8, 252u8, 28u8],
            [139u8, 133u8, 144u8, 43u8],
            [153u8, 115u8, 94u8, 50u8],
            [187u8, 220u8, 2u8, 219u8],
            [188u8, 190u8, 80u8, 148u8],
            [188u8, 239u8, 59u8, 85u8],
            [189u8, 179u8, 55u8, 209u8],
            [192u8, 216u8, 187u8, 116u8],
            [195u8, 46u8, 78u8, 62u8],
            [207u8, 9u8, 224u8, 208u8],
            [210u8, 23u8, 123u8, 221u8],
            [210u8, 239u8, 115u8, 152u8],
            [213u8, 212u8, 77u8, 128u8],
            [242u8, 180u8, 230u8, 23u8],
            [250u8, 36u8, 247u8, 67u8],
            [253u8, 203u8, 96u8, 104u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(resolvedAt),
            ::core::stringify!(status),
            ::core::stringify!(wasRespectedGameTypeWhenCreated),
            ::core::stringify!(startingRootHash),
            ::core::stringify!(resolve),
            ::core::stringify!(rangeVkeyCommitment),
            ::core::stringify!(prove),
            ::core::stringify!(bondDistributionMode),
            ::core::stringify!(gameCreator),
            ::core::stringify!(claimData),
            ::core::stringify!(normalModeCredit),
            ::core::stringify!(sp1Verifier),
            ::core::stringify!(version),
            ::core::stringify!(startingOutputRoot),
            ::core::stringify!(anchorStateRegistry),
            ::core::stringify!(extraData),
            ::core::stringify!(claimCredit),
            ::core::stringify!(l1Head),
            ::core::stringify!(challengerBond),
            ::core::stringify!(rollupConfigHash),
            ::core::stringify!(startingBlockNumber),
            ::core::stringify!(closeGame),
            ::core::stringify!(parentIndex),
            ::core::stringify!(initialize),
            ::core::stringify!(l2BlockNumber),
            ::core::stringify!(l2SequenceNumber),
            ::core::stringify!(gameType),
            ::core::stringify!(maxProveDuration),
            ::core::stringify!(rootClaim),
            ::core::stringify!(gameOver),
            ::core::stringify!(refundModeCredit),
            ::core::stringify!(aggregationVkey),
            ::core::stringify!(createdAt),
            ::core::stringify!(maxChallengeDuration),
            ::core::stringify!(challenge),
            ::core::stringify!(credit),
            ::core::stringify!(disputeGameFactory),
            ::core::stringify!(gameData),
            ::core::stringify!(accessManager),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <resolvedAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <statusCall as alloy_sol_types::SolCall>::SIGNATURE,
            <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <startingRootHashCall as alloy_sol_types::SolCall>::SIGNATURE,
            <resolveCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bondDistributionModeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameCreatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimDataCall as alloy_sol_types::SolCall>::SIGNATURE,
            <normalModeCreditCall as alloy_sol_types::SolCall>::SIGNATURE,
            <sp1VerifierCall as alloy_sol_types::SolCall>::SIGNATURE,
            <versionCall as alloy_sol_types::SolCall>::SIGNATURE,
            <startingOutputRootCall as alloy_sol_types::SolCall>::SIGNATURE,
            <anchorStateRegistryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <extraDataCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimCreditCall as alloy_sol_types::SolCall>::SIGNATURE,
            <l1HeadCall as alloy_sol_types::SolCall>::SIGNATURE,
            <challengerBondCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rollupConfigHashCall as alloy_sol_types::SolCall>::SIGNATURE,
            <startingBlockNumberCall as alloy_sol_types::SolCall>::SIGNATURE,
            <closeGameCall as alloy_sol_types::SolCall>::SIGNATURE,
            <parentIndexCall as alloy_sol_types::SolCall>::SIGNATURE,
            <initializeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <l2BlockNumberCall as alloy_sol_types::SolCall>::SIGNATURE,
            <l2SequenceNumberCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameTypeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <maxProveDurationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rootClaimCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameOverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <refundModeCreditCall as alloy_sol_types::SolCall>::SIGNATURE,
            <aggregationVkeyCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createdAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <maxChallengeDurationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <challengeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <creditCall as alloy_sol_types::SolCall>::SIGNATURE,
            <disputeGameFactoryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <gameDataCall as alloy_sol_types::SolCall>::SIGNATURE,
            <accessManagerCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for OPSuccinctFaultDisputeGameCalls {
        const NAME: &'static str = "OPSuccinctFaultDisputeGameCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 39usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::accessManager(_) => {
                    <accessManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::aggregationVkey(_) => {
                    <aggregationVkeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::anchorStateRegistry(_) => {
                    <anchorStateRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bondDistributionMode(_) => {
                    <bondDistributionModeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challenge(_) => {
                    <challengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengerBond(_) => {
                    <challengerBondCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimCredit(_) => {
                    <claimCreditCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimData(_) => {
                    <claimDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeGame(_) => {
                    <closeGameCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createdAt(_) => {
                    <createdAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::credit(_) => <creditCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::disputeGameFactory(_) => {
                    <disputeGameFactoryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::extraData(_) => {
                    <extraDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gameCreator(_) => {
                    <gameCreatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gameData(_) => <gameDataCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::gameOver(_) => <gameOverCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::gameType(_) => <gameTypeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l1Head(_) => <l1HeadCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::l2BlockNumber(_) => {
                    <l2BlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l2SequenceNumber(_) => {
                    <l2SequenceNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxChallengeDuration(_) => {
                    <maxChallengeDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxProveDuration(_) => {
                    <maxProveDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::normalModeCredit(_) => {
                    <normalModeCreditCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parentIndex(_) => {
                    <parentIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::prove(_) => <proveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rangeVkeyCommitment(_) => {
                    <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refundModeCredit(_) => {
                    <refundModeCreditCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolve(_) => <resolveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::resolvedAt(_) => {
                    <resolvedAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rollupConfigHash(_) => {
                    <rollupConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rootClaim(_) => {
                    <rootClaimCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sp1Verifier(_) => {
                    <sp1VerifierCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startingBlockNumber(_) => {
                    <startingBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startingOutputRoot(_) => {
                    <startingOutputRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startingRootHash(_) => {
                    <startingRootHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::status(_) => <statusCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::version(_) => <versionCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::wasRespectedGameTypeWhenCreated(_) => {
                    <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls>] = &[
                {
                    fn resolvedAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <resolvedAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::resolvedAt)
                    }
                    resolvedAt
                },
                {
                    fn status(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <statusCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::status)
                    }
                    status
                },
                {
                    fn wasRespectedGameTypeWhenCreated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameCalls::wasRespectedGameTypeWhenCreated,
                            )
                    }
                    wasRespectedGameTypeWhenCreated
                },
                {
                    fn startingRootHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingRootHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingRootHash)
                    }
                    startingRootHash
                },
                {
                    fn resolve(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <resolveCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::resolve)
                    }
                    resolve
                },
                {
                    fn rangeVkeyCommitment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::rangeVkeyCommitment)
                    }
                    rangeVkeyCommitment
                },
                {
                    fn prove(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <proveCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::prove)
                    }
                    prove
                },
                {
                    fn bondDistributionMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <bondDistributionModeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::bondDistributionMode)
                    }
                    bondDistributionMode
                },
                {
                    fn gameCreator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameCreatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::gameCreator)
                    }
                    gameCreator
                },
                {
                    fn claimData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <claimDataCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::claimData)
                    }
                    claimData
                },
                {
                    fn normalModeCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <normalModeCreditCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::normalModeCredit)
                    }
                    normalModeCredit
                },
                {
                    fn sp1Verifier(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <sp1VerifierCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::sp1Verifier)
                    }
                    sp1Verifier
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::version)
                    }
                    version
                },
                {
                    fn startingOutputRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingOutputRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingOutputRoot)
                    }
                    startingOutputRoot
                },
                {
                    fn anchorStateRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <anchorStateRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::anchorStateRegistry)
                    }
                    anchorStateRegistry
                },
                {
                    fn extraData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <extraDataCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::extraData)
                    }
                    extraData
                },
                {
                    fn claimCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <claimCreditCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::claimCredit)
                    }
                    claimCredit
                },
                {
                    fn l1Head(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l1HeadCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::l1Head)
                    }
                    l1Head
                },
                {
                    fn challengerBond(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <challengerBondCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::challengerBond)
                    }
                    challengerBond
                },
                {
                    fn rollupConfigHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rollupConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::rollupConfigHash)
                    }
                    rollupConfigHash
                },
                {
                    fn startingBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingBlockNumber)
                    }
                    startingBlockNumber
                },
                {
                    fn closeGame(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <closeGameCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::closeGame)
                    }
                    closeGame
                },
                {
                    fn parentIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <parentIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::parentIndex)
                    }
                    parentIndex
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::initialize)
                    }
                    initialize
                },
                {
                    fn l2BlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l2BlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::l2BlockNumber)
                    }
                    l2BlockNumber
                },
                {
                    fn l2SequenceNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l2SequenceNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::l2SequenceNumber)
                    }
                    l2SequenceNumber
                },
                {
                    fn gameType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameTypeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::gameType)
                    }
                    gameType
                },
                {
                    fn maxProveDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <maxProveDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::maxProveDuration)
                    }
                    maxProveDuration
                },
                {
                    fn rootClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rootClaimCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::rootClaim)
                    }
                    rootClaim
                },
                {
                    fn gameOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameOverCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::gameOver)
                    }
                    gameOver
                },
                {
                    fn refundModeCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <refundModeCreditCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::refundModeCredit)
                    }
                    refundModeCredit
                },
                {
                    fn aggregationVkey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <aggregationVkeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::aggregationVkey)
                    }
                    aggregationVkey
                },
                {
                    fn createdAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <createdAtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::createdAt)
                    }
                    createdAt
                },
                {
                    fn maxChallengeDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <maxChallengeDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::maxChallengeDuration)
                    }
                    maxChallengeDuration
                },
                {
                    fn challenge(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <challengeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::challenge)
                    }
                    challenge
                },
                {
                    fn credit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <creditCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::credit)
                    }
                    credit
                },
                {
                    fn disputeGameFactory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <disputeGameFactoryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::disputeGameFactory)
                    }
                    disputeGameFactory
                },
                {
                    fn gameData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameDataCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameCalls::gameData)
                    }
                    gameData
                },
                {
                    fn accessManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <accessManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::accessManager)
                    }
                    accessManager
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls>] = &[
                {
                    fn resolvedAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <resolvedAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::resolvedAt)
                    }
                    resolvedAt
                },
                {
                    fn status(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <statusCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::status)
                    }
                    status
                },
                {
                    fn wasRespectedGameTypeWhenCreated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameCalls::wasRespectedGameTypeWhenCreated,
                            )
                    }
                    wasRespectedGameTypeWhenCreated
                },
                {
                    fn startingRootHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingRootHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingRootHash)
                    }
                    startingRootHash
                },
                {
                    fn resolve(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <resolveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::resolve)
                    }
                    resolve
                },
                {
                    fn rangeVkeyCommitment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::rangeVkeyCommitment)
                    }
                    rangeVkeyCommitment
                },
                {
                    fn prove(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <proveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::prove)
                    }
                    prove
                },
                {
                    fn bondDistributionMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <bondDistributionModeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::bondDistributionMode)
                    }
                    bondDistributionMode
                },
                {
                    fn gameCreator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameCreatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::gameCreator)
                    }
                    gameCreator
                },
                {
                    fn claimData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <claimDataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::claimData)
                    }
                    claimData
                },
                {
                    fn normalModeCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <normalModeCreditCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::normalModeCredit)
                    }
                    normalModeCredit
                },
                {
                    fn sp1Verifier(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <sp1VerifierCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::sp1Verifier)
                    }
                    sp1Verifier
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::version)
                    }
                    version
                },
                {
                    fn startingOutputRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingOutputRootCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingOutputRoot)
                    }
                    startingOutputRoot
                },
                {
                    fn anchorStateRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <anchorStateRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::anchorStateRegistry)
                    }
                    anchorStateRegistry
                },
                {
                    fn extraData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <extraDataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::extraData)
                    }
                    extraData
                },
                {
                    fn claimCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <claimCreditCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::claimCredit)
                    }
                    claimCredit
                },
                {
                    fn l1Head(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l1HeadCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::l1Head)
                    }
                    l1Head
                },
                {
                    fn challengerBond(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <challengerBondCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::challengerBond)
                    }
                    challengerBond
                },
                {
                    fn rollupConfigHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rollupConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::rollupConfigHash)
                    }
                    rollupConfigHash
                },
                {
                    fn startingBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <startingBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::startingBlockNumber)
                    }
                    startingBlockNumber
                },
                {
                    fn closeGame(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <closeGameCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::closeGame)
                    }
                    closeGame
                },
                {
                    fn parentIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <parentIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::parentIndex)
                    }
                    parentIndex
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::initialize)
                    }
                    initialize
                },
                {
                    fn l2BlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l2BlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::l2BlockNumber)
                    }
                    l2BlockNumber
                },
                {
                    fn l2SequenceNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <l2SequenceNumberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::l2SequenceNumber)
                    }
                    l2SequenceNumber
                },
                {
                    fn gameType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameTypeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::gameType)
                    }
                    gameType
                },
                {
                    fn maxProveDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <maxProveDurationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::maxProveDuration)
                    }
                    maxProveDuration
                },
                {
                    fn rootClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <rootClaimCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::rootClaim)
                    }
                    rootClaim
                },
                {
                    fn gameOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameOverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::gameOver)
                    }
                    gameOver
                },
                {
                    fn refundModeCredit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <refundModeCreditCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::refundModeCredit)
                    }
                    refundModeCredit
                },
                {
                    fn aggregationVkey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <aggregationVkeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::aggregationVkey)
                    }
                    aggregationVkey
                },
                {
                    fn createdAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <createdAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::createdAt)
                    }
                    createdAt
                },
                {
                    fn maxChallengeDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <maxChallengeDurationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::maxChallengeDuration)
                    }
                    maxChallengeDuration
                },
                {
                    fn challenge(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <challengeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::challenge)
                    }
                    challenge
                },
                {
                    fn credit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <creditCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::credit)
                    }
                    credit
                },
                {
                    fn disputeGameFactory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <disputeGameFactoryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::disputeGameFactory)
                    }
                    disputeGameFactory
                },
                {
                    fn gameData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <gameDataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::gameData)
                    }
                    gameData
                },
                {
                    fn accessManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameCalls> {
                        <accessManagerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameCalls::accessManager)
                    }
                    accessManager
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::accessManager(inner) => {
                    <accessManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::aggregationVkey(inner) => {
                    <aggregationVkeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::anchorStateRegistry(inner) => {
                    <anchorStateRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bondDistributionMode(inner) => {
                    <bondDistributionModeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challenge(inner) => {
                    <challengeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengerBond(inner) => {
                    <challengerBondCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimCredit(inner) => {
                    <claimCreditCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimData(inner) => {
                    <claimDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::closeGame(inner) => {
                    <closeGameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::createdAt(inner) => {
                    <createdAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::credit(inner) => {
                    <creditCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::disputeGameFactory(inner) => {
                    <disputeGameFactoryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::extraData(inner) => {
                    <extraDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gameCreator(inner) => {
                    <gameCreatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gameData(inner) => {
                    <gameDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gameOver(inner) => {
                    <gameOverCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gameType(inner) => {
                    <gameTypeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::l1Head(inner) => {
                    <l1HeadCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::l2BlockNumber(inner) => {
                    <l2BlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::l2SequenceNumber(inner) => {
                    <l2SequenceNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxChallengeDuration(inner) => {
                    <maxChallengeDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxProveDuration(inner) => {
                    <maxProveDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::normalModeCredit(inner) => {
                    <normalModeCreditCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parentIndex(inner) => {
                    <parentIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::prove(inner) => {
                    <proveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rangeVkeyCommitment(inner) => {
                    <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refundModeCredit(inner) => {
                    <refundModeCreditCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolve(inner) => {
                    <resolveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::resolvedAt(inner) => {
                    <resolvedAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rollupConfigHash(inner) => {
                    <rollupConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rootClaim(inner) => {
                    <rootClaimCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sp1Verifier(inner) => {
                    <sp1VerifierCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startingBlockNumber(inner) => {
                    <startingBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startingOutputRoot(inner) => {
                    <startingOutputRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startingRootHash(inner) => {
                    <startingRootHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::status(inner) => {
                    <statusCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::wasRespectedGameTypeWhenCreated(inner) => {
                    <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::accessManager(inner) => {
                    <accessManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::aggregationVkey(inner) => {
                    <aggregationVkeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::anchorStateRegistry(inner) => {
                    <anchorStateRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bondDistributionMode(inner) => {
                    <bondDistributionModeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challenge(inner) => {
                    <challengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengerBond(inner) => {
                    <challengerBondCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimCredit(inner) => {
                    <claimCreditCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimData(inner) => {
                    <claimDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeGame(inner) => {
                    <closeGameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createdAt(inner) => {
                    <createdAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::credit(inner) => {
                    <creditCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::disputeGameFactory(inner) => {
                    <disputeGameFactoryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::extraData(inner) => {
                    <extraDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameCreator(inner) => {
                    <gameCreatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameData(inner) => {
                    <gameDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameOver(inner) => {
                    <gameOverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gameType(inner) => {
                    <gameTypeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l1Head(inner) => {
                    <l1HeadCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::l2BlockNumber(inner) => {
                    <l2BlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l2SequenceNumber(inner) => {
                    <l2SequenceNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxChallengeDuration(inner) => {
                    <maxChallengeDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxProveDuration(inner) => {
                    <maxProveDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::normalModeCredit(inner) => {
                    <normalModeCreditCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parentIndex(inner) => {
                    <parentIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::prove(inner) => {
                    <proveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::rangeVkeyCommitment(inner) => {
                    <rangeVkeyCommitmentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refundModeCredit(inner) => {
                    <refundModeCreditCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolve(inner) => {
                    <resolveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::resolvedAt(inner) => {
                    <resolvedAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rollupConfigHash(inner) => {
                    <rollupConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rootClaim(inner) => {
                    <rootClaimCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sp1Verifier(inner) => {
                    <sp1VerifierCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startingBlockNumber(inner) => {
                    <startingBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startingOutputRoot(inner) => {
                    <startingOutputRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startingRootHash(inner) => {
                    <startingRootHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::status(inner) => {
                    <statusCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::wasRespectedGameTypeWhenCreated(inner) => {
                    <wasRespectedGameTypeWhenCreatedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`OPSuccinctFaultDisputeGame`](self) custom errors.
    #[derive(Clone)]
    pub enum OPSuccinctFaultDisputeGameErrors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        BadAuth(BadAuth),
        #[allow(missing_docs)]
        BondTransferFailed(BondTransferFailed),
        #[allow(missing_docs)]
        ClaimAlreadyChallenged(ClaimAlreadyChallenged),
        #[allow(missing_docs)]
        ClaimAlreadyResolved(ClaimAlreadyResolved),
        #[allow(missing_docs)]
        GameNotFinalized(GameNotFinalized),
        #[allow(missing_docs)]
        GameNotOver(GameNotOver),
        #[allow(missing_docs)]
        GameOver(GameOver),
        #[allow(missing_docs)]
        IncorrectBondAmount(IncorrectBondAmount),
        #[allow(missing_docs)]
        IncorrectDisputeGameFactory(IncorrectDisputeGameFactory),
        #[allow(missing_docs)]
        InvalidBondDistributionMode(InvalidBondDistributionMode),
        #[allow(missing_docs)]
        InvalidParentGame(InvalidParentGame),
        #[allow(missing_docs)]
        InvalidProposalStatus(InvalidProposalStatus),
        #[allow(missing_docs)]
        NoCreditToClaim(NoCreditToClaim),
        #[allow(missing_docs)]
        ParentGameNotResolved(ParentGameNotResolved),
        #[allow(missing_docs)]
        UnexpectedRootClaim(UnexpectedRootClaim),
    }
    impl OPSuccinctFaultDisputeGameErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 100u8, 60u8, 57u8],
            [7u8, 138u8, 61u8, 244u8],
            [13u8, 193u8, 73u8, 240u8],
            [23u8, 191u8, 229u8, 247u8],
            [52u8, 97u8, 25u8, 247u8],
            [72u8, 81u8, 189u8, 155u8],
            [116u8, 146u8, 162u8, 105u8],
            [131u8, 230u8, 204u8, 107u8],
            [133u8, 195u8, 69u8, 176u8],
            [134u8, 32u8, 170u8, 25u8],
            [146u8, 197u8, 6u8, 174u8],
            [148u8, 13u8, 56u8, 199u8],
            [211u8, 134u8, 239u8, 62u8],
            [223u8, 70u8, 156u8, 203u8],
            [241u8, 169u8, 69u8, 129u8],
            [244u8, 2u8, 57u8, 219u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(GameNotOver),
            ::core::stringify!(InvalidBondDistributionMode),
            ::core::stringify!(AlreadyInitialized),
            ::core::stringify!(NoCreditToClaim),
            ::core::stringify!(InvalidParentGame),
            ::core::stringify!(GameNotFinalized),
            ::core::stringify!(InvalidProposalStatus),
            ::core::stringify!(BondTransferFailed),
            ::core::stringify!(ClaimAlreadyChallenged),
            ::core::stringify!(IncorrectBondAmount),
            ::core::stringify!(ParentGameNotResolved),
            ::core::stringify!(IncorrectDisputeGameFactory),
            ::core::stringify!(BadAuth),
            ::core::stringify!(GameOver),
            ::core::stringify!(ClaimAlreadyResolved),
            ::core::stringify!(UnexpectedRootClaim),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <GameNotOver as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidBondDistributionMode as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyInitialized as alloy_sol_types::SolError>::SIGNATURE,
            <NoCreditToClaim as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidParentGame as alloy_sol_types::SolError>::SIGNATURE,
            <GameNotFinalized as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidProposalStatus as alloy_sol_types::SolError>::SIGNATURE,
            <BondTransferFailed as alloy_sol_types::SolError>::SIGNATURE,
            <ClaimAlreadyChallenged as alloy_sol_types::SolError>::SIGNATURE,
            <IncorrectBondAmount as alloy_sol_types::SolError>::SIGNATURE,
            <ParentGameNotResolved as alloy_sol_types::SolError>::SIGNATURE,
            <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::SIGNATURE,
            <BadAuth as alloy_sol_types::SolError>::SIGNATURE,
            <GameOver as alloy_sol_types::SolError>::SIGNATURE,
            <ClaimAlreadyResolved as alloy_sol_types::SolError>::SIGNATURE,
            <UnexpectedRootClaim as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for OPSuccinctFaultDisputeGameErrors {
        const NAME: &'static str = "OPSuccinctFaultDisputeGameErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 16usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BadAuth(_) => <BadAuth as alloy_sol_types::SolError>::SELECTOR,
                Self::BondTransferFailed(_) => {
                    <BondTransferFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimAlreadyChallenged(_) => {
                    <ClaimAlreadyChallenged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimAlreadyResolved(_) => {
                    <ClaimAlreadyResolved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GameNotFinalized(_) => {
                    <GameNotFinalized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GameNotOver(_) => {
                    <GameNotOver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GameOver(_) => <GameOver as alloy_sol_types::SolError>::SELECTOR,
                Self::IncorrectBondAmount(_) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncorrectDisputeGameFactory(_) => {
                    <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBondDistributionMode(_) => {
                    <InvalidBondDistributionMode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidParentGame(_) => {
                    <InvalidParentGame as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidProposalStatus(_) => {
                    <InvalidProposalStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoCreditToClaim(_) => {
                    <NoCreditToClaim as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ParentGameNotResolved(_) => {
                    <ParentGameNotResolved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnexpectedRootClaim(_) => {
                    <UnexpectedRootClaim as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors>] = &[
                {
                    fn GameNotOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameNotOver as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameErrors::GameNotOver)
                    }
                    GameNotOver
                },
                {
                    fn InvalidBondDistributionMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidBondDistributionMode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::InvalidBondDistributionMode,
                            )
                    }
                    InvalidBondDistributionMode
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn NoCreditToClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <NoCreditToClaim as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::NoCreditToClaim)
                    }
                    NoCreditToClaim
                },
                {
                    fn InvalidParentGame(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidParentGame as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::InvalidParentGame)
                    }
                    InvalidParentGame
                },
                {
                    fn GameNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameNotFinalized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::GameNotFinalized)
                    }
                    GameNotFinalized
                },
                {
                    fn InvalidProposalStatus(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidProposalStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::InvalidProposalStatus)
                    }
                    InvalidProposalStatus
                },
                {
                    fn BondTransferFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <BondTransferFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::BondTransferFailed)
                    }
                    BondTransferFailed
                },
                {
                    fn ClaimAlreadyChallenged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ClaimAlreadyChallenged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::ClaimAlreadyChallenged,
                            )
                    }
                    ClaimAlreadyChallenged
                },
                {
                    fn IncorrectBondAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <IncorrectBondAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::IncorrectBondAmount)
                    }
                    IncorrectBondAmount
                },
                {
                    fn ParentGameNotResolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ParentGameNotResolved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::ParentGameNotResolved)
                    }
                    ParentGameNotResolved
                },
                {
                    fn IncorrectDisputeGameFactory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::IncorrectDisputeGameFactory,
                            )
                    }
                    IncorrectDisputeGameFactory
                },
                {
                    fn BadAuth(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <BadAuth as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameErrors::BadAuth)
                    }
                    BadAuth
                },
                {
                    fn GameOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameOver as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(OPSuccinctFaultDisputeGameErrors::GameOver)
                    }
                    GameOver
                },
                {
                    fn ClaimAlreadyResolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ClaimAlreadyResolved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::ClaimAlreadyResolved)
                    }
                    ClaimAlreadyResolved
                },
                {
                    fn UnexpectedRootClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <UnexpectedRootClaim as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::UnexpectedRootClaim)
                    }
                    UnexpectedRootClaim
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors>] = &[
                {
                    fn GameNotOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameNotOver as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::GameNotOver)
                    }
                    GameNotOver
                },
                {
                    fn InvalidBondDistributionMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidBondDistributionMode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::InvalidBondDistributionMode,
                            )
                    }
                    InvalidBondDistributionMode
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn NoCreditToClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <NoCreditToClaim as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::NoCreditToClaim)
                    }
                    NoCreditToClaim
                },
                {
                    fn InvalidParentGame(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidParentGame as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::InvalidParentGame)
                    }
                    InvalidParentGame
                },
                {
                    fn GameNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameNotFinalized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::GameNotFinalized)
                    }
                    GameNotFinalized
                },
                {
                    fn InvalidProposalStatus(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <InvalidProposalStatus as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::InvalidProposalStatus)
                    }
                    InvalidProposalStatus
                },
                {
                    fn BondTransferFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <BondTransferFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::BondTransferFailed)
                    }
                    BondTransferFailed
                },
                {
                    fn ClaimAlreadyChallenged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ClaimAlreadyChallenged as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::ClaimAlreadyChallenged,
                            )
                    }
                    ClaimAlreadyChallenged
                },
                {
                    fn IncorrectBondAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <IncorrectBondAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::IncorrectBondAmount)
                    }
                    IncorrectBondAmount
                },
                {
                    fn ParentGameNotResolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ParentGameNotResolved as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::ParentGameNotResolved)
                    }
                    ParentGameNotResolved
                },
                {
                    fn IncorrectDisputeGameFactory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                OPSuccinctFaultDisputeGameErrors::IncorrectDisputeGameFactory,
                            )
                    }
                    IncorrectDisputeGameFactory
                },
                {
                    fn BadAuth(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <BadAuth as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::BadAuth)
                    }
                    BadAuth
                },
                {
                    fn GameOver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <GameOver as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::GameOver)
                    }
                    GameOver
                },
                {
                    fn ClaimAlreadyResolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <ClaimAlreadyResolved as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::ClaimAlreadyResolved)
                    }
                    ClaimAlreadyResolved
                },
                {
                    fn UnexpectedRootClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<OPSuccinctFaultDisputeGameErrors> {
                        <UnexpectedRootClaim as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(OPSuccinctFaultDisputeGameErrors::UnexpectedRootClaim)
                    }
                    UnexpectedRootClaim
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BadAuth(inner) => {
                    <BadAuth as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::BondTransferFailed(inner) => {
                    <BondTransferFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimAlreadyChallenged(inner) => {
                    <ClaimAlreadyChallenged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimAlreadyResolved(inner) => {
                    <ClaimAlreadyResolved as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GameNotFinalized(inner) => {
                    <GameNotFinalized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GameNotOver(inner) => {
                    <GameNotOver as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::GameOver(inner) => {
                    <GameOver as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IncorrectBondAmount(inner) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IncorrectDisputeGameFactory(inner) => {
                    <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBondDistributionMode(inner) => {
                    <InvalidBondDistributionMode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidParentGame(inner) => {
                    <InvalidParentGame as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidProposalStatus(inner) => {
                    <InvalidProposalStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoCreditToClaim(inner) => {
                    <NoCreditToClaim as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ParentGameNotResolved(inner) => {
                    <ParentGameNotResolved as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnexpectedRootClaim(inner) => {
                    <UnexpectedRootClaim as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BadAuth(inner) => {
                    <BadAuth as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::BondTransferFailed(inner) => {
                    <BondTransferFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimAlreadyChallenged(inner) => {
                    <ClaimAlreadyChallenged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimAlreadyResolved(inner) => {
                    <ClaimAlreadyResolved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GameNotFinalized(inner) => {
                    <GameNotFinalized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GameNotOver(inner) => {
                    <GameNotOver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GameOver(inner) => {
                    <GameOver as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::IncorrectBondAmount(inner) => {
                    <IncorrectBondAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IncorrectDisputeGameFactory(inner) => {
                    <IncorrectDisputeGameFactory as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBondDistributionMode(inner) => {
                    <InvalidBondDistributionMode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidParentGame(inner) => {
                    <InvalidParentGame as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidProposalStatus(inner) => {
                    <InvalidProposalStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoCreditToClaim(inner) => {
                    <NoCreditToClaim as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ParentGameNotResolved(inner) => {
                    <ParentGameNotResolved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnexpectedRootClaim(inner) => {
                    <UnexpectedRootClaim as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`OPSuccinctFaultDisputeGame`](self) events.
    #[derive(Clone)]
    pub enum OPSuccinctFaultDisputeGameEvents {
        #[allow(missing_docs)]
        Challenged(Challenged),
        #[allow(missing_docs)]
        GameClosed(GameClosed),
        #[allow(missing_docs)]
        Proved(Proved),
        #[allow(missing_docs)]
        Resolved(Resolved),
    }
    impl OPSuccinctFaultDisputeGameEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                94u8, 24u8, 111u8, 9u8, 185u8, 201u8, 52u8, 145u8, 241u8, 78u8, 39u8,
                126u8, 234u8, 127u8, 170u8, 93u8, 230u8, 162u8, 212u8, 189u8, 167u8,
                90u8, 121u8, 175u8, 122u8, 54u8, 132u8, 251u8, 251u8, 66u8, 218u8, 96u8,
            ],
            [
                94u8, 101u8, 101u8, 217u8, 202u8, 47u8, 92u8, 133u8, 1u8, 214u8, 65u8,
                139u8, 245u8, 99u8, 50u8, 42u8, 114u8, 67u8, 186u8, 122u8, 206u8, 38u8,
                109u8, 117u8, 234u8, 201u8, 159u8, 74u8, 219u8, 179u8, 11u8, 167u8,
            ],
            [
                152u8, 2u8, 123u8, 56u8, 21u8, 63u8, 153u8, 92u8, 75u8, 128u8, 42u8,
                92u8, 126u8, 99u8, 101u8, 190u8, 227u8, 173u8, 219u8, 37u8, 175u8, 107u8,
                41u8, 129u8, 140u8, 12u8, 48u8, 70u8, 132u8, 216u8, 5u8, 44u8,
            ],
            [
                153u8, 8u8, 234u8, 172u8, 6u8, 69u8, 223u8, 157u8, 7u8, 4u8, 208u8,
                106u8, 220u8, 158u8, 7u8, 51u8, 124u8, 149u8, 29u8, 226u8, 240u8, 107u8,
                95u8, 40u8, 54u8, 21u8, 29u8, 72u8, 213u8, 228u8, 114u8, 47u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(Resolved),
            ::core::stringify!(Proved),
            ::core::stringify!(Challenged),
            ::core::stringify!(GameClosed),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <Resolved as alloy_sol_types::SolEvent>::SIGNATURE,
            <Proved as alloy_sol_types::SolEvent>::SIGNATURE,
            <Challenged as alloy_sol_types::SolEvent>::SIGNATURE,
            <GameClosed as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for OPSuccinctFaultDisputeGameEvents {
        const NAME: &'static str = "OPSuccinctFaultDisputeGameEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Challenged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Challenged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Challenged)
                }
                Some(<GameClosed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameClosed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::GameClosed)
                }
                Some(<Proved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Proved as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Proved)
                }
                Some(<Resolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Resolved as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Resolved)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for OPSuccinctFaultDisputeGameEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Challenged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameClosed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Proved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Resolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Challenged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameClosed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Proved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Resolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`OPSuccinctFaultDisputeGame`](self) contract instance.

See the [wrapper's documentation](`OPSuccinctFaultDisputeGameInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> OPSuccinctFaultDisputeGameInstance<P, N> {
        OPSuccinctFaultDisputeGameInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _maxChallengeDuration: <Duration as alloy::sol_types::SolType>::RustType,
        _maxProveDuration: <Duration as alloy::sol_types::SolType>::RustType,
        _disputeGameFactory: alloy::sol_types::private::Address,
        _sp1Verifier: alloy::sol_types::private::Address,
        _rollupConfigHash: alloy::sol_types::private::FixedBytes<32>,
        _aggregationVkey: alloy::sol_types::private::FixedBytes<32>,
        _rangeVkeyCommitment: alloy::sol_types::private::FixedBytes<32>,
        _challengerBond: alloy::sol_types::private::primitives::aliases::U256,
        _anchorStateRegistry: alloy::sol_types::private::Address,
        _accessManager: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<OPSuccinctFaultDisputeGameInstance<P, N>>,
    > {
        OPSuccinctFaultDisputeGameInstance::<
            P,
            N,
        >::deploy(
            __provider,
            _maxChallengeDuration,
            _maxProveDuration,
            _disputeGameFactory,
            _sp1Verifier,
            _rollupConfigHash,
            _aggregationVkey,
            _rangeVkeyCommitment,
            _challengerBond,
            _anchorStateRegistry,
            _accessManager,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _maxChallengeDuration: <Duration as alloy::sol_types::SolType>::RustType,
        _maxProveDuration: <Duration as alloy::sol_types::SolType>::RustType,
        _disputeGameFactory: alloy::sol_types::private::Address,
        _sp1Verifier: alloy::sol_types::private::Address,
        _rollupConfigHash: alloy::sol_types::private::FixedBytes<32>,
        _aggregationVkey: alloy::sol_types::private::FixedBytes<32>,
        _rangeVkeyCommitment: alloy::sol_types::private::FixedBytes<32>,
        _challengerBond: alloy::sol_types::private::primitives::aliases::U256,
        _anchorStateRegistry: alloy::sol_types::private::Address,
        _accessManager: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        OPSuccinctFaultDisputeGameInstance::<
            P,
            N,
        >::deploy_builder(
            __provider,
            _maxChallengeDuration,
            _maxProveDuration,
            _disputeGameFactory,
            _sp1Verifier,
            _rollupConfigHash,
            _aggregationVkey,
            _rangeVkeyCommitment,
            _challengerBond,
            _anchorStateRegistry,
            _accessManager,
        )
    }
    /**A [`OPSuccinctFaultDisputeGame`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`OPSuccinctFaultDisputeGame`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct OPSuccinctFaultDisputeGameInstance<
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for OPSuccinctFaultDisputeGameInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("OPSuccinctFaultDisputeGameInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > OPSuccinctFaultDisputeGameInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`OPSuccinctFaultDisputeGame`](self) contract instance.

See the [wrapper's documentation](`OPSuccinctFaultDisputeGameInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _maxChallengeDuration: <Duration as alloy::sol_types::SolType>::RustType,
            _maxProveDuration: <Duration as alloy::sol_types::SolType>::RustType,
            _disputeGameFactory: alloy::sol_types::private::Address,
            _sp1Verifier: alloy::sol_types::private::Address,
            _rollupConfigHash: alloy::sol_types::private::FixedBytes<32>,
            _aggregationVkey: alloy::sol_types::private::FixedBytes<32>,
            _rangeVkeyCommitment: alloy::sol_types::private::FixedBytes<32>,
            _challengerBond: alloy::sol_types::private::primitives::aliases::U256,
            _anchorStateRegistry: alloy::sol_types::private::Address,
            _accessManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<OPSuccinctFaultDisputeGameInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                _maxChallengeDuration,
                _maxProveDuration,
                _disputeGameFactory,
                _sp1Verifier,
                _rollupConfigHash,
                _aggregationVkey,
                _rangeVkeyCommitment,
                _challengerBond,
                _anchorStateRegistry,
                _accessManager,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _maxChallengeDuration: <Duration as alloy::sol_types::SolType>::RustType,
            _maxProveDuration: <Duration as alloy::sol_types::SolType>::RustType,
            _disputeGameFactory: alloy::sol_types::private::Address,
            _sp1Verifier: alloy::sol_types::private::Address,
            _rollupConfigHash: alloy::sol_types::private::FixedBytes<32>,
            _aggregationVkey: alloy::sol_types::private::FixedBytes<32>,
            _rangeVkeyCommitment: alloy::sol_types::private::FixedBytes<32>,
            _challengerBond: alloy::sol_types::private::primitives::aliases::U256,
            _anchorStateRegistry: alloy::sol_types::private::Address,
            _accessManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _maxChallengeDuration,
                            _maxProveDuration,
                            _disputeGameFactory,
                            _sp1Verifier,
                            _rollupConfigHash,
                            _aggregationVkey,
                            _rangeVkeyCommitment,
                            _challengerBond,
                            _anchorStateRegistry,
                            _accessManager,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> OPSuccinctFaultDisputeGameInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> OPSuccinctFaultDisputeGameInstance<P, N> {
            OPSuccinctFaultDisputeGameInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > OPSuccinctFaultDisputeGameInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`accessManager`] function.
        pub fn accessManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, accessManagerCall, N> {
            self.call_builder(&accessManagerCall)
        }
        ///Creates a new call builder for the [`aggregationVkey`] function.
        pub fn aggregationVkey(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, aggregationVkeyCall, N> {
            self.call_builder(&aggregationVkeyCall)
        }
        ///Creates a new call builder for the [`anchorStateRegistry`] function.
        pub fn anchorStateRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, anchorStateRegistryCall, N> {
            self.call_builder(&anchorStateRegistryCall)
        }
        ///Creates a new call builder for the [`bondDistributionMode`] function.
        pub fn bondDistributionMode(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, bondDistributionModeCall, N> {
            self.call_builder(&bondDistributionModeCall)
        }
        ///Creates a new call builder for the [`challenge`] function.
        pub fn challenge(&self) -> alloy_contract::SolCallBuilder<&P, challengeCall, N> {
            self.call_builder(&challengeCall)
        }
        ///Creates a new call builder for the [`challengerBond`] function.
        pub fn challengerBond(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, challengerBondCall, N> {
            self.call_builder(&challengerBondCall)
        }
        ///Creates a new call builder for the [`claimCredit`] function.
        pub fn claimCredit(
            &self,
            _recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, claimCreditCall, N> {
            self.call_builder(&claimCreditCall { _recipient })
        }
        ///Creates a new call builder for the [`claimData`] function.
        pub fn claimData(&self) -> alloy_contract::SolCallBuilder<&P, claimDataCall, N> {
            self.call_builder(&claimDataCall)
        }
        ///Creates a new call builder for the [`closeGame`] function.
        pub fn closeGame(&self) -> alloy_contract::SolCallBuilder<&P, closeGameCall, N> {
            self.call_builder(&closeGameCall)
        }
        ///Creates a new call builder for the [`createdAt`] function.
        pub fn createdAt(&self) -> alloy_contract::SolCallBuilder<&P, createdAtCall, N> {
            self.call_builder(&createdAtCall)
        }
        ///Creates a new call builder for the [`credit`] function.
        pub fn credit(
            &self,
            _recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, creditCall, N> {
            self.call_builder(&creditCall { _recipient })
        }
        ///Creates a new call builder for the [`disputeGameFactory`] function.
        pub fn disputeGameFactory(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, disputeGameFactoryCall, N> {
            self.call_builder(&disputeGameFactoryCall)
        }
        ///Creates a new call builder for the [`extraData`] function.
        pub fn extraData(&self) -> alloy_contract::SolCallBuilder<&P, extraDataCall, N> {
            self.call_builder(&extraDataCall)
        }
        ///Creates a new call builder for the [`gameCreator`] function.
        pub fn gameCreator(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, gameCreatorCall, N> {
            self.call_builder(&gameCreatorCall)
        }
        ///Creates a new call builder for the [`gameData`] function.
        pub fn gameData(&self) -> alloy_contract::SolCallBuilder<&P, gameDataCall, N> {
            self.call_builder(&gameDataCall)
        }
        ///Creates a new call builder for the [`gameOver`] function.
        pub fn gameOver(&self) -> alloy_contract::SolCallBuilder<&P, gameOverCall, N> {
            self.call_builder(&gameOverCall)
        }
        ///Creates a new call builder for the [`gameType`] function.
        pub fn gameType(&self) -> alloy_contract::SolCallBuilder<&P, gameTypeCall, N> {
            self.call_builder(&gameTypeCall)
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(&initializeCall)
        }
        ///Creates a new call builder for the [`l1Head`] function.
        pub fn l1Head(&self) -> alloy_contract::SolCallBuilder<&P, l1HeadCall, N> {
            self.call_builder(&l1HeadCall)
        }
        ///Creates a new call builder for the [`l2BlockNumber`] function.
        pub fn l2BlockNumber(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, l2BlockNumberCall, N> {
            self.call_builder(&l2BlockNumberCall)
        }
        ///Creates a new call builder for the [`l2SequenceNumber`] function.
        pub fn l2SequenceNumber(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, l2SequenceNumberCall, N> {
            self.call_builder(&l2SequenceNumberCall)
        }
        ///Creates a new call builder for the [`maxChallengeDuration`] function.
        pub fn maxChallengeDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, maxChallengeDurationCall, N> {
            self.call_builder(&maxChallengeDurationCall)
        }
        ///Creates a new call builder for the [`maxProveDuration`] function.
        pub fn maxProveDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, maxProveDurationCall, N> {
            self.call_builder(&maxProveDurationCall)
        }
        ///Creates a new call builder for the [`normalModeCredit`] function.
        pub fn normalModeCredit(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, normalModeCreditCall, N> {
            self.call_builder(&normalModeCreditCall(_0))
        }
        ///Creates a new call builder for the [`parentIndex`] function.
        pub fn parentIndex(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, parentIndexCall, N> {
            self.call_builder(&parentIndexCall)
        }
        ///Creates a new call builder for the [`prove`] function.
        pub fn prove(
            &self,
            proofBytes: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, proveCall, N> {
            self.call_builder(&proveCall { proofBytes })
        }
        ///Creates a new call builder for the [`rangeVkeyCommitment`] function.
        pub fn rangeVkeyCommitment(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, rangeVkeyCommitmentCall, N> {
            self.call_builder(&rangeVkeyCommitmentCall)
        }
        ///Creates a new call builder for the [`refundModeCredit`] function.
        pub fn refundModeCredit(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, refundModeCreditCall, N> {
            self.call_builder(&refundModeCreditCall(_0))
        }
        ///Creates a new call builder for the [`resolve`] function.
        pub fn resolve(&self) -> alloy_contract::SolCallBuilder<&P, resolveCall, N> {
            self.call_builder(&resolveCall)
        }
        ///Creates a new call builder for the [`resolvedAt`] function.
        pub fn resolvedAt(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, resolvedAtCall, N> {
            self.call_builder(&resolvedAtCall)
        }
        ///Creates a new call builder for the [`rollupConfigHash`] function.
        pub fn rollupConfigHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, rollupConfigHashCall, N> {
            self.call_builder(&rollupConfigHashCall)
        }
        ///Creates a new call builder for the [`rootClaim`] function.
        pub fn rootClaim(&self) -> alloy_contract::SolCallBuilder<&P, rootClaimCall, N> {
            self.call_builder(&rootClaimCall)
        }
        ///Creates a new call builder for the [`sp1Verifier`] function.
        pub fn sp1Verifier(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, sp1VerifierCall, N> {
            self.call_builder(&sp1VerifierCall)
        }
        ///Creates a new call builder for the [`startingBlockNumber`] function.
        pub fn startingBlockNumber(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, startingBlockNumberCall, N> {
            self.call_builder(&startingBlockNumberCall)
        }
        ///Creates a new call builder for the [`startingOutputRoot`] function.
        pub fn startingOutputRoot(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, startingOutputRootCall, N> {
            self.call_builder(&startingOutputRootCall)
        }
        ///Creates a new call builder for the [`startingRootHash`] function.
        pub fn startingRootHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, startingRootHashCall, N> {
            self.call_builder(&startingRootHashCall)
        }
        ///Creates a new call builder for the [`status`] function.
        pub fn status(&self) -> alloy_contract::SolCallBuilder<&P, statusCall, N> {
            self.call_builder(&statusCall)
        }
        ///Creates a new call builder for the [`version`] function.
        pub fn version(&self) -> alloy_contract::SolCallBuilder<&P, versionCall, N> {
            self.call_builder(&versionCall)
        }
        ///Creates a new call builder for the [`wasRespectedGameTypeWhenCreated`] function.
        pub fn wasRespectedGameTypeWhenCreated(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, wasRespectedGameTypeWhenCreatedCall, N> {
            self.call_builder(&wasRespectedGameTypeWhenCreatedCall)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > OPSuccinctFaultDisputeGameInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Challenged`] event.
        pub fn Challenged_filter(&self) -> alloy_contract::Event<&P, Challenged, N> {
            self.event_filter::<Challenged>()
        }
        ///Creates a new event filter for the [`GameClosed`] event.
        pub fn GameClosed_filter(&self) -> alloy_contract::Event<&P, GameClosed, N> {
            self.event_filter::<GameClosed>()
        }
        ///Creates a new event filter for the [`Proved`] event.
        pub fn Proved_filter(&self) -> alloy_contract::Event<&P, Proved, N> {
            self.event_filter::<Proved>()
        }
        ///Creates a new event filter for the [`Resolved`] event.
        pub fn Resolved_filter(&self) -> alloy_contract::Event<&P, Resolved, N> {
            self.event_filter::<Resolved>()
        }
    }
}
